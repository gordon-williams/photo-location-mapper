<!--
    Photo Location Mapper
    Copyright (c) 2026 Gordon Williams

    Licensed under the MIT License.
    See LICENSE file for details.

    https://github.com/gordon-williams/photo-location-mapper
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Location Mapper</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exifreader@4.21.1/dist/exif-reader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        button {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            outline: none;
            background: none;
            font-family: inherit;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 3px dashed transparent;
            transition: all 0.3s ease;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            text-align: center;
        }

        h1 {
            font-size: 1.5em;
            margin: 0 0 5px 0;
        }

        .subtitle {
            opacity: 0.9;
            font-size: 0.85em;
        }

        .upload-section {
            padding: 20px 30px;
            border-bottom: 1px solid #e0e0e0;
        }

        .upload-button {
            background: #667eea;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            vertical-align: middle;
            box-sizing: border-box;
            text-align: center;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .upload-button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .upload-button:active:not(:disabled) {
            transform: translateY(0);
        }
        
        .upload-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        input[type="file"] {
            display: none;
        }

        #routeInput {
            display: none;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: inline-block;
            max-width: 100%;
        }

        .stats-item {
            display: inline-block;
            margin: 0 12px 0 0;
            font-weight: 500;
            white-space: nowrap;
        }

        .photos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 30px;
        }

        .photo-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            transition: all 0.3s;
            position: relative;
            z-index: 0;
        }

        .photo-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }
        
        .photo-delete-btn {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(220, 53, 69, 0.95);
            color: white;
            border: 2px solid white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .photo-delete-btn:hover {
            background: rgba(200, 35, 51, 1);
            transform: scale(1.1);
        }
        
        .gps-input-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        
        .gps-input-row label {
            font-weight: 600;
            min-width: 70px;
        }
        
        .gps-input {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }
        
        .gps-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .gps-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            justify-content: flex-end;
        }
        
        .gps-btn {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            color: #333;
            cursor: pointer;
        }
        
        .gps-btn:disabled {
            background: #f0f0f0;
            color: #999;
            cursor: not-allowed;
        }
        
        .gps-btn:hover:not(:disabled) {
            background: #f5f5f5;
            border-color: #999;
        }
        
        .photo-card.highlight-moved {
            animation: highlightPulse 1.5s ease-out;
        }
        
        @keyframes highlightPulse {
            0% { box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.8); background: rgba(102, 126, 234, 0.1); }
            100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0); background: white; }
        }
        
        /* Lightbox for large photo preview */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 20000;
            justify-content: center;
            align-items: center;
        }
        
        .lightbox.active {
            display: flex;
        }
        
        .lightbox-content {
            position: relative;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .lightbox-img {
            max-width: 95vw;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 4px;
        }
        
        .lightbox-caption {
            color: white;
            margin-top: 10px;
            font-size: 14px;
            text-align: center;
        }
        
        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 32px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 20001;
        }
        
        .lightbox-close:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 28px;
            width: 50px;
            height: 80px;
            cursor: pointer;
            z-index: 20001;
        }
        
        .lightbox-nav:hover {
            background: rgba(255,255,255,0.3);
        }
        
        .lightbox-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .lightbox-prev {
            left: 20px;
            border-radius: 4px;
        }
        
        .lightbox-next {
            right: 20px;
            border-radius: 4px;
        }
        
        .lightbox-counter {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .photo-preview {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background: #f0f0f0;
            cursor: grab;
            user-select: none;
        }

        .photo-preview:active {
            cursor: grabbing;
        }

        .photo-preview-container {
            width: 100%;
            height: 225px;
            overflow: hidden;
            position: relative;
            background: #f0f0f0;
            z-index: 1;
            cursor: pointer;
        }
        
        .photo-preview-container::before {
            content: '‚õ∂';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        .photo-preview-container:hover::before {
            opacity: 1;
        }

        .photo-preview-container::after {
            content: 'üñêÔ∏è Drag ‚Ä¢ üîç Zoom';
            position: absolute;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 5;
        }

        .photo-preview-container:hover::after {
            opacity: 1;
        }

        .photo-preview-draggable {
            cursor: grab;
            user-select: none;
            display: block;
            transform-origin: top left;
        }

        .photo-preview-draggable:active {
            cursor: grabbing;
        }

        .reset-pan {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .reset-pan:hover {
            background: white;
        }

        .zoom-controls {
            position: absolute;
            bottom: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            background: rgba(255,255,255,0.9);
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .zoom-btn:hover {
            background: white;
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .map-style-selector {
            padding: 8px 15px;
            background: white;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .map-style-selector label {
            font-weight: 500;
            color: #333;
        }

        .map-style-selector select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9em;
            background: white;
            cursor: pointer;
        }

        #routeFilterContainer {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #activityCheckboxes {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        #activityCheckboxes label {
            transition: all 0.2s ease;
        }

        #activityCheckboxes label:hover {
            background: #e9ecef !important;
        }

        .photo-info {
            padding: 15px;
        }

        .photo-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            font-size: 0.9em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .location-data {
            font-size: 0.85em;
            color: #666;
            line-height: 1.8;
        }

        .location-data strong {
            color: #333;
            display: inline-block;
            min-width: 80px;
        }

        .no-gps {
            color: #e74c3c;
            font-style: italic;
        }

        .map-controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .map-button, .save-button, .clear-button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .map-button {
            background: #27ae60;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            cursor: pointer;
            transition: all 0.3s;
            box-sizing: border-box;
            vertical-align: middle;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .map-button:hover:not(:disabled) {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }
        
        .map-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .save-button {
            background: #667eea;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            transition: all 0.2s;
            box-sizing: border-box;
            vertical-align: middle;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .save-button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .save-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .clear-button {
            background: #e74c3c;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            cursor: pointer;
            transition: all 0.3s;
            box-sizing: border-box;
            vertical-align: middle;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .clear-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        .map-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .map-modal.active {
            display: flex;
        }
        /* Gallery window: draggable + resizable (non-blocking look) */
        #galleryModal {
            background: transparent;
            align-items: flex-start;
            justify-content: flex-start;
            pointer-events: none; /* allow clicks only on the window itself */
        }
        #galleryModal .map-container-wrapper {
            position: absolute;
            top: 80px;
            left: 80px;
            width: 70vw;
            height: 70vh;
            max-width: 95vw;
            max-height: 90vh;
            min-width: 360px;
            min-height: 260px;
            resize: both;
            overflow: auto;
            border-radius: 10px;
            box-shadow: 0 12px 35px rgba(0,0,0,0.35);
            pointer-events: auto;
            display: block !important;
        }
        #galleryModal .map-header {
            cursor: move;
            user-select: none;
        }


        .map-container-wrapper {
            background: white;
            border-radius: 0;
            width: 100%;
            max-width: 100%;
            height: 100%;
            max-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: none;
        }

        .map-header {
            padding: 10px 15px;
            background: #667eea;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .map-header h2 {
            margin: 0;
            font-size: 1.1em;
        }

        .close-button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 1.3em;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }

        .close-button:hover {
            background: rgba(255,255,255,0.3);
        }

        #mapContainer {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 400px;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #fee;
            color: #c33;
            padding: 15px;
            margin: 20px 30px;
            border-radius: 8px;
            border-left: 4px solid #c33;
        }

        @media (max-width: 768px) {
            .photos-grid {
                grid-template-columns: 1fr;
            }

            #mapContainer {
                min-height: 300px;
            }

            .map-container-wrapper {
                max-height: 100vh;
            }

            .map-modal {
                padding: 0;
            }

            .stats-item {
                display: block;
                margin: 5px 0;
            }

            .upload-section {
                flex-direction: column;
            }

            .upload-button {
                width: 100%;
                margin: 5px 0 !important;
            }

            .map-style-selector {
                flex-wrap: wrap;
                gap: 10px;
            }

            .map-style-selector button {
                width: 100%;
                margin: 10px 0 0 0 !important;
            }

            .gallery-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .gallery-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .marker-popup {
            text-align: center;
        }

        .marker-popup img {
            width: 150px;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .marker-popup .filename {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .marker-popup .coords {
            font-size: 0.85em;
            color: #666;
        }

        .numbered-marker {
            z-index: 1000 !important;
        }

        #galleryContainer {
            transition: background 0.3s ease;
        }
        
        #galleryContainer::-webkit-scrollbar {
            width: 8px;
        }
        
        #galleryContainer::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #galleryContainer::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        #galleryContainer::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        #gallerySaveBtn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3) !important;
        }
        
        #gallerySaveBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 0;
        }

        .gallery-item {
            position: relative;
            aspect-ratio: 4 / 3;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background: #f5f5f5;
        }

        .gallery-item img {
            width: 100%;
            height: 100%;
            display: block;
        }

        .gallery-item-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 64px;
        }

        .gallery-number {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #667eea;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border: 3px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 2;
        }

        @keyframes glow {
            0%, 100% { 
                box-shadow: 0 0 0px rgba(39, 174, 96, 0);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 0 20px rgba(39, 174, 96, 0.8);
                transform: scale(1.05);
            }
        }
    
        /* Gallery thumbnails should use the same 4:3 tile behaviour as the main window */
        .gallery-item .photo-preview-container {
            height: 100%;
            background: #f0f0f0;
        }
        .gallery-item .photo-preview-container::after {
            display: none;
        }
        .gallery-item .photo-preview-draggable {
            cursor: default;
        }


/* === Unified main control buttons === */
.ctrl-btn {
  border: none;
  border-radius: 10px;
  padding: 10px 18px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: #fff;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  min-height: 36px;
}

.ctrl-btn.green { background:#4CAF50; }
.ctrl-btn.green:hover { background:#43a047; }

.ctrl-btn.blue { background:#2196F3; }
.ctrl-btn.blue:hover { background:#1e88e5; }

.ctrl-btn.red { background:#f44336; }
.ctrl-btn.red:hover { background:#e53935; }

.ctrl-btn[disabled] {
  background: #9e9e9e !important;
  opacity: 1;
  cursor: not-allowed;
}
.ctrl-btn[disabled]:hover { background: #9e9e9e !important; }

/* Floating Photo Popup Panels */
.photo-popup-panel {
    position: absolute;
    background: white;
    border-radius: 10px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    min-width: 280px;
    min-height: 200px;
    max-width: 90vw;
    max-height: 80vh;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    resize: both;
}

.photo-popup-header {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 10px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: move;
    user-select: none;
    flex-shrink: 0;
}

.photo-popup-header h3 {
    margin: 0;
    font-size: 0.95em;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: calc(100% - 30px);
}

.photo-popup-close {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.1em;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    flex-shrink: 0;
}

.photo-popup-close:hover {
    background: rgba(255,255,255,0.35);
}

.photo-popup-content {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
    display: flex;
    flex-direction: column;
}

.photo-popup-image-container {
    position: relative;
    width: 100%;
    min-height: 150px;
    flex: 1;
    overflow: hidden;
    border-radius: 6px;
    background: #f5f5f5;
    margin-bottom: 10px;
}

.photo-popup-image {
    display: block;
    transform-origin: top left;
    cursor: grab;
    user-select: none;
}

.photo-popup-image:active {
    cursor: grabbing;
}

.photo-popup-number {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: #667eea;
    color: white;
    width: 42px;
    height: 42px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 18px;
    border: 3px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    z-index: 5;
    pointer-events: none;
}

.photo-popup-placeholder {
    width: 100%;
    height: 150px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    border-radius: 6px;
    margin-bottom: 10px;
    position: relative;
}

.photo-popup-details {
    font-size: 0.85em;
    color: #555;
    margin-bottom: 12px;
}

.photo-popup-details div {
    margin-bottom: 4px;
}

.photo-popup-details strong {
    color: #333;
}

.photo-popup-comment-section {
    border-top: 1px solid #eee;
    padding-top: 10px;
}

.photo-popup-comment-section label {
    display: block;
    font-weight: 600;
    font-size: 0.85em;
    color: #333;
    margin-bottom: 6px;
}

.photo-popup-comment {
    width: 100%;
    min-height: 60px;
    padding: 8px 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-family: inherit;
    font-size: 0.9em;
    resize: vertical;
    transition: border-color 0.2s;
}

.photo-popup-comment:focus {
    outline: none;
    border-color: #667eea;
}

.photo-popup-comment-saved {
    font-size: 0.75em;
    color: #27ae60;
    margin-top: 4px;
    opacity: 0;
    transition: opacity 0.3s;
}

.photo-popup-comment-saved.visible {
    opacity: 1;
}

.photo-popup-resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 16px;
    height: 16px;
    cursor: nwse-resize;
    background: linear-gradient(135deg, transparent 50%, #ccc 50%, #ccc 60%, transparent 60%, transparent 70%, #ccc 70%, #ccc 80%, transparent 80%);
}

/* Photo Markers on Map */
.photo-marker {
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 3px 10px rgba(0,0,0,0.6), 0 0 0 1px rgba(0,0,0,0.3), 0 8px 25px rgba(0,0,0,0.4);
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    background: #667eea;
}

.photo-marker:hover {
    transform: scale(1.1);
    box-shadow: 0 5px 15px rgba(0,0,0,0.7), 0 0 0 1px rgba(0,0,0,0.4), 0 12px 35px rgba(0,0,0,0.5);
    z-index: 10000 !important;
}

.photo-marker-container {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative;
}

.photo-marker-img {
    display: block;
    transform-origin: top left;
    cursor: grab;
    user-select: none;
}

.photo-marker-img:active {
    cursor: grabbing;
}

.photo-marker-number {
    position: absolute;
    bottom: -12px;
    left: -12px;
    background: #667eea;
    color: white;
    min-width: 28px;
    height: 28px;
    border-radius: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    padding: 0 6px;
    border: 2px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.5), 0 4px 12px rgba(0,0,0,0.3);
    pointer-events: none;
}

.photo-marker-badge-icon .photo-marker-number {
    position: static;
}

/* Orbital draggable badge */
.orbital-badge {
    position: absolute !important;
    pointer-events: auto !important;
    cursor: grab;
    transition: box-shadow 0.1s ease;
    min-width: 28px;
    height: 28px;
    border-radius: 14px;
    font-size: 14px;
    padding: 0 6px;
    border: 2px solid white;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #667eea;
    color: white;
    font-weight: bold;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4), 0 12px 30px rgba(0,0,0,0.25);
}

.orbital-badge:hover {
    box-shadow: 0 5px 12px rgba(102, 126, 234, 0.8), 0 10px 25px rgba(0,0,0,0.5);
    background: #667eea;
}

.orbital-badge:active {
    cursor: grabbing;
    box-shadow: 0 6px 15px rgba(102, 126, 234, 1), 0 12px 30px rgba(0,0,0,0.5);
}

.photo-marker-placeholder {
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.photo-marker-badge-icon {
    background: transparent !important;
    border: none !important;
    overflow: visible !important;
    position: relative;
    pointer-events: none !important;
}

.leaflet-div-icon {
    background: transparent;
    border: none;
}

.photo-marker-icon {
    overflow: visible !important;
}

/* Ensure Leaflet marker pane allows shadow overflow */
.leaflet-marker-pane,
.leaflet-marker-icon {
    overflow: visible !important;
}

/* GPS location dot (shown when marker is dragged away) */
.gps-location-dot {
    background: #667eea;
    border: 2px solid white;
    border-radius: 50%;
    box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Spider cluster lines */
.spider-leg {
    stroke: #667eea;
    stroke-width: 2;
    stroke-opacity: 0.6;
}

.spider-leg-hover {
    stroke-opacity: 1;
    stroke-width: 3;
}

</style>
</head>
<body>
    <div class="container">
        <header>
            <h1 style="margin: 0 0 5px 0; font-size: 1.5em;">Photo Location Mapper</h1>
            <div class="subtitle" style="font-size: 0.85em;">Extract GPS data from photos and visualize on a map</div>
            <div style="font-size: 0.7em; opacity: 0.7; margin-top: 4px;">v1.1.0</div>
        </header>

        <div class="upload-section">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;">
                <div style="display: flex; gap: 10px;">
                    <button class="ctrl-btn blue" id="selectPhotosButton">Select Photos</button>
                    <input type="file" id="fileInput" accept="image/jpeg,image/jpg,image/heic,image/heif" multiple style="display: none;">
                    
                    <button class="ctrl-btn blue" id="routeButton" title="Load route file (GPX or Google Takeout JSON)">Load Route</button>
                    <input type="file" id="routeInput" accept=".gpx,.json,.gz" style="display: none;">
                </div>
                
                <div id="stats" style="display: none; font-size: 0.9em; color: #555;">
                    <span class="stats-item"><span id="photoCount">0</span> photos</span>
                    <span class="stats-item"><span id="gpsCount">0</span> GPS</span>
                    <span class="stats-item" id="dateRangeStats" style="display: none;"><span id="dateRange"></span></span>
                    <span class="stats-item" id="routeStats" style="display: none;"><span id="routeCount">0</span> routes</span>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button class="ctrl-btn green" id="showMapButton" disabled>Map</button>
                    <button class="ctrl-btn green" id="showGalleryButton" disabled>Gallery</button>
                    <button class="ctrl-btn red" id="clearButton" disabled>Clear All</button>
                </div>
            </div>
            
            <div style="margin-top: 8px; font-size: 0.85em; color: #666;">
                Or drag and drop photos anywhere on this page
                <span id="lastPathsInfo" style="margin-left: 15px; color: #888;"></span>
            </div>
        </div>

        <div id="loadingIndicator" class="loading" style="display: none;">
            <div class="spinner"></div>
            <div>Processing photos...</div>
        </div>

        <div id="errorContainer"></div>

        <div class="photos-grid" id="photosGrid"></div>

    </div>

    <div class="map-modal" id="mapModal">
        <div class="map-container-wrapper">
            <div class="map-header">
                <h2 id="mapPanelTitle">Photo Locations</h2>
                <button class="close-button" id="closeMapButton">√ó</button>
            </div>
            <div class="map-style-selector">
                <label for="mapStyleSelect">üó∫Ô∏è Map Style:</label>
                <select id="mapStyleSelect">
                    <option value="osm">Street Map (Standard navigation)</option>
                    <option value="satellite">Satellite (Aerial imagery)</option>
                    <option value="cycle">Cycle Map (Bike routes with contours)</option>
                    <option value="humanitarian" selected>Humanitarian (Clear, simple)</option>
                    <optgroup label="Mapbox (API key required)">
                        <option value="mapbox-streets">Mapbox Streets</option>
                        <option value="mapbox-outdoors">Mapbox Outdoors</option>
                        <option value="mapbox-satellite">Mapbox Satellite</option>
                        <option value="mapbox-satellite-streets">Mapbox Satellite Streets</option>
                    </optgroup>
                </select>
                <button id="mapboxKeyBtn" style="margin-left: 5px; padding: 2px 8px; font-size: 11px; cursor: pointer;" title="Configure Mapbox API key">üîë</button>
                <button id="toggle3DBtn" class="save-button" style="margin-left: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: none;" title="Toggle 3D terrain view (requires Mapbox API key)">üèîÔ∏è 3D View</button>

                <div id="routeFilterContainer" style="display: none; margin-left: 30px; flex: 1; align-items: center;">
                    <label>üìç Show Activities:</label>
                    <div id="activityCheckboxes" style="display: inline-flex; flex-wrap: wrap; gap: 10px; margin-left: 10px;">
                    </div>
                </div>
                
                <button class="save-button" id="photoMarkersBtn" style="margin-left: auto; background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);" title="Show photo thumbnails on map. Drag to move marker. Hold Option/Alt + drag to pan image within circle.">üì∑ Photo Markers</button>
                <button class="save-button" id="mapSaveBtn" style="margin-left: 10px;">üíæ Save Map as JPEG</button>
                <div id="markerSizeControl" style="display: none; margin-left: 10px; align-items: center; gap: 8px;">
                    <label style="font-size: 12px; white-space: nowrap;">Size:</label>
                    <input type="range" id="markerSizeSlider" min="50" max="400" value="70" style="width: 100px; cursor: pointer;">
                    <span id="markerSizeValue" style="font-size: 12px; min-width: 40px;">70px</span>
                </div>
                <div id="numberMarkerSizeControl" style="display: none; margin-left: 10px; align-items: center; gap: 8px;">
                    <label style="font-size: 12px; white-space: nowrap;">‚Ññ Size:</label>
                    <input type="range" id="numberMarkerSizeSlider" min="1" max="5" step="0.5" value="1" style="width: 80px; cursor: pointer;">
                    <span id="numberMarkerSizeValue" style="font-size: 12px; min-width: 30px;">1x</span>
                </div>
            </div>
            <div id="mapContainer" style="position: relative;">
                <div id="map"></div>
                <div id="map3d" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
            </div>
        </div>
        </div>
    </div>

    <!-- Gallery Modal -->
    <div class="map-modal" id="galleryModal">
        <div class="map-container-wrapper">
            <div class="map-header">
                <h2>Gallery</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="gallerySaveBtn" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: background 0.2s;">üíæ Save as JPEG</button>
                    <button class="close-button" id="closeGalleryButton">√ó</button>
                </div>
            </div>
            
            <div id="galleryContainer" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 20px; background: #3c3c3c;">
                <div id="galleryGrid" class="gallery-grid">
                </div>
            </div>
        </div>
    </div>

    <!-- Lightbox for large photo preview -->
    <div class="lightbox" id="lightbox">
        <button class="lightbox-close" id="lightboxClose">√ó</button>
        <button class="lightbox-nav lightbox-prev" id="lightboxPrev">‚Äπ</button>
        <button class="lightbox-nav lightbox-next" id="lightboxNext">‚Ä∫</button>
        <div class="lightbox-content">
            <img class="lightbox-img" id="lightboxImg" src="" alt="">
            <div class="lightbox-caption" id="lightboxCaption"></div>
        </div>
        <div class="lightbox-counter" id="lightboxCounter"></div>
    </div>

    <script>
        let photos = [];
        let routes = [];
        let routePolylines = [];
        let selectedActivities = new Set();
        let map = null;
        let map3d = null; // Mapbox GL JS 3D map
        let is3DMode = false;
        let currentTileLayer = null;
        let markers = [];
        let photoMarkersMode = false;
        let photoMarkers = [];
        let numberBadgeMarkers = [];
        let spiderLegs = [];
        let PHOTO_MARKER_SIZE = 70; // pixels, adjustable via slider
        let NUMBER_MARKER_SIZE = 32; // pixels for number markers, adjustable via slider
        let photoMarkerTransforms = {}; // Store manual adjustments by photo index
        let badgeOrbitalAngles = {}; // Store badge orbital angle by photo index (radians)
        let photoMarkerOffsets = {}; // Store marker position offsets from GPS location { index: { lat, lng } }
        let rubberbandLines = []; // Polylines connecting markers to their GPS locations
        let copiedGPS = null; // Stored GPS coordinates for copy/paste
        let highlightedPhotoName = null; // Photo name to highlight after re-sort
        let lightboxIndex = 0; // Current photo index in lightbox
        let photosWithUnsavedEdits = new Set(); // Track photos with unsaved changes
        let BADGE_SCALE = 1; // Scale factor for orbital number badges (1x to 5x)
        const BASE_BADGE_SIZE = 28; // Base badge size in pixels

        // Map state tracking - remembers user's map configuration during session
        let userHasInteractedWithMap = false; // True once user has zoomed/panned/configured map
        let savedMapState = null; // { center: {lat, lng}, zoom: number }

        // Global state for orbital badge dragging (to avoid duplicate document listeners)
        let orbitalDragState = null; // { badge, photoMarker, photoIndex, badgeSize, updateFn }
        
        // Global state for photo marker panning (to avoid duplicate document listeners)
        let photoMarkerDragState = null; // { img, startX, startY, initialX, initialY, posX, posY, scale, updateFn, saveFn }

        const fileInput = document.getElementById('fileInput');
        const selectPhotosButton = document.getElementById('selectPhotosButton');
        const routeInput = document.getElementById('routeInput');
        const routeButton = document.getElementById('routeButton');
        const photosGrid = document.getElementById('photosGrid');
        const showMapButton = document.getElementById('showMapButton');
        const showGalleryButton = document.getElementById('showGalleryButton');
        const mapSaveBtn = document.getElementById('mapSaveBtn');
        const clearButton = document.getElementById('clearButton');
        const mapModal = document.getElementById('mapModal');
        const galleryModal = document.getElementById('galleryModal');
        const closeMapButton = document.getElementById('closeMapButton');
        const closeGalleryButton = document.getElementById('closeGalleryButton');
        const gallerySaveBtn = document.getElementById('gallerySaveBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const stats = document.getElementById('stats');
        const errorContainer = document.getElementById('errorContainer');
        const mapStyleSelect = document.getElementById('mapStyleSelect');
        const container = document.querySelector('.container');
        
        // Lightbox elements
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightboxImg');
        const lightboxCaption = document.getElementById('lightboxCaption');
        const lightboxCounter = document.getElementById('lightboxCounter');
        const lightboxClose = document.getElementById('lightboxClose');
        const lightboxPrev = document.getElementById('lightboxPrev');
        const lightboxNext = document.getElementById('lightboxNext');

        // Path memory using localStorage
        const STORAGE_KEY = 'photoLocationMapper_paths';
        
        function loadSavedPaths() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.log('Could not load saved paths:', e);
            }
            return { photosFolder: null, routesFolder: null };
        }
        
        function savePaths(paths) {
            try {
                const existing = loadSavedPaths();
                const updated = { ...existing, ...paths };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
                displaySavedPaths();
            } catch (e) {
                console.log('Could not save paths:', e);
            }
        }
        
        function displaySavedPaths() {
            const paths = loadSavedPaths();
            const infoEl = document.getElementById('lastPathsInfo');
            if (!infoEl) return;
            
            const parts = [];
            if (paths.photosFolder) {
                parts.push(`üì∑ ${paths.photosFolder}`);
            }
            if (paths.routesFolder) {
                parts.push(`üó∫Ô∏è ${paths.routesFolder}`);
            }
            
            if (parts.length > 0) {
                infoEl.innerHTML = `<span style="color: #999;">Last used:</span> ${parts.join(' ‚Ä¢ ')}`;
            }
        }
        
        // Display saved paths on load
        displaySavedPaths();

        // Button clicks trigger file inputs
        selectPhotosButton.addEventListener('click', () => fileInput.click());

        // Route button opens file picker directly
        routeButton.addEventListener('click', () => routeInput.click());

        fileInput.addEventListener('change', handleFileSelect);
        routeInput.addEventListener('change', handleRouteSelect);
        showMapButton.addEventListener('click', showMap);
        showGalleryButton.addEventListener('click', showGallery);
        mapSaveBtn.addEventListener('click', saveMapAsImage);
        const photoMarkersBtn = document.getElementById('photoMarkersBtn');
        photoMarkersBtn.addEventListener('click', togglePhotoMarkers);
        
        const markerSizeSlider = document.getElementById('markerSizeSlider');
        const markerSizeValue = document.getElementById('markerSizeValue');
        const markerSizeControl = document.getElementById('markerSizeControl');
        
        markerSizeSlider.addEventListener('input', () => {
            const oldSize = PHOTO_MARKER_SIZE;
            const newSize = parseInt(markerSizeSlider.value);
            PHOTO_MARKER_SIZE = newSize;
            markerSizeValue.textContent = PHOTO_MARKER_SIZE + 'px';

            // Scale the saved transforms proportionally to the new size
            const sizeRatio = newSize / oldSize;
            Object.keys(photoMarkerTransforms).forEach(key => {
                const transform = photoMarkerTransforms[key];
                if (transform) {
                    transform.scale *= sizeRatio;
                    transform.baseScale *= sizeRatio;
                    transform.posX *= sizeRatio;
                    transform.posY *= sizeRatio;
                }
            });

            if (photoMarkersMode) {
                showPhotoMarkers(); // Refresh with new size
            }
        });
        
        const numberMarkerSizeSlider = document.getElementById('numberMarkerSizeSlider');
        const numberMarkerSizeValue = document.getElementById('numberMarkerSizeValue');
        const numberMarkerSizeControl = document.getElementById('numberMarkerSizeControl');
        
        numberMarkerSizeSlider.addEventListener('input', () => {
            BADGE_SCALE = parseFloat(numberMarkerSizeSlider.value);
            numberMarkerSizeValue.textContent = BADGE_SCALE + 'x';
            if (photoMarkersMode) {
                showPhotoMarkers(); // Refresh with new badge size
            }
        });
        clearButton.addEventListener('click', clearAll);
        closeMapButton.addEventListener('click', () => {
            closeAllPhotoPopups();
            clearPhotoMarkers();
            mapModal.classList.remove('active');
        });
        closeGalleryButton.addEventListener('click', () => galleryModal.classList.remove('active'));
        gallerySaveBtn.addEventListener('click', saveGalleryAsImage);

        // Make the gallery behave like a draggable + resizable window
        (function enableGalleryWindow() {
            const modal = galleryModal;
            const wrapper = modal.querySelector('.map-container-wrapper');
            const header = modal.querySelector('.map-header');

            let isDraggingWin = false;
            let startX = 0, startY = 0;
            let startLeft = 0, startTop = 0;

            header.addEventListener('mousedown', (e) => {
                // Only start drag when the modal is open
                if (!modal.classList.contains('active')) return;
                isDraggingWin = true;

                const rect = wrapper.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = rect.left;
                startTop = rect.top;

                // Bring to front
                wrapper.style.zIndex = '2000';

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingWin) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;

                // Clamp inside viewport with a small margin
                const margin = 10;
                const w = wrapper.getBoundingClientRect().width;
                const h = wrapper.getBoundingClientRect().height;

                const maxLeft = window.innerWidth - w - margin;
                const maxTop = window.innerHeight - h - margin;

                newLeft = Math.min(maxLeft, Math.max(margin, newLeft));
                newTop = Math.min(maxTop, Math.max(margin, newTop));

                wrapper.style.left = newLeft + 'px';
                wrapper.style.top = newTop + 'px';
            });

            document.addEventListener('mouseup', () => {
                isDraggingWin = false;
            });
        })();


        mapStyleSelect.addEventListener('change', changeMapStyle);
        document.getElementById('mapboxKeyBtn').addEventListener('click', showMapboxKeyDialog);
        document.getElementById('toggle3DBtn').addEventListener('click', toggle3DView);

        // Drag and drop support
        container.addEventListener('dragover', handleDragOver);
        container.addEventListener('drop', handleDrop);
        container.addEventListener('dragleave', handleDragLeave);
        container.addEventListener('dragenter', handleDragEnter);

        // Handle window resize to update map
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (map && mapModal.classList.contains('active')) {
                    map.invalidateSize();
                }
            }, 100);
        });

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.stopPropagation();
            container.style.borderColor = '#667eea';
            container.style.backgroundColor = '#f8f9ff';
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            if (e.target === container) {
                container.style.borderColor = '';
                container.style.backgroundColor = '';
            }
        }

        async function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            container.style.borderColor = '';
            container.style.backgroundColor = '';

            const files = Array.from(e.dataTransfer.files);
            if (files.length === 0) return;

            // Filter for image files
            const imageFiles = files.filter(f => 
                f.type.startsWith('image/') || 
                f.name.toLowerCase().endsWith('.heic') || 
                f.name.toLowerCase().endsWith('.heif')
            );

            if (imageFiles.length > 0) {
                loadingIndicator.style.display = 'block';
                errorContainer.innerHTML = '';
                
                for (const file of imageFiles) {
                    try {
                        await processPhoto(file);
                    } catch (error) {
                        console.error(`Error processing ${file.name}:`, error);
                        showError(`Failed to process ${file.name}: ${error.message}`);
                    }
                }

                // Sort photos by datetime (chronological order)
                photos.sort((a, b) => {
                    if (!a.gps || !a.gps.dateTimeObj) return 1;
                    if (!b.gps || !b.gps.dateTimeObj) return -1;
                    return a.gps.dateTimeObj - b.gps.dateTimeObj;
                });

                loadingIndicator.style.display = 'none';
                updateStats();
                renderPhotos();
                
                // Preserve route filter display if routes exist
                if (routes.length > 0) {
                    updateRouteFilter();
                }
            }
        }

        async function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            // Try to extract folder path from first file
            if (files[0].webkitRelativePath) {
                const pathParts = files[0].webkitRelativePath.split('/');
                if (pathParts.length > 1) {
                    savePaths({ photosFolder: pathParts.slice(0, -1).join('/') });
                }
            } else if (files[0].name) {
                // For regular file picker, we can only note that photos were loaded
                // The path isn't available, but we can store a timestamp reference
                savePaths({ photosFolder: `(${files.length} photos loaded ${new Date().toLocaleDateString()})` });
            }

            loadingIndicator.style.display = 'block';
            errorContainer.innerHTML = '';
            
            for (const file of files) {
                try {
                    await processPhoto(file);
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                    showError(`Failed to process ${file.name}: ${error.message}`);
                }
            }

            // Sort photos by datetime (chronological order)
            photos.sort((a, b) => {
                // Photos without GPS or datetime go to the end
                if (!a.gps || !a.gps.dateTimeObj) return 1;
                if (!b.gps || !b.gps.dateTimeObj) return -1;
                
                // Sort by datetime
                return a.gps.dateTimeObj - b.gps.dateTimeObj;
            });

            loadingIndicator.style.display = 'none';
            updateStats();
            renderPhotos();
            
            // Preserve route filter display if routes exist
            if (routes.length > 0) {
                updateRouteFilter();
            }
            
            // Reset file input
            fileInput.value = '';
        }

        async function handleRouteSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            const loadingText = loadingIndicator.querySelector('div:last-child');
            loadingIndicator.style.display = 'block';
            loadingText.textContent = `Loading ${file.name}...`;

            try {
                const routesBefore = routes.length;

                // Auto-detect format based on file extension
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.gpx')) {
                    await parseGPXFile(file);
                } else if (fileName.endsWith('.json') || fileName.endsWith('.gz')) {
                    await parseRouteFile(file);
                } else {
                    // Try to detect from content
                    const text = await file.text();
                    if (text.trim().startsWith('<?xml') || text.trim().startsWith('<gpx')) {
                        await parseGPXFile(file);
                    } else {
                        // Assume JSON format
                        await parseRouteFile(file);
                    }
                }

                const routesAdded = routes.length - routesBefore;

                loadingIndicator.style.display = 'none';

                if (routesAdded === 0) {
                    showError(`No routes found in ${file.name}`, 'warning');
                } else {
                    showError(`‚úì Loaded ${routesAdded} route${routesAdded !== 1 ? 's' : ''} from ${file.name}`, 'success');
                }

            } catch (error) {
                loadingIndicator.style.display = 'none';
                console.error('Error loading route file:', error);
                showError(`Error loading ${file.name}: ${error.message}`, 'error');
            }

            updateStats();
            updateRouteFilter();

            routeInput.value = '';
        }

        async function parseRouteFile(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                let jsonText;

                if (file.name.endsWith('.gz')) {
                    // Decompress gzip
                    const decompressed = pako.ungzip(new Uint8Array(arrayBuffer), { to: 'string' });
                    jsonText = decompressed;
                } else {
                    jsonText = new TextDecoder().decode(arrayBuffer);
                }

                const data = JSON.parse(jsonText);
                
                if (data.timelineItems) {
                    data.timelineItems.forEach(item => {
                        if (!item.isVisit && item.samples && item.samples.length > 0) {
                            // Extract route path from samples
                            const path = item.samples
                                .filter(s => s.location && s.location.latitude && s.location.longitude)
                                .map(s => ({
                                    lat: s.location.latitude,
                                    lng: s.location.longitude,
                                    timestamp: s.date
                                }));

                            if (path.length > 1) {
                                const startTime = new Date(item.startDate);
                                const endTime = new Date(item.endDate);
                                const activityType = (item.activityType || item.samples?.[0]?.classifiedType || 'unknown').toLowerCase();

                                // Skip stationary data
                                if (activityType === 'stationary') return;

                                routes.push({
                                    date: startTime.toISOString().split('T')[0],
                                    startTime: startTime,
                                    endTime: endTime,
                                    path: path,
                                    activityType: activityType,
                                    distance: calculateDistance(path)
                                });
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Error parsing route file:', error);
                throw error;
            }
        }

        function calculateDistance(path) {
            let total = 0;
            for (let i = 1; i < path.length; i++) {
                const R = 6371000; // Earth's radius in meters
                const lat1 = path[i-1].lat * Math.PI / 180;
                const lat2 = path[i].lat * Math.PI / 180;
                const dLat = (path[i].lat - path[i-1].lat) * Math.PI / 180;
                const dLon = (path[i].lng - path[i-1].lng) * Math.PI / 180;

                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                total += R * c;
            }
            return total;
        }

        async function parseGPXFile(file) {
            try {
                const text = await file.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');

                // Check for parse errors
                const parseError = xml.querySelector('parsererror');
                if (parseError) {
                    throw new Error('Invalid GPX XML format');
                }

                // Parse all tracks (<trk> elements)
                const tracks = xml.querySelectorAll('trk');

                tracks.forEach(track => {
                    const typeEl = track.querySelector('type');
                    const nameEl = track.querySelector('name');
                    const activityType = typeEl ? typeEl.textContent.toLowerCase() : 'unknown';
                    const trackName = nameEl ? nameEl.textContent : null;

                    // Skip stationary data
                    if (activityType === 'stationary') return;

                    // Get all track segments
                    const segments = track.querySelectorAll('trkseg');

                    segments.forEach(segment => {
                        const trackpoints = segment.querySelectorAll('trkpt');
                        if (trackpoints.length < 2) return;

                        const path = [];
                        let startTime = null;
                        let endTime = null;

                        trackpoints.forEach(trkpt => {
                            const lat = parseFloat(trkpt.getAttribute('lat'));
                            const lng = parseFloat(trkpt.getAttribute('lon'));
                            const timeEl = trkpt.querySelector('time');
                            const eleEl = trkpt.querySelector('ele');

                            if (!isNaN(lat) && !isNaN(lng)) {
                                const point = { lat, lng };

                                if (timeEl) {
                                    const timestamp = new Date(timeEl.textContent);
                                    point.timestamp = timestamp.toISOString();
                                    if (!startTime) startTime = timestamp;
                                    endTime = timestamp;
                                }

                                if (eleEl) {
                                    point.ele = parseFloat(eleEl.textContent);
                                }

                                path.push(point);
                            }
                        });

                        if (path.length > 1) {
                            // Use first point's timestamp if no explicit times
                            if (!startTime) {
                                startTime = new Date();
                                endTime = new Date();
                            }

                            routes.push({
                                date: startTime.toISOString().split('T')[0],
                                startTime: startTime,
                                endTime: endTime,
                                path: path,
                                activityType: activityType,
                                distance: calculateDistance(path),
                                name: trackName,
                                source: 'gpx'
                            });
                        }
                    });
                });

            } catch (error) {
                console.error('Error parsing GPX file:', error);
                throw error;
            }
        }

        function updateRouteFilter() {
            if (routes.length === 0) return;

            const routeFilterContainer = document.getElementById('routeFilterContainer');
            routeFilterContainer.style.display = 'flex';
            
            const checkboxContainer = document.getElementById('activityCheckboxes');
            checkboxContainer.innerHTML = '';
            
            // Get unique activity types
            const activityTypes = [...new Set(routes.map(r => r.activityType))];
            
            // Initialize selectedActivities if empty (first time)
            if (selectedActivities.size === 0) {
                activityTypes.forEach(activity => selectedActivities.add(activity));
            }
            
            // Create checkbox for each activity
            activityTypes.forEach(activity => {
                const label = document.createElement('label');
                label.style.display = 'inline-flex';
                label.style.alignItems = 'center';
                label.style.gap = '5px';
                label.style.padding = '5px 10px';
                label.style.background = '#f8f9fa';
                label.style.borderRadius = '6px';
                label.style.cursor = 'pointer';
                label.style.fontSize = '0.85em';
                label.style.border = '2px solid transparent';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = activity;
                checkbox.checked = selectedActivities.has(activity);
                
                if (!checkbox.checked) {
                    label.style.borderColor = '#ddd';
                }
                
                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedActivities.add(activity);
                        label.style.borderColor = 'transparent';
                    } else {
                        selectedActivities.delete(activity);
                        label.style.borderColor = '#ddd';
                    }
                    filterRoutes();
                });
                
                const activityName = activity.charAt(0).toUpperCase() + activity.slice(1);
                const color = getActivityColor(activity);
                
                const colorDot = document.createElement('span');
                colorDot.textContent = '‚óè';
                colorDot.style.color = color;
                colorDot.style.fontSize = '1.2em';
                
                const text = document.createElement('span');
                text.textContent = activityName;
                
                label.appendChild(checkbox);
                label.appendChild(colorDot);
                label.appendChild(text);
                checkboxContainer.appendChild(label);
            });
        }

        function filterRoutes() {
            if (!map) return;
            
            // Hide/show routes based on selected activities
            routes.forEach((route, index) => {
                if (routePolylines[index]) {
                    if (selectedActivities.has(route.activityType)) {
                        routePolylines[index].border.addTo(map);
                        routePolylines[index].line.addTo(map);
                    } else {
                        routePolylines[index].border.remove();
                        routePolylines[index].line.remove();
                    }
                }
            });
        }

        async function processPhoto(file) {
            // Check if photo already exists (by filename)
            const existingIndex = photos.findIndex(p => p.name === file.name);
            
            // Extract GPS data first using ExifReader (works with HEIC and JPEG)
            const gpsData = await extractGPSData(file);
            
            // Create preview image - convert HEIC to JPEG for compatibility
            const imageSrc = await createImagePreview(file);
            
            if (existingIndex >= 0) {
                // Update existing photo but preserve comment
                const existingComment = photos[existingIndex].comment;
                const existingViewTransform = photos[existingIndex].viewTransform;
                
                // Revoke old URL to free memory
                if (photos[existingIndex].src) {
                    URL.revokeObjectURL(photos[existingIndex].src);
                }
                
                photos[existingIndex] = {
                    name: file.name,
                    src: imageSrc,
                    gps: gpsData,
                    file: file,
                    comment: existingComment,
                    viewTransform: existingViewTransform
                };
            } else {
                photos.push({
                    name: file.name,
                    src: imageSrc,
                    gps: gpsData,
                    file: file
                });
            }
        }

        async function createImagePreview(file) {
            const isHEIC = file.type === 'image/heic' || file.type === 'image/heif' || 
                          file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');
            
            if (isHEIC) {
                try {
                    // Try to create an image bitmap from the HEIC file
                    const bitmap = await createImageBitmap(file);
                    
                    // Create a canvas and convert to JPEG
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas dimensions to match image
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    
                    // Draw the image
                    ctx.drawImage(bitmap, 0, 0);
                    
                    // Convert canvas to JPEG blob
                    return new Promise((resolve, reject) => {
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(URL.createObjectURL(blob));
                            } else {
                                reject(new Error('Failed to convert to JPEG'));
                            }
                        }, 'image/jpeg', 0.92);
                    });
                } catch (error) {
                    console.log('Browser cannot decode HEIC - skipping preview');
                    // Return null to indicate no preview available
                    return null;
                }
            } else {
                // For JPEG/JPG, use file directly
                return URL.createObjectURL(file);
            }
        }

        async function extractGPSData(file) {
            try {
                // Read file as ArrayBuffer for ExifReader
                const arrayBuffer = await file.arrayBuffer();
                
                // Parse EXIF data using ExifReader
                const tags = ExifReader.load(arrayBuffer, {expanded: true});

                // Check for GPS data in various possible locations
                let latitude, longitude, altitude, dateTime;

                // Try to get GPS coordinates
                if (tags.gps) {
                    latitude = tags.gps.Latitude;
                    longitude = tags.gps.Longitude;
                    altitude = tags.gps.Altitude;
                } 
                
                // Fallback to checking individual GPS tags
                if (!latitude && tags.GPSLatitude) {
                    latitude = convertGPSToDecimal(tags.GPSLatitude.description || tags.GPSLatitude.value);
                }
                if (!longitude && tags.GPSLongitude) {
                    longitude = convertGPSToDecimal(tags.GPSLongitude.description || tags.GPSLongitude.value);
                }
                if (!altitude && tags.GPSAltitude) {
                    altitude = tags.GPSAltitude.value || tags.GPSAltitude.description;
                }
                // Try to get date/time
                if (tags.exif && tags.exif.DateTimeOriginal) {
                    dateTime = tags.exif.DateTimeOriginal.description || tags.exif.DateTimeOriginal.value;
                } else if (tags.DateTime) {
                    dateTime = tags.DateTime.description || tags.DateTime.value;
                }

                // If no GPS data found, still return date/time if available
                if (!latitude || !longitude) {
                    console.log('No GPS data found in file');
                    
                    // Still extract date/time for non-GPS photos
                    if (dateTime) {
                        const dateTimeStr = dateTime.toString();
                        let dateTimeObj = null;
                        const dtStr = dateTimeStr.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
                        dateTimeObj = new Date(dtStr);
                        if (isNaN(dateTimeObj.getTime())) {
                            dateTimeObj = null;
                        }
                        return {
                            latitude: null,
                            longitude: null,
                            altitude: null,
                            dateTime: dateTimeStr,
                            dateTimeObj: dateTimeObj,
                            latDMS: null,
                            lonDMS: null,
                            hasGPS: false
                        };
                    }
                    return null;
                }

                // Format altitude
                const altitudeStr = altitude ? `${parseFloat(altitude).toFixed(1)} m` : 'N/A';
                const dateTimeStr = dateTime || 'N/A';
                
                // Parse datetime string to Date object for sorting
                let dateTimeObj = null;
                if (dateTime) {
                    // EXIF datetime format is typically "YYYY:MM:DD HH:MM:SS"
                    const dtStr = dateTime.toString().replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
                    dateTimeObj = new Date(dtStr);
                    
                    // If parsing failed, try alternative formats
                    if (isNaN(dateTimeObj.getTime())) {
                        dateTimeObj = null;
                    }
                }

                // Convert to DMS format for display
                const latDMS = convertDDToDMS(latitude, latitude >= 0 ? 'N' : 'S');
                const lonDMS = convertDDToDMS(longitude, longitude >= 0 ? 'E' : 'W');


                return {
                    latitude,
                    longitude,
                    altitude: altitudeStr,
                    dateTime: dateTimeStr,
                    dateTimeObj: dateTimeObj,
                    latDMS,
                    lonDMS,
                    hasGPS: true
                };
            } catch (error) {
                console.error('Error extracting GPS data:', error);
                return null;
            }
        }

        function convertGPSToDecimal(gpsString) {
            // GPS string might be in format like "27¬∞ 32' 43.81"" or already a number
            if (typeof gpsString === 'number') {
                return gpsString;
            }
            
            if (typeof gpsString === 'string') {
                // Try to parse DMS format
                const match = gpsString.match(/(\d+)¬∞\s*(\d+)'\s*([\d.]+)"/);
                if (match) {
                    const degrees = parseFloat(match[1]);
                    const minutes = parseFloat(match[2]);
                    const seconds = parseFloat(match[3]);
                    return degrees + minutes / 60 + seconds / 3600;
                }
                
                // If it's just a decimal number as string
                const parsed = parseFloat(gpsString);
                if (!isNaN(parsed)) {
                    return parsed;
                }
            }
            
            return null;
        }

        function convertDDToDMS(dd, direction) {
            const absolute = Math.abs(dd);
            const degrees = Math.floor(absolute);
            const minutesDecimal = (absolute - degrees) * 60;
            const minutes = Math.floor(minutesDecimal);
            const seconds = ((minutesDecimal - minutes) * 60).toFixed(2);
            
            return `${degrees}¬∞ ${minutes}' ${seconds}" ${direction}`;
        }

        function formatBrisbaneDate(date) {
            // Format date in Brisbane timezone as "Monday, 3rd January 2026"
            const dateOptions = {
                timeZone: 'Australia/Brisbane',
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            };
            
            // Get date parts
            const dateFormatter = new Intl.DateTimeFormat('en-AU', dateOptions);
            const parts = dateFormatter.formatToParts(date);
            
            let weekday = '', day = '', month = '', year = '';
            parts.forEach(part => {
                if (part.type === 'weekday') weekday = part.value;
                if (part.type === 'day') day = part.value;
                if (part.type === 'month') month = part.value;
                if (part.type === 'year') year = part.value;
            });
            
            // Add ordinal suffix
            const dayNum = parseInt(day, 10);
            let ordinal = 'th';
            if (dayNum === 1 || dayNum === 21 || dayNum === 31) ordinal = 'st';
            else if (dayNum === 2 || dayNum === 22) ordinal = 'nd';
            else if (dayNum === 3 || dayNum === 23) ordinal = 'rd';
            
            return `${weekday}, ${dayNum}${ordinal} ${month} ${year}`;
        }

        function formatBrisbaneShortDate(date) {
            // Short format for stats bar: "3 Jan 2026"
            return date.toLocaleDateString('en-AU', {
                timeZone: 'Australia/Brisbane',
                day: 'numeric',
                month: 'short',
                year: 'numeric'
            });
        }

        function formatBrisbaneDateTime(date) {
            // Returns separate date and time strings
            return {
                date: formatBrisbaneDate(date),
                time: date.toLocaleTimeString('en-AU', {
                    timeZone: 'Australia/Brisbane',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                })
            };
        }

        // Lightbox functions
        function openLightbox(index) {
            if (index < 0 || index >= photos.length) return;
            lightboxIndex = index;
            updateLightbox();
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        function closeLightbox() {
            lightbox.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        function updateLightbox() {
            const photo = photos[lightboxIndex];
            lightboxImg.src = photo.src;
            
            // Build caption with name, date/time, and GPS
            let caption = photo.name;
            if (photo.gps && photo.gps.dateTimeObj) {
                const dt = formatBrisbaneDateTime(photo.gps.dateTimeObj);
                caption += ` ‚Ä¢ ${dt.date} ${dt.time}`;
            }
            if (photo.gps && photo.gps.hasGPS) {
                caption += ` ‚Ä¢ ${photo.gps.latDMS}, ${photo.gps.lonDMS}`;
            }
            lightboxCaption.textContent = caption;
            
            lightboxCounter.textContent = `${lightboxIndex + 1} / ${photos.length}`;
            
            // Update nav button states
            lightboxPrev.disabled = lightboxIndex === 0;
            lightboxNext.disabled = lightboxIndex === photos.length - 1;
        }
        
        function lightboxPrevPhoto() {
            if (lightboxIndex > 0) {
                lightboxIndex--;
                updateLightbox();
            }
        }
        
        function lightboxNextPhoto() {
            if (lightboxIndex < photos.length - 1) {
                lightboxIndex++;
                updateLightbox();
            }
        }
        
        // Lightbox event listeners
        lightboxClose.addEventListener('click', closeLightbox);
        lightboxPrev.addEventListener('click', lightboxPrevPhoto);
        lightboxNext.addEventListener('click', lightboxNextPhoto);
        
        lightbox.addEventListener('click', (e) => {
            // Close if clicking the background (not the image or buttons)
            if (e.target === lightbox) {
                closeLightbox();
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (!lightbox.classList.contains('active')) return;
            
            switch(e.key) {
                case 'Escape':
                    closeLightbox();
                    break;
                case 'ArrowLeft':
                    lightboxPrevPhoto();
                    break;
                case 'ArrowRight':
                    lightboxNextPhoto();
                    break;
            }
        });

        function updateStats() {
            const photoCount = photos.length;
            const gpsCount = photos.filter(p => p.gps && p.gps.hasGPS).length;

            document.getElementById('photoCount').textContent = photoCount;
            document.getElementById('gpsCount').textContent = gpsCount;

            if (photoCount > 0) {
                stats.style.display = 'inline-block';
                
                // Calculate and display date range
                const photosWithDates = photos.filter(p => p.gps && p.gps.dateTimeObj);
                if (photosWithDates.length > 0) {
                    const dates = photosWithDates.map(p => p.gps.dateTimeObj);
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    
                    const dateRangeEl = document.getElementById('dateRange');
                    const dateRangeStats = document.getElementById('dateRangeStats');
                    
                    if (minDate.toDateString() === maxDate.toDateString()) {
                        // Single date - short format for stats bar
                        dateRangeEl.textContent = formatBrisbaneShortDate(minDate);
                    } else {
                        // Date range
                        dateRangeEl.textContent = `${formatBrisbaneShortDate(minDate)} ‚Äì ${formatBrisbaneShortDate(maxDate)}`;
                    }
                    dateRangeStats.style.display = 'inline';
                }
            }

            if (routes.length > 0) {
                document.getElementById('routeStats').style.display = 'inline';
                document.getElementById('routeCount').textContent = routes.length;
            }

            // Enable map if we have GPS photos OR routes
            showMapButton.disabled = (gpsCount === 0 && routes.length === 0);
            showGalleryButton.disabled = gpsCount === 0;
            clearButton.disabled = (photos.length === 0 && routes.length === 0);
        }
        
        function deletePhoto(index) {
            if (index < 0 || index >= photos.length) return;
            
            // Revoke object URL to free memory
            if (photos[index].src) {
                URL.revokeObjectURL(photos[index].src);
            }
            
            // Remove the photo
            photos.splice(index, 1);
            
            // Re-index saved transforms (shift down indices above deleted)
            const newTransforms = {};
            Object.keys(photoMarkerTransforms).forEach(key => {
                const oldIndex = parseInt(key);
                if (oldIndex < index) {
                    newTransforms[oldIndex] = photoMarkerTransforms[key];
                } else if (oldIndex > index) {
                    newTransforms[oldIndex - 1] = photoMarkerTransforms[key];
                }
                // Skip the deleted index
            });
            photoMarkerTransforms = newTransforms;
            
            // Re-render
            renderPhotos();
            updateStats();
            
            // Update map if open
            if (map && mapModal.classList.contains('active')) {
                if (photoMarkersMode) {
                    showPhotoMarkers();
                } else {
                    showNumberMarkers();
                }
            }
        }
        
        function copyGPS(index) {
            if (index < 0 || index >= photos.length) return;
            const photo = photos[index];
            if (!photo.gps || !photo.gps.hasGPS) return;
            
            copiedGPS = {
                latitude: photo.gps.latitude,
                longitude: photo.gps.longitude,
                altitude: photo.gps.altitude,
                dateTimeObj: photo.gps.dateTimeObj,
                dateTime: photo.gps.dateTime
            };
            
            // Update all paste buttons to be enabled
            document.querySelectorAll('.gps-btn-paste').forEach(btn => {
                btn.disabled = false;
            });
            
            // Show feedback
            const toast = document.createElement('div');
            toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#667eea;color:white;padding:10px 20px;border-radius:8px;z-index:10000;';
            toast.textContent = `GPS + Date/Time copied from ${photo.name}`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
            
        }
        
        function pasteGPS(index) {
            if (index < 0 || index >= photos.length || !copiedGPS) return;
            
            const photo = photos[index];
            if (!photo.gps) {
                photo.gps = {};
            }
            
            photo.gps.latitude = copiedGPS.latitude;
            photo.gps.longitude = copiedGPS.longitude;
            photo.gps.altitude = copiedGPS.altitude;
            photo.gps.latDMS = convertDDToDMS(copiedGPS.latitude, copiedGPS.latitude >= 0 ? 'N' : 'S');
            photo.gps.lonDMS = convertDDToDMS(copiedGPS.longitude, copiedGPS.longitude >= 0 ? 'E' : 'W');
            photo.gps.hasGPS = true;
            
            // Also paste date/time if available
            if (copiedGPS.dateTimeObj) {
                photo.gps.dateTimeObj = copiedGPS.dateTimeObj;
                photo.gps.dateTime = copiedGPS.dateTime;
            }
            
            // Mark this photo as having unsaved edits
            photosWithUnsavedEdits.add(photo.name);
            
            // Highlight this specific photo after re-sort
            highlightedPhotoName = photo.name;
            
            // Re-sort photos chronologically after date/time change
            photos.sort((a, b) => {
                if (!a.gps || !a.gps.dateTimeObj) return 1;
                if (!b.gps || !b.gps.dateTimeObj) return -1;
                return a.gps.dateTimeObj - b.gps.dateTimeObj;
            });
            
            renderPhotos();
            updateStats();
            
            // Clear highlight after animation
            setTimeout(() => {
                highlightedPhotoName = null;
            }, 1500);
            
            // Update map if open
            if (map && mapModal.classList.contains('active')) {
                if (photoMarkersMode) {
                    showPhotoMarkers();
                } else {
                    showNumberMarkers();
                }
            }
            
            // Show feedback
            const toast = document.createElement('div');
            toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#28a745;color:white;padding:10px 20px;border-radius:8px;z-index:10000;';
            toast.textContent = `GPS + Date/Time pasted to ${photo.name}`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
            
        }
        
        function parseDMSToDecimal(dmsStr) {
            // Parse DMS format like "27¬∞ 28' 0.00" S" or "153¬∞ 1' 30.00" E"
            // Also handle incomplete formats like "27¬∞ 32' 43.24" (missing direction and/or closing quote)
            if (!dmsStr || typeof dmsStr !== 'string') return null;
            
            dmsStr = dmsStr.trim();
            
            // Normalize quote characters (handle ", ", ‚Ä≥, etc.)
            dmsStr = dmsStr.replace(/[""‚Ä≥]/g, '"').replace(/[''‚Ä≤]/g, "'");
            
            // Try full format with direction: 27¬∞ 28' 0.00" S
            let match = dmsStr.match(/(\d+)¬∞\s*(\d+)[''‚Ä≤]?\s*([\d.]+)[""‚Ä≥]?\s*([NSEW])/i);
            if (match) {
                const degrees = parseFloat(match[1]);
                const minutes = parseFloat(match[2]);
                const seconds = parseFloat(match[3]);
                const direction = match[4].toUpperCase();
                
                let decimal = degrees + minutes / 60 + seconds / 3600;
                if (direction === 'S' || direction === 'W') {
                    decimal = -decimal;
                }
                return decimal;
            }
            
            // Try format without direction: 27¬∞ 32' 43.24 or 27¬∞ 32' 43.24"
            match = dmsStr.match(/(\d+)¬∞\s*(\d+)[''‚Ä≤]?\s*([\d.]+)[""‚Ä≥]?/);
            if (match) {
                const degrees = parseFloat(match[1]);
                const minutes = parseFloat(match[2]);
                const seconds = parseFloat(match[3]);
                
                let decimal = degrees + minutes / 60 + seconds / 3600;
                return decimal; // Return positive, caller will handle sign
            }
            
            // Try parsing as plain decimal number
            const num = parseFloat(dmsStr);
            if (!isNaN(num)) {
                return num;
            }
            
            console.log('Failed to parse DMS:', dmsStr);
            return null;
        }
        
        function degToDmsRational(deg) {
            const d = Math.floor(deg);
            const minFloat = (deg - d) * 60;
            const m = Math.floor(minFloat);
            const secFloat = (minFloat - m) * 60;
            const s = Math.round(secFloat * 100);
            
            return [[d, 1], [m, 1], [s, 100]];
        }
        
        function saveGPSFromInputs(index) {
            if (index < 0 || index >= photos.length) {
                return;
            }
            
            const photo = photos[index];
            const latInput = document.querySelector(`.gps-input[data-field="lat"][data-index="${index}"]`);
            const lngInput = document.querySelector(`.gps-input[data-field="lng"][data-index="${index}"]`);
            const altInput = document.querySelector(`.gps-input[data-field="alt"][data-index="${index}"]`);
            const dateInput = document.querySelector(`.gps-input[data-field="date"][data-index="${index}"]`);
            const timeInput = document.querySelector(`.gps-input[data-field="time"][data-index="${index}"]`);
            
            if (!latInput || !lngInput) {
                return;
            }
            
            // Parse DMS format to decimal
            let lat = parseDMSToDecimal(latInput.value);
            let lng = parseDMSToDecimal(lngInput.value);
            const alt = altInput.value.trim();
            
            // If direction not specified in DMS, infer from existing photo data or Brisbane defaults
            if (lat !== null && !(/[NS]/i.test(latInput.value))) {
                // If photo already has GPS, match its sign; otherwise assume South for Brisbane
                if (photo.gps && photo.gps.latitude < 0) {
                    lat = -Math.abs(lat);
                } else if (!photo.gps || !photo.gps.latitude) {
                    // Default to South (Brisbane area)
                    lat = -Math.abs(lat);
                }
            }
            
            if (lng !== null && !(/[EW]/i.test(lngInput.value))) {
                // If photo already has GPS, match its sign; otherwise assume East for Brisbane
                if (photo.gps && photo.gps.longitude > 0) {
                    lng = Math.abs(lng);
                } else if (!photo.gps || !photo.gps.longitude) {
                    // Default to East (Brisbane area)
                    lng = Math.abs(lng);
                }
            }
            
            if (lat === null || lng === null) {
                alert('Please enter valid coordinates in DMS format\nExample: 27¬∞ 28\' 0.00" S');
                return;
            }
            
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                alert('Latitude must be -90 to 90, Longitude must be -180 to 180');
                return;
            }
            
            // Parse date and time
            let dateTimeObj = null;
            const dateStr = dateInput ? dateInput.value.trim() : '';
            const timeStr = timeInput ? timeInput.value.trim() : '';
            
            if (dateStr && timeStr) {
                // Parse DD/MM/YYYY format
                const dateParts = dateStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                const timeParts = timeStr.match(/(\d{1,2}):(\d{2}):?(\d{2})?/);
                
                if (dateParts && timeParts) {
                    const day = parseInt(dateParts[1]);
                    const month = parseInt(dateParts[2]) - 1;
                    const year = parseInt(dateParts[3]);
                    const hours = parseInt(timeParts[1]);
                    const minutes = parseInt(timeParts[2]);
                    const seconds = parseInt(timeParts[3] || '0');
                    
                    dateTimeObj = new Date(year, month, day, hours, minutes, seconds);
                }
            }
            
            // Update in-memory data
            if (!photo.gps) {
                photo.gps = {
                    dateTime: 'N/A',
                    dateTimeObj: null
                };
            }
            
            photo.gps.latitude = lat;
            photo.gps.longitude = lng;
            photo.gps.altitude = alt || 'N/A';
            photo.gps.latDMS = convertDDToDMS(lat, lat >= 0 ? 'N' : 'S');
            photo.gps.lonDMS = convertDDToDMS(lng, lng >= 0 ? 'E' : 'W');
            photo.gps.hasGPS = true;
            
            if (dateTimeObj && !isNaN(dateTimeObj.getTime())) {
                photo.gps.dateTimeObj = dateTimeObj;
                photo.gps.dateTime = dateTimeObj.toLocaleString('en-AU', { 
                    timeZone: 'Australia/Brisbane',
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
            }
            
            // Save to file with EXIF
            const img = new Image();
            // Don't set crossOrigin for blob URLs (same-origin already)
            if (!photo.src.startsWith('blob:')) {
                img.crossOrigin = 'anonymous';
            }
            
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                // Get as JPEG data URL
                const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
                
                try {
                    // Check if piexif is available
                    if (typeof piexif === 'undefined') {
                        throw new Error('piexifjs library not loaded');
                    }
                    
                    // Create new EXIF object
                    let exifObj = {"0th":{}, "Exif":{}, "GPS":{}, "1st":{}, "thumbnail": null};
                    
                    // Set GPS data
                    exifObj.GPS[piexif.GPSIFD.GPSLatitudeRef] = lat >= 0 ? 'N' : 'S';
                    exifObj.GPS[piexif.GPSIFD.GPSLatitude] = degToDmsRational(Math.abs(lat));
                    exifObj.GPS[piexif.GPSIFD.GPSLongitudeRef] = lng >= 0 ? 'E' : 'W';
                    exifObj.GPS[piexif.GPSIFD.GPSLongitude] = degToDmsRational(Math.abs(lng));
                    
                    // Set altitude if available
                    if (alt && alt !== 'N/A') {
                        const altNum = parseFloat(alt);
                        if (!isNaN(altNum)) {
                            exifObj.GPS[piexif.GPSIFD.GPSAltitudeRef] = altNum >= 0 ? 0 : 1;
                            exifObj.GPS[piexif.GPSIFD.GPSAltitude] = [Math.abs(Math.round(altNum * 100)), 100];
                        }
                    }
                    
                    // Set date/time from edited values
                    const dtToSave = dateTimeObj || photo.gps.dateTimeObj;
                    if (dtToSave) {
                        const exifDateStr = dtToSave.getFullYear() + ':' +
                            String(dtToSave.getMonth() + 1).padStart(2, '0') + ':' +
                            String(dtToSave.getDate()).padStart(2, '0') + ' ' +
                            String(dtToSave.getHours()).padStart(2, '0') + ':' +
                            String(dtToSave.getMinutes()).padStart(2, '0') + ':' +
                            String(dtToSave.getSeconds()).padStart(2, '0');
                        exifObj.Exif[piexif.ExifIFD.DateTimeOriginal] = exifDateStr;
                        exifObj.Exif[piexif.ExifIFD.DateTimeDigitized] = exifDateStr;
                        exifObj["0th"][piexif.ImageIFD.DateTime] = exifDateStr;
                    }
                    
                    // Insert EXIF into image
                    const exifBytes = piexif.dump(exifObj);
                    const newDataUrl = piexif.insert(exifBytes, dataUrl);
                    
                    // Download the file
                    const link = document.createElement('a');
                    link.href = newDataUrl;
                    const baseName = photo.name.replace(/\.[^.]+$/, '');
                    link.download = baseName + '_gps.jpg';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Clear unsaved edits for this photo (it's been saved)
                    photosWithUnsavedEdits.delete(photo.name);
                    
                    // Highlight this specific photo after re-sort
                    highlightedPhotoName = photo.name;
                    
                    // Re-sort photos chronologically after date/time edit
                    photos.sort((a, b) => {
                        if (!a.gps || !a.gps.dateTimeObj) return 1;
                        if (!b.gps || !b.gps.dateTimeObj) return -1;
                        return a.gps.dateTimeObj - b.gps.dateTimeObj;
                    });
                    
                    // Update display
                    renderPhotos();
                    updateStats();
                    
                    // Clear highlight after animation
                    setTimeout(() => {
                        highlightedPhotoName = null;
                    }, 1500);
                    
                    // Update map if open
                    if (map && mapModal.classList.contains('active')) {
                        if (photoMarkersMode) {
                            showPhotoMarkers();
                        } else {
                            showNumberMarkers();
                        }
                    }
                    
                    // Show feedback
                    const toast = document.createElement('div');
                    toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#28a745;color:white;padding:10px 20px;border-radius:8px;z-index:10000;';
                    toast.textContent = `Saved ${baseName}_gps.jpg with metadata`;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 3000);
                    
                } catch (exifError) {
                    console.error('EXIF error:', exifError);
                    alert('Error saving EXIF data: ' + exifError.message);
                }
            };
            
            img.onerror = function(e) {
                console.error('Error loading image for processing:', e);
                alert('Error loading image for processing');
            };
            
            img.src = photo.src;
        }
        
        function renderPhotos() {
            photosGrid.innerHTML = '';

            photos.forEach((photo, index) => {
                const card = document.createElement('div');
                card.className = 'photo-card';
                
                // Add highlight class if this photo was just edited
                if (highlightedPhotoName === photo.name) {
                    card.classList.add('highlight-moved');
                }

                // Only add image if preview is available
                if (photo.src) {
                    const container = document.createElement('div');
                    container.className = 'photo-preview-container';
                    
                    const img = document.createElement('img');
                    img.className = 'photo-preview-draggable';
                    img.src = photo.src;
                    img.alt = photo.name;
                    
                    // State for this image
                    let containerWidth = 0;  // set after element is in DOM
                    let containerHeight = 0; // set after element is in DOM
                    
                    function readContainerSize() {
                        const r = container.getBoundingClientRect();
                        containerWidth = Math.max(1, Math.round(r.width));
                        containerHeight = Math.max(1, Math.round(r.height));
                    }

                    let imgWidth = 0;
                    let imgHeight = 0;
                    let baseScale = 1;
                    let minScale = 0.1;

                    let scale = 1;
                    let posX = 0;
                    let posY = 0;
                    let isDragging = false;
                    let startX, startY, initialX, initialY;
                    
                    // Wait for image to load to get dimensions
                    img.onload = function() {
                        imgWidth = img.naturalWidth;
                        imgHeight = img.naturalHeight;
                        
                        readContainerSize();
                        // Determine if image is portrait or landscape
                        const isPortrait = imgHeight > imgWidth;

                        if (isPortrait) {
                            // Portrait: fit to width (fills the tile width; crop vertically)
                            baseScale = containerWidth / imgWidth;
                        } else {
                            // Landscape: cover (fills the tile; crop horizontally if needed)
                            const scaleX = containerWidth / imgWidth;
                            const scaleY = containerHeight / imgHeight;
                            baseScale = Math.max(scaleX, scaleY);
                        }

                        scale = baseScale;
                        minScale = baseScale; // never allow zooming out to reveal background

                        // Centre the image within the 4:3 tile
                        const scaledW = imgWidth * scale;
                        const scaledH = imgHeight * scale;
                        posX = (containerWidth - scaledW) / 2;
                        posY = (containerHeight - scaledH) / 2;

                        // Apply initial transform
                        updateTransform();};
                    
                    function updateTransform() {
                        // Clamp pan so the image always covers the tile (no background showing)
                        const scaledW = imgWidth * scale;
                        const scaledH = imgHeight * scale;

                        if (scaledW > containerWidth) {
                            const minX = containerWidth - scaledW;
                            posX = Math.min(0, Math.max(minX, posX));
                        } else {
                            posX = (containerWidth - scaledW) / 2;
                        }

                        if (scaledH > containerHeight) {
                            const minY = containerHeight - scaledH;
                            posY = Math.min(0, Math.max(minY, posY));
                        } else {
                            posY = (containerHeight - scaledH) / 2;
                        }

                        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                        img.style.transformOrigin = 'top left';
                        // Persist the current view so the Gallery can mirror the same zoom + offsets
                        photo.viewTransform = { scale, posX, posY };
                    }
                    
                    // Keep tiles correct if the container size changes (responsive layout)
                    const ro = new ResizeObserver(() => {
                        if (!imgWidth || !imgHeight) return;
                        readContainerSize();
                        const isPortrait = imgHeight > imgWidth;

                        if (isPortrait) {
                            baseScale = containerWidth / imgWidth;
                        } else {
                            const scaleX = containerWidth / imgWidth;
                            const scaleY = containerHeight / imgHeight;
                            baseScale = Math.max(scaleX, scaleY);
                        }

                        // Never allow a scale that reveals background
                        minScale = baseScale;
                        if (scale < minScale) scale = minScale;

                        updateTransform();
                    });
                    ro.observe(container);

                    // Mouse drag
                    img.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        initialX = posX;
                        initialY = posY;
                        e.preventDefault();
                    });
                    
                    // Double-click to open lightbox
                    container.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        openLightbox(index);
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        updateTransform();
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    // Mouse wheel zoom
                    container.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.05 : 0.05;
                        scale = Math.max(0.1, Math.min(5, scale + delta));
                        updateTransform();
                    }, { passive: false });
                    
                    // Touch support (passive: false because we use preventDefault)
                    img.addEventListener('touchstart', (e) => {
                        isDragging = true;
                        const touch = e.touches[0];
                        startX = touch.clientX;
                        startY = touch.clientY;
                        initialX = posX;
                        initialY = posY;
                        e.preventDefault();
                    }, { passive: false });
                    
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging || e.touches.length === 0) return;
                        const touch = e.touches[0];
                        const dx = touch.clientX - startX;
                        const dy = touch.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        updateTransform();
                    }, { passive: true });
                    
                    document.addEventListener('touchend', () => {
                        isDragging = false;
                    }, { passive: true });
                    
                    // Reset button
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'reset-pan';
                    resetBtn.textContent = '‚Ü∫ Reset';
                    resetBtn.onclick = () => {
                        posX = 0;
                        posY = 0;
                        // Recalculate initial scale
                        if (img.naturalWidth && img.naturalHeight) {
                            let containerWidth = 0;  // set after element is in DOM
                    let containerHeight = 0; // set after element is in DOM
                    
                    function readContainerSize() {
                        const r = container.getBoundingClientRect();
                        containerWidth = Math.max(1, Math.round(r.width));
                        containerHeight = Math.max(1, Math.round(r.height));
                    }

                            const imgWidth = img.naturalWidth;
                            const imgHeight = img.naturalHeight;
                        readContainerSize();
                            const isPortrait = imgHeight > imgWidth;
                            
                            if (isPortrait) {
                                scale = containerWidth / imgWidth;
                            } else {
                                const scaleX = containerWidth / imgWidth;
                                const scaleY = containerHeight / imgHeight;
                                scale = Math.max(scaleX, scaleY);
                            }
                        } else {
                            scale = 1;
                        }
                        updateTransform();
                    };
                    
                    // Zoom controls
                    const zoomControls = document.createElement('div');
                    zoomControls.className = 'zoom-controls';
                    
                    const zoomIn = document.createElement('button');
                    zoomIn.className = 'zoom-btn';
                    zoomIn.textContent = '+';
                    zoomIn.onclick = () => {
                        scale = Math.min(5, scale + 0.1);
                        updateTransform();
                    };
                    
                    const zoomOut = document.createElement('button');
                    zoomOut.className = 'zoom-btn';
                    zoomOut.textContent = '‚àí';
                    zoomOut.onclick = () => {
                        scale = Math.max(minScale, scale - 0.1);
                        updateTransform();
                    };
                    
                    zoomControls.appendChild(zoomOut);
                    zoomControls.appendChild(zoomIn);
                    
                    container.appendChild(img);
                    container.appendChild(resetBtn);
                    container.appendChild(zoomControls);
                    card.appendChild(container);
                }

                const info = document.createElement('div');
                info.className = 'photo-info';

                const name = document.createElement('div');
                name.className = 'photo-name';
                name.textContent = `${index + 1}. ${photo.name}`;

                const locationData = document.createElement('div');
                locationData.className = 'location-data';

                // Create editable GPS inputs with DMS format
                const hasGPS = photo.gps && photo.gps.hasGPS;
                const latDMS = hasGPS ? photo.gps.latDMS : '';
                const lngDMS = hasGPS ? photo.gps.lonDMS : '';
                const alt = hasGPS ? photo.gps.altitude : '';
                
                // Escape double quotes for HTML attributes
                const escapeHtml = (str) => str ? str.replace(/"/g, '&quot;') : '';
                
                // Date/time display (from GPS or file metadata)
                const dateTime = photo.gps && photo.gps.dateTimeObj ? formatBrisbaneDateTime(photo.gps.dateTimeObj) : null;
                
                locationData.innerHTML = `
                    <div class="gps-input-row">
                        <label>Latitude:</label>
                        <input type="text" class="gps-input" data-field="lat" data-index="${index}" value="${escapeHtml(latDMS)}" placeholder="27¬∞ 28' 0.00&quot; S">
                    </div>
                    <div class="gps-input-row">
                        <label>Longitude:</label>
                        <input type="text" class="gps-input" data-field="lng" data-index="${index}" value="${escapeHtml(lngDMS)}" placeholder="153¬∞ 1' 30.00&quot; E">
                    </div>
                    <div class="gps-input-row">
                        <label>Altitude:</label>
                        <input type="text" class="gps-input" data-field="alt" data-index="${index}" value="${escapeHtml(alt) || ''}" placeholder="0 m">
                    </div>
                    <div class="gps-input-row">
                        <label>Date:</label>
                        <input type="text" class="gps-input" data-field="date" data-index="${index}" value="${dateTime ? dateTime.date : ''}" placeholder="08/01/2026">
                    </div>
                    <div class="gps-input-row">
                        <label>Time:</label>
                        <input type="text" class="gps-input" data-field="time" data-index="${index}" value="${dateTime ? dateTime.time : ''}" placeholder="10:30:00">
                    </div>
                    ${photo.comment ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;"><strong>üí¨</strong> ${photo.comment}</div>` : ''}
                `;
                
                // Create buttons programmatically for reliable event handling
                const buttonRow = document.createElement('div');
                buttonRow.className = 'gps-buttons';
                
                if (hasGPS) {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'gps-btn';
                    copyBtn.textContent = 'Copy';
                    copyBtn.addEventListener('click', () => copyGPS(index));
                    buttonRow.appendChild(copyBtn);
                }
                
                const pasteBtn = document.createElement('button');
                pasteBtn.className = 'gps-btn';
                pasteBtn.textContent = 'Paste';
                pasteBtn.disabled = !copiedGPS;
                pasteBtn.classList.add('gps-btn-paste');
                pasteBtn.addEventListener('click', () => pasteGPS(index));
                buttonRow.appendChild(pasteBtn);
                
                const saveBtn = document.createElement('button');
                saveBtn.className = 'gps-btn gps-btn-save';
                saveBtn.textContent = 'Save to File';
                // Enable if this photo has unsaved edits
                saveBtn.disabled = !photosWithUnsavedEdits.has(photo.name);
                saveBtn.addEventListener('click', () => {
                    saveGPSFromInputs(index);
                });
                buttonRow.appendChild(saveBtn);
                
                // Insert buttons after the time input row
                const lastInputRow = locationData.querySelector('.gps-input-row:last-of-type');
                if (lastInputRow) {
                    lastInputRow.after(buttonRow);
                } else {
                    locationData.appendChild(buttonRow);
                }
                
                // Add input listeners to enable Save button when any field is edited
                const allInputs = locationData.querySelectorAll('.gps-input');
                allInputs.forEach(input => {
                    input.addEventListener('input', () => {
                        saveBtn.disabled = false;
                        photosWithUnsavedEdits.add(photo.name);
                    });
                });
                
                // Add change listeners for date/time fields to update and re-sort
                const dateInput = locationData.querySelector('.gps-input[data-field="date"]');
                const timeInput = locationData.querySelector('.gps-input[data-field="time"]');
                
                const updateDateTime = () => {
                    const dateStr = dateInput ? dateInput.value.trim() : '';
                    const timeStr = timeInput ? timeInput.value.trim() : '';
                    
                    if (dateStr && timeStr) {
                        const dateParts = dateStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                        const timeParts = timeStr.match(/(\d{1,2}):(\d{2}):?(\d{2})?/);
                        
                        if (dateParts && timeParts) {
                            const day = parseInt(dateParts[1]);
                            const month = parseInt(dateParts[2]) - 1;
                            const year = parseInt(dateParts[3]);
                            const hours = parseInt(timeParts[1]);
                            const minutes = parseInt(timeParts[2]);
                            const seconds = parseInt(timeParts[3] || '0');
                            
                            const newDateTime = new Date(year, month, day, hours, minutes, seconds);
                            
                            if (!isNaN(newDateTime.getTime())) {
                                if (!photo.gps) photo.gps = {};
                                photo.gps.dateTimeObj = newDateTime;
                                photo.gps.dateTime = newDateTime.toLocaleString('en-AU', { 
                                    timeZone: 'Australia/Brisbane',
                                    year: 'numeric', month: '2-digit', day: '2-digit',
                                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                                });
                                
                                // Mark as having unsaved edits and highlight this photo
                                photosWithUnsavedEdits.add(photo.name);
                                highlightedPhotoName = photo.name;
                                
                                // Re-sort chronologically
                                photos.sort((a, b) => {
                                    if (!a.gps || !a.gps.dateTimeObj) return 1;
                                    if (!b.gps || !b.gps.dateTimeObj) return -1;
                                    return a.gps.dateTimeObj - b.gps.dateTimeObj;
                                });
                                
                                renderPhotos();
                                updateStats();
                                
                                // Clear highlight after animation
                                setTimeout(() => {
                                    highlightedPhotoName = null;
                                }, 1500);
                                
                            }
                        }
                    }
                };
                
                if (dateInput) dateInput.addEventListener('change', updateDateTime);
                if (timeInput) timeInput.addEventListener('change', updateDateTime);

                info.appendChild(name);
                info.appendChild(locationData);
                card.appendChild(info);
                
                // Delete button - added last to render on top
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'photo-delete-btn';
                deleteBtn.textContent = '√ó';
                deleteBtn.title = 'Delete photo';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deletePhoto(index);
                });
                card.appendChild(deleteBtn);
                
                photosGrid.appendChild(card);
            });
        }

        // Mapbox API key (stored in localStorage)
        let mapboxApiKey = localStorage.getItem('mapboxApiKey') || '';

        const mapStyles = {
            osm: {
                name: 'Street Map',
                url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                attribution: '¬© OpenStreetMap contributors'
            },
            satellite: {
                name: 'Satellite',
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                attribution: 'Tiles ¬© Esri'
            },
            cycle: {
                name: 'Cycle Map',
                url: 'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png',
                attribution: '¬© OpenStreetMap contributors, CyclOSM'
            },
            humanitarian: {
                name: 'Humanitarian',
                url: 'https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
                attribution: '¬© OpenStreetMap contributors, Humanitarian OSM'
            },
            'mapbox-streets': {
                name: 'Mapbox Streets',
                url: 'https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            },
            'mapbox-outdoors': {
                name: 'Mapbox Outdoors',
                url: 'https://api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            },
            'mapbox-satellite': {
                name: 'Mapbox Satellite',
                url: 'https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            },
            'mapbox-satellite-streets': {
                name: 'Mapbox Satellite Streets',
                url: 'https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v12/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            }
        };

        // Arc Timeline color scheme
        const arcColors = {
            arcDarkPurple: '#2D2D73',
            arcPurple: '#7A3CFC',
            arcGreen: '#12A656',
            arcDarkGreen: '#0E8444',
            arcRed: '#E35641',
            arcOrange: '#EB781B',
            arcRuby: '#D85582',
            arcByzantine: '#8B408C',
            arcMagenta: '#8E1DD2',
            arcJade: '#079260',
            arcJungle: '#18A1B1',
            arcYellow: '#EEA10A',
            arcGold: '#AA9131',
            arcBrown: '#B4831D',
            arcDarkBlue: '#26398B',
            arcBlue: '#3B71F6',
            arcLightBlue: '#039FD4',
            arcNavy: '#4056B5',
            arcSapphire: '#4884AE',
            arcAnchor: '#4E5268',
            arcSpaniard: '#2D2F3E'
        };

        function getActivityColor(activityType) {
            const type = activityType.toLowerCase();
            
            switch (type) {
                case 'bogus':
                    return arcColors.arcBrown;
                case 'stationary':
                    return arcColors.arcPurple;
                case 'walking':
                case 'golf':
                case 'wheelchair':
                    return arcColors.arcGreen;
                case 'hiking':
                    return arcColors.arcDarkGreen;
                case 'running':
                    return arcColors.arcOrange;
                case 'cycling':
                case 'rowing':
                case 'swimming':
                case 'kayaking':
                    return arcColors.arcLightBlue;
                case 'car':
                case 'taxi':
                    return arcColors.arcAnchor;
                case 'bus':
                    return arcColors.arcNavy;
                case 'motorcycle':
                case 'scooter':
                    return arcColors.arcRed;
                case 'airplane':
                case 'hotairballoon':
                    return arcColors.arcMagenta;
                case 'boat':
                    return arcColors.arcBlue;
                case 'train':
                case 'metro':
                case 'tram':
                case 'cablecar':
                case 'funicular':
                case 'chairlift':
                case 'skilift':
                    return arcColors.arcGold;
                case 'tractor':
                    return arcColors.arcSpaniard;
                case 'tuktuk':
                case 'songthaew':
                    return arcColors.arcBrown;
                case 'skateboarding':
                    return arcColors.arcJungle;
                case 'inlineskating':
                    return arcColors.arcRuby;
                case 'snowboarding':
                    return arcColors.arcSapphire;
                case 'skiing':
                    return arcColors.arcDarkBlue;
                case 'horseback':
                    return arcColors.arcByzantine;
                case 'surfing':
                    return arcColors.arcRuby;
                case 'unknown':
                default:
                    return '#808080'; // gray
            }
        }

        function changeMapStyle() {
            if (!map || !currentTileLayer) return;

            const style = mapStyleSelect.value;
            const styleConfig = mapStyles[style];

            // Check if Mapbox style requires API key
            if (styleConfig.requiresApiKey) {
                if (!mapboxApiKey) {
                    alert('Please configure your Mapbox API key first by clicking the üîë button.');
                    // Revert to previous selection
                    mapStyleSelect.value = 'humanitarian';
                    return;
                }
            }

            // Remove current tile layer
            map.removeLayer(currentTileLayer);

            // Build tile layer options
            const tileOptions = {
                attribution: styleConfig.attribution,
                maxZoom: 19
            };

            // Add Mapbox-specific options
            if (styleConfig.tileSize) tileOptions.tileSize = styleConfig.tileSize;
            if (styleConfig.zoomOffset) tileOptions.zoomOffset = styleConfig.zoomOffset;

            // Build URL with API key if needed
            let tileUrl = styleConfig.url;
            if (styleConfig.requiresApiKey) {
                tileUrl = tileUrl.replace('{accessToken}', mapboxApiKey);
            }

            // Add new tile layer
            currentTileLayer = L.tileLayer(tileUrl, tileOptions).addTo(map);
        }

        function showMapboxKeyDialog() {
            const currentKey = mapboxApiKey ? mapboxApiKey.substring(0, 10) + '...' : '(not set)';
            const newKey = prompt(`Enter your Mapbox API key:\n\nCurrent: ${currentKey}\n\nGet a free key at mapbox.com`, mapboxApiKey || '');

            if (newKey !== null) {
                mapboxApiKey = newKey.trim();
                if (mapboxApiKey) {
                    localStorage.setItem('mapboxApiKey', mapboxApiKey);
                    alert('Mapbox API key saved. You can now use Mapbox map styles and 3D view.');
                    // Show 3D button when API key is set
                    document.getElementById('toggle3DBtn').style.display = '';
                } else {
                    localStorage.removeItem('mapboxApiKey');
                    document.getElementById('toggle3DBtn').style.display = 'none';
                }
            }
        }

        function toggle3DView() {
            if (!mapboxApiKey) {
                alert('Please configure your Mapbox API key first by clicking the üîë button.');
                return;
            }

            is3DMode = !is3DMode;
            const btn = document.getElementById('toggle3DBtn');
            const map2dContainer = document.getElementById('map');
            const map3dContainer = document.getElementById('map3d');

            if (is3DMode) {
                btn.textContent = 'üó∫Ô∏è 2D View';
                btn.title = 'Switch back to 2D map view';
                map2dContainer.style.display = 'none';
                map3dContainer.style.display = 'block';

                // Hide photo markers controls in 3D mode
                if (photoMarkersMode) {
                    document.getElementById('markerSizeControl').style.display = 'none';
                    document.getElementById('numberMarkerSizeControl').style.display = 'none';
                }

                init3DMap();
            } else {
                btn.textContent = 'üèîÔ∏è 3D View';
                btn.title = 'Toggle 3D terrain view (requires Mapbox API key)';
                map2dContainer.style.display = 'block';
                map3dContainer.style.display = 'none';

                // Restore photo markers controls if in photo markers mode
                if (photoMarkersMode) {
                    document.getElementById('markerSizeControl').style.display = 'flex';
                    document.getElementById('numberMarkerSizeControl').style.display = 'flex';
                }

                // Sync view from 3D to 2D
                if (map3d && map) {
                    const center = map3d.getCenter();
                    const zoom = map3d.getZoom();
                    map.setView([center.lat, center.lng], zoom, { animate: false });
                }

                map.invalidateSize();
            }
        }

        function init3DMap() {
            if (!mapboxApiKey) return;

            mapboxgl.accessToken = mapboxApiKey;

            // Get current view from 2D map
            let center = [-122.4, 37.8]; // Default
            let zoom = 10;
            let pitch = 60;
            let bearing = 0;

            if (map) {
                const mapCenter = map.getCenter();
                center = [mapCenter.lng, mapCenter.lat];
                zoom = map.getZoom();
            }

            // If 3D map doesn't exist, create it
            if (!map3d) {
                map3d = new mapboxgl.Map({
                    container: 'map3d',
                    style: 'mapbox://styles/mapbox/satellite-streets-v12',
                    center: center,
                    zoom: zoom,
                    pitch: pitch,
                    bearing: bearing,
                    antialias: true
                });

                map3d.on('load', () => {
                    // Add terrain
                    map3d.addSource('mapbox-dem', {
                        type: 'raster-dem',
                        url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
                        tileSize: 512,
                        maxzoom: 14
                    });

                    map3d.setTerrain({ source: 'mapbox-dem', exaggeration: 1.5 });

                    // Add sky
                    map3d.addLayer({
                        id: 'sky',
                        type: 'sky',
                        paint: {
                            'sky-type': 'atmosphere',
                            'sky-atmosphere-sun': [0.0, 90.0],
                            'sky-atmosphere-sun-intensity': 15
                        }
                    });

                    // Add routes and markers
                    add3DRoutes();
                    add3DMarkers();
                });

                // Add navigation controls
                map3d.addControl(new mapboxgl.NavigationControl());
            } else {
                // Update existing map view
                map3d.setCenter(center);
                map3d.setZoom(zoom);
                map3d.resize();

                // Update routes and markers
                if (map3d.isStyleLoaded()) {
                    add3DRoutes();
                    add3DMarkers();
                }
            }
        }

        function add3DRoutes() {
            if (!map3d || !map3d.isStyleLoaded()) return;

            // Remove existing route layers
            if (map3d.getLayer('routes-line')) map3d.removeLayer('routes-line');
            if (map3d.getLayer('routes-border')) map3d.removeLayer('routes-border');
            if (map3d.getSource('routes')) map3d.removeSource('routes');

            if (routes.length === 0) return;

            // Build GeoJSON from routes
            const features = routes.map((route, index) => {
                // Check if this activity type is selected
                if (selectedActivities.size > 0 && !selectedActivities.has(route.activityType)) {
                    return null;
                }
                return {
                    type: 'Feature',
                    properties: {
                        color: getActivityColor(route.activityType),
                        activityType: route.activityType
                    },
                    geometry: {
                        type: 'LineString',
                        coordinates: route.path.map(p => [p.lng, p.lat])
                    }
                };
            }).filter(f => f !== null);

            if (features.length === 0) return;

            map3d.addSource('routes', {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: features
                }
            });

            // White border
            map3d.addLayer({
                id: 'routes-border',
                type: 'line',
                source: 'routes',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': '#ffffff',
                    'line-width': 8,
                    'line-opacity': 0.9
                }
            });

            // Colored line
            map3d.addLayer({
                id: 'routes-line',
                type: 'line',
                source: 'routes',
                layout: {
                    'line-join': 'round',
                    'line-cap': 'round'
                },
                paint: {
                    'line-color': ['get', 'color'],
                    'line-width': 5,
                    'line-opacity': 0.9
                }
            });
        }

        // Store 3D markers for cleanup
        let markers3d = [];

        function add3DMarkers() {
            if (!map3d) return;

            // Remove existing markers
            markers3d.forEach(m => m.remove());
            markers3d = [];

            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);

            photosWithGPS.forEach((photo, index) => {
                // Create marker element
                const el = document.createElement('div');
                el.className = 'marker-3d';
                el.style.cssText = `
                    width: 40px;
                    height: 40px;
                    background: #667eea;
                    border: 3px solid white;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                    font-size: 14px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
                    cursor: pointer;
                `;
                el.textContent = index + 1;

                // Add click handler
                el.addEventListener('click', () => {
                    // Show popup with photo info
                    const popup = new mapboxgl.Popup({ offset: 25 })
                        .setHTML(`
                            <div style="text-align: center; max-width: 200px;">
                                <img src="${photo.src}" style="width: 100%; border-radius: 4px; margin-bottom: 8px;">
                                <div style="font-weight: bold;">${photo.name}</div>
                                <div style="font-size: 0.9em; color: #666;">
                                    ${photo.gps.latitude.toFixed(6)}, ${photo.gps.longitude.toFixed(6)}
                                </div>
                            </div>
                        `);

                    new mapboxgl.Marker(el)
                        .setLngLat([photo.gps.longitude, photo.gps.latitude])
                        .setPopup(popup)
                        .addTo(map3d);
                });

                const marker = new mapboxgl.Marker(el)
                    .setLngLat([photo.gps.longitude, photo.gps.latitude])
                    .addTo(map3d);

                markers3d.push(marker);
            });
        }

        function showMap() {
            mapModal.classList.add('active');

            // Show/hide 3D button based on API key availability
            document.getElementById('toggle3DBtn').style.display = mapboxApiKey ? '' : 'none';

            // Close any existing popups
            closeAllPhotoPopups();

            // Remember if photo markers mode was active to restore it later
            const wasPhotoMarkersMode = photoMarkersMode;

            // Temporarily reset photo markers mode while rebuilding
            photoMarkersMode = false;
            document.getElementById('photoMarkersBtn').textContent = 'üì∑ Photo Markers';
            document.getElementById('markerSizeControl').style.display = 'none';

            if (!map) {
                map = L.map('map', {
                    scrollWheelZoom: true,
                    wheelPxPerZoomLevel: 240,  // Default is 60, 4x makes zoom 4x finer
                    wheelDebounceTime: 40,      // Smoother scrolling
                    zoomSnap: 0.25              // Allow quarter-zoom levels for smoother transitions
                });

                // Create custom pane for rubberband lines (above routes in shadowPane, below markers)
                map.createPane('rubberbandPane');
                map.getPane('rubberbandPane').style.zIndex = 550; // Above shadowPane (500), below markerPane (600)

                // Create Canvas renderers for polylines (fixes html2canvas SVG rendering issues)
                map.routeRenderer = L.canvas({ pane: 'shadowPane' });
                map.rubberbandRenderer = L.canvas({ pane: 'rubberbandPane' });

                const defaultStyle = mapStyles['humanitarian'];
                currentTileLayer = L.tileLayer(defaultStyle.url, {
                    attribution: defaultStyle.attribution,
                    maxZoom: 19
                }).addTo(map);

                // Update spider positions on zoom
                map.on('zoomend', () => {
                    if (photoMarkersMode) {
                        updateSpiderPositions();
                    }
                });

                // Track user interactions with the map
                map.on('zoomend moveend', () => {
                    userHasInteractedWithMap = true;
                    savedMapState = {
                        center: map.getCenter(),
                        zoom: map.getZoom()
                    };
                });
            }

            // Force map to recalculate size after modal is displayed
            setTimeout(() => {
                map.invalidateSize();
            }, 100);

            // Clear existing markers and routes
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            routePolylines.forEach(poly => {
                poly.border.remove();
                poly.line.remove();
            });
            routePolylines = [];

            // Draw routes first (so they appear under markers)
            routes.forEach((route, index) => {
                const color = getActivityColor(route.activityType);
                
                // Draw white border first (wider line)
                const borderLine = L.polyline(route.path, {
                    color: '#ffffff',
                    weight: 12,
                    opacity: 0.9,
                    pane: 'shadowPane',
                    renderer: map.routeRenderer  // Use Canvas renderer for html2canvas compatibility
                }).addTo(map);

                // Draw colored route on top
                const polyline = L.polyline(route.path, {
                    color: color,
                    weight: 8,
                    opacity: 0.8,
                    pane: 'shadowPane',
                    renderer: map.routeRenderer  // Use Canvas renderer for html2canvas compatibility
                }).addTo(map);
                
                // Add popup to route
                const distKm = (route.distance / 1000).toFixed(2);
                const activityName = route.activityType.charAt(0).toUpperCase() + route.activityType.slice(1);
                polyline.bindPopup(`
                    <div style="text-align: center;">
                        <div style="font-weight: 600; color: ${color}; margin-bottom: 4px;">${activityName}</div>
                        <div style="font-size: 0.9em;">Start: ${route.startTime.toLocaleTimeString()}</div>
                        <div style="font-size: 0.9em;">End: ${route.endTime.toLocaleTimeString()}</div>
                        <div style="font-size: 0.9em; font-weight: 500; margin-top: 4px;">Distance: ${distKm} km</div>
                    </div>
                `);
                
                routePolylines.push({ border: borderLine, line: polyline });
            });

            // Apply saved route filters
            filterRoutes();

            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            
            photosWithGPS.forEach((photo, index) => {
                // Create numbered marker
                const numberIcon = L.divIcon({
                    className: 'numbered-marker',
                    html: `<div style="background: #667eea; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${index + 1}</div>`,
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
                
                const marker = L.marker([photo.gps.latitude, photo.gps.longitude], {
                    icon: numberIcon,
                    zIndexOffset: 1000  // Ensure markers are above routes
                }).addTo(map);
                
                // Use custom floating popup instead of Leaflet popup
                marker.on('click', () => {
                    openPhotoPopup(photo, index, marker);
                });
                
                markers.push(marker);
            });

            // Restore saved map view if user has interacted, otherwise fit to bounds
            if (userHasInteractedWithMap && savedMapState) {
                // Restore user's saved view
                map.setView(savedMapState.center, savedMapState.zoom, { animate: false });
            } else {
                // Fit map to show all GPS data (photos and routes)
                const bounds = L.latLngBounds();

                // Add photo marker positions to bounds
                markers.forEach(marker => {
                    bounds.extend(marker.getLatLng());
                });

                // Add route positions to bounds
                routes.forEach(route => {
                    route.path.forEach(point => {
                        bounds.extend([point.lat, point.lng]);
                    });
                });

                if (bounds.isValid()) {
                    map.fitBounds(bounds.pad(0.1));
                }
            }

            // Restore photo markers mode if it was active before
            if (wasPhotoMarkersMode) {
                setTimeout(() => {
                    togglePhotoMarkers();
                }, 150);
            }
        }

        // Floating popup management
        let activePopups = [];
        let popupZIndex = 2000;

        function openPhotoPopup(photo, index, marker) {
            // Create the popup panel
            const panel = document.createElement('div');
            panel.className = 'photo-popup-panel';
            panel.dataset.photoIndex = index;
            panel.style.zIndex = ++popupZIndex;
            
            // Position near the marker
            const mapContainer = document.getElementById('mapContainer');
            const mapRect = mapContainer.getBoundingClientRect();
            const point = map.latLngToContainerPoint([photo.gps.latitude, photo.gps.longitude]);
            
            // Initial position - offset from marker
            let left = point.x + 40;
            let top = point.y - 100;
            
            // Keep within map bounds
            left = Math.max(10, Math.min(left, mapRect.width - 300));
            top = Math.max(10, Math.min(top, mapRect.height - 250));
            
            panel.style.left = left + 'px';
            panel.style.top = top + 'px';
            panel.style.width = '320px';
            panel.style.height = '420px';
            
            // Header
            const header = document.createElement('div');
            header.className = 'photo-popup-header';
            
            const title = document.createElement('h3');
            title.textContent = photo.name;
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'photo-popup-close';
            closeBtn.innerHTML = '√ó';
            closeBtn.onclick = () => closePhotoPopup(panel);
            
            header.appendChild(title);
            header.appendChild(closeBtn);
            
            // Content
            const content = document.createElement('div');
            content.className = 'photo-popup-content';
            
            // Image container with pan/zoom
            const imgContainer = document.createElement('div');
            imgContainer.className = 'photo-popup-image-container';
            
            // Number badge
            const numberBadge = document.createElement('div');
            numberBadge.className = 'photo-popup-number';
            numberBadge.textContent = index + 1;
            imgContainer.appendChild(numberBadge);
            
            if (photo.src) {
                const img = document.createElement('img');
                img.className = 'photo-popup-image';
                img.src = photo.src;
                img.alt = photo.name;
                
                // Pan/zoom state
                let scale = 1;
                let posX = 0;
                let posY = 0;
                let isDragging = false;
                let startX, startY, initialX, initialY;
                let baseScale = 1;
                let minScale = 0.1;
                let imgWidth = 0;
                let imgHeight = 0;
                
                function readContainerSize() {
                    const r = imgContainer.getBoundingClientRect();
                    return {
                        width: Math.max(1, r.width),
                        height: Math.max(1, r.height)
                    };
                }
                
                function updateTransform() {
                    img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                    img.style.transformOrigin = 'top left';
                }
                
                function fitImage() {
                    if (!imgWidth || !imgHeight) return;
                    const container = readContainerSize();
                    const isPortrait = imgHeight > imgWidth;
                    
                    if (isPortrait) {
                        baseScale = container.width / imgWidth;
                    } else {
                        const scaleX = container.width / imgWidth;
                        const scaleY = container.height / imgHeight;
                        baseScale = Math.max(scaleX, scaleY);
                    }
                    
                    minScale = baseScale;
                    scale = baseScale;
                    posX = 0;
                    posY = 0;
                    updateTransform();
                }
                
                img.onload = function() {
                    imgWidth = img.naturalWidth;
                    imgHeight = img.naturalHeight;
                    fitImage();
                };
                
                // Observe container resize
                const ro = new ResizeObserver(() => {
                    if (imgWidth && imgHeight) {
                        const container = readContainerSize();
                        const isPortrait = imgHeight > imgWidth;
                        
                        if (isPortrait) {
                            baseScale = container.width / imgWidth;
                        } else {
                            const scaleX = container.width / imgWidth;
                            const scaleY = container.height / imgHeight;
                            baseScale = Math.max(scaleX, scaleY);
                        }
                        
                        minScale = baseScale;
                        if (scale < minScale) scale = minScale;
                        updateTransform();
                    }
                });
                ro.observe(imgContainer);
                
                // Mouse drag
                img.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = posX;
                    initialY = posY;
                    e.preventDefault();
                });
                
                imgContainer.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    posX = initialX + dx;
                    posY = initialY + dy;
                    updateTransform();
                });
                
                imgContainer.addEventListener('mouseup', () => isDragging = false);
                imgContainer.addEventListener('mouseleave', () => isDragging = false);
                
                // Mouse wheel zoom - finer control
                imgContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.03 : 0.03;
                    scale = Math.max(minScale, Math.min(5, scale + delta));
                    updateTransform();
                }, { passive: false });
                
                imgContainer.appendChild(img);
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'photo-popup-placeholder';
                placeholder.textContent = 'üì∏';
                placeholder.appendChild(numberBadge.cloneNode(true));
                imgContainer.appendChild(placeholder);
            }
            
            content.appendChild(imgContainer);
            
            // Format date in Brisbane time
            const dateTime = photo.gps.dateTimeObj ? formatBrisbaneDateTime(photo.gps.dateTimeObj) : null;
            
            // Details
            const details = document.createElement('div');
            details.className = 'photo-popup-details';
            details.innerHTML = `
                <div><strong>Coordinates:</strong> ${photo.gps.latitude.toFixed(6)}, ${photo.gps.longitude.toFixed(6)}</div>
                <div><strong>Altitude:</strong> ${photo.gps.altitude}</div>
                ${dateTime ? `<div><strong>Date:</strong> ${dateTime.date}</div>` : ''}
                ${dateTime ? `<div><strong>Time:</strong> ${dateTime.time}</div>` : ''}
            `;
            content.appendChild(details);
            
            // Comment section
            const commentSection = document.createElement('div');
            commentSection.className = 'photo-popup-comment-section';
            
            const commentLabel = document.createElement('label');
            commentLabel.textContent = 'üí¨ Comment';
            commentLabel.htmlFor = `comment-${index}`;
            
            const commentArea = document.createElement('textarea');
            commentArea.className = 'photo-popup-comment';
            commentArea.id = `comment-${index}`;
            commentArea.placeholder = 'Add a comment about this photo...';
            commentArea.value = photo.comment || '';
            
            const savedIndicator = document.createElement('div');
            savedIndicator.className = 'photo-popup-comment-saved';
            savedIndicator.textContent = '‚úì Saved';
            
            // Auto-save comment on input
            let saveTimeout;
            commentArea.addEventListener('input', () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    photo.comment = commentArea.value;
                    savedIndicator.classList.add('visible');
                    setTimeout(() => savedIndicator.classList.remove('visible'), 1500);
                    // Update the card display too
                    renderPhotos();
                }, 500);
            });
            
            commentSection.appendChild(commentLabel);
            commentSection.appendChild(commentArea);
            commentSection.appendChild(savedIndicator);
            content.appendChild(commentSection);
            
            // Resize handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'photo-popup-resize-handle';
            
            panel.appendChild(header);
            panel.appendChild(content);
            panel.appendChild(resizeHandle);
            
            // Add to map container
            mapContainer.appendChild(panel);
            activePopups.push(panel);
            
            // Make draggable
            setupPanelDrag(panel, header);
            
            // Make resizable
            setupPanelResize(panel, resizeHandle);
            
            // Bring to front on click
            panel.addEventListener('mousedown', () => {
                panel.style.zIndex = ++popupZIndex;
            });
        }

        function closePhotoPopup(panel) {
            panel.remove();
            activePopups = activePopups.filter(p => p !== panel);
        }

        function closeAllPhotoPopups() {
            activePopups.forEach(p => p.remove());
            activePopups = [];
        }

        function setupPanelDrag(panel, header) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('photo-popup-close')) return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = panel.offsetLeft;
                startTop = panel.offsetTop;
                
                panel.style.zIndex = ++popupZIndex;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                const mapContainer = document.getElementById('mapContainer');
                const mapRect = mapContainer.getBoundingClientRect();
                const panelRect = panel.getBoundingClientRect();
                
                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                
                // Keep within map container
                newLeft = Math.max(0, Math.min(newLeft, mapRect.width - panelRect.width));
                newTop = Math.max(0, Math.min(newTop, mapRect.height - panelRect.height));
                
                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        function setupPanelResize(panel, handle) {
            let isResizing = false;
            let startX, startY, startWidth, startHeight;
            
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = panel.offsetWidth;
                startHeight = panel.offsetHeight;
                
                panel.style.zIndex = ++popupZIndex;
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                const newWidth = Math.max(280, startWidth + dx);
                const newHeight = Math.max(200, startHeight + dy);
                
                panel.style.width = newWidth + 'px';
                panel.style.height = newHeight + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isResizing = false;
            });
        }

        // Photo Markers Mode
        function togglePhotoMarkers() {
            photoMarkersMode = !photoMarkersMode;
            const btn = document.getElementById('photoMarkersBtn');
            const photoSizeControl = document.getElementById('markerSizeControl');
            const numberSizeControl = document.getElementById('numberMarkerSizeControl');
            
            if (photoMarkersMode) {
                btn.textContent = 'üî¢ Number Markers';
                photoSizeControl.style.display = 'flex';
                numberSizeControl.style.display = 'flex';
                closeAllPhotoPopups(); // Close popups in photo marker mode
                showPhotoMarkers();
            } else {
                btn.textContent = 'üì∑ Photo Markers';
                photoSizeControl.style.display = 'none';
                numberSizeControl.style.display = 'none';
                hidePhotoMarkers();
                showNumberMarkers();
            }
        }

        function showPhotoMarkers() {
            // Hide numbered markers
            markers.forEach(m => map.removeLayer(m));
            
            // Clear existing photo markers
            clearPhotoMarkers();
            
            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            
            // Group photos by proximity
            const clusters = clusterPhotosByProximity(photosWithGPS);
            
            // Create markers for each cluster
            clusters.forEach(cluster => {
                if (cluster.photos.length === 1) {
                    // Single photo - just create marker at location
                    createPhotoMarker(cluster.photos[0], cluster.center);
                } else {
                    // Multiple photos - create spider
                    createSpiderCluster(cluster);
                }
            });
        }

        function hidePhotoMarkers() {
            clearPhotoMarkers();
        }

        function clearPhotoMarkers() {
            photoMarkers.forEach(pm => {
                if (pm.marker) map.removeLayer(pm.marker);
            });
            photoMarkers = [];

            numberBadgeMarkers.forEach(m => {
                if (m) map.removeLayer(m);
            });
            numberBadgeMarkers = [];

            spiderLegs.forEach(leg => {
                if (leg) map.removeLayer(leg);
            });
            spiderLegs = [];

            // Clear rubberband lines and GPS dots
            rubberbandLines.forEach(line => {
                if (line) map.removeLayer(line);
            });
            rubberbandLines = [];
        }
        
        function resetPhotoMarkerTransforms() {
            photoMarkerTransforms = {};
            photoMarkerOffsets = {};
        }

        function showNumberMarkers() {
            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            
            const size = NUMBER_MARKER_SIZE;
            const fontSize = Math.round(size * 0.44);
            const borderWidth = Math.max(2, Math.round(size * 0.09));
            
            photosWithGPS.forEach((photo, index) => {
                const numberIcon = L.divIcon({
                    className: 'numbered-marker',
                    html: `<div style="background: #667eea; color: white; border-radius: 50%; width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: ${fontSize}px; border: ${borderWidth}px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${index + 1}</div>`,
                    iconSize: [size, size],
                    iconAnchor: [size / 2, size / 2],
                    popupAnchor: [0, -size / 2]
                });
                
                const marker = L.marker([photo.gps.latitude, photo.gps.longitude], {
                    icon: numberIcon,
                    zIndexOffset: 1000
                }).addTo(map);
                
                marker.on('click', () => {
                    openPhotoPopup(photo, index, marker);
                });
                
                markers.push(marker);
            });
        }

        function clusterPhotosByProximity(photosWithGPS) {
            const clusters = [];
            const assigned = new Set();
            const proximityThreshold = 0.0001; // ~11 meters
            
            photosWithGPS.forEach((photo, idx) => {
                if (assigned.has(idx)) return;
                
                const cluster = {
                    photos: [{ photo, index: photos.indexOf(photo) }],
                    center: { lat: photo.gps.latitude, lng: photo.gps.longitude }
                };
                assigned.add(idx);
                
                // Find nearby photos
                photosWithGPS.forEach((other, otherIdx) => {
                    if (assigned.has(otherIdx)) return;
                    
                    const dist = Math.sqrt(
                        Math.pow(photo.gps.latitude - other.gps.latitude, 2) +
                        Math.pow(photo.gps.longitude - other.gps.longitude, 2)
                    );
                    
                    if (dist < proximityThreshold) {
                        cluster.photos.push({ photo: other, index: photos.indexOf(other) });
                        assigned.add(otherIdx);
                    }
                });
                
                // Calculate center
                if (cluster.photos.length > 1) {
                    let sumLat = 0, sumLng = 0;
                    cluster.photos.forEach(p => {
                        sumLat += p.photo.gps.latitude;
                        sumLng += p.photo.gps.longitude;
                    });
                    cluster.center = {
                        lat: sumLat / cluster.photos.length,
                        lng: sumLng / cluster.photos.length
                    };
                }
                
                clusters.push(cluster);
            });
            
            return clusters;
        }

        function createPhotoMarker(photoData, position) {
            const { photo, index } = photoData;
            const size = PHOTO_MARKER_SIZE;

            // Store the original GPS position (position might already be offset for spider clusters)
            const gpsPosition = { lat: photo.gps.latitude, lng: photo.gps.longitude };

            // Apply any saved offset to the display position
            const savedOffset = photoMarkerOffsets[index];
            let displayPosition = { ...position };
            if (savedOffset) {
                displayPosition.lat = position.lat + savedOffset.lat;
                displayPosition.lng = position.lng + savedOffset.lng;
            }

            const container = document.createElement('div');
            container.className = 'photo-marker';
            container.style.width = size + 'px';
            container.style.height = size + 'px';
            container.style.boxShadow = '0 3px 10px rgba(0,0,0,0.6), 0 0 0 1px rgba(0,0,0,0.3), 0 8px 25px rgba(0,0,0,0.4)';

            const imgContainer = document.createElement('div');
            imgContainer.className = 'photo-marker-container';

            if (photo.src) {
                const img = document.createElement('img');
                img.className = 'photo-marker-img';
                img.src = photo.src;

                // Pan/zoom state
                let scale = 1;
                let posX = 0;
                let posY = 0;
                let isDragging = false;
                let startX, startY, initialX, initialY;
                let baseScale = 1;
                let imgWidth = 0, imgHeight = 0;

                function updateTransform() {
                    img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                }

                img.onload = function() {
                    imgWidth = img.naturalWidth;
                    imgHeight = img.naturalHeight;

                    // Cover the circular area
                    const scaleX = size / imgWidth;
                    const scaleY = size / imgHeight;
                    baseScale = Math.max(scaleX, scaleY);
                    scale = baseScale;

                    // Center
                    posX = (size - imgWidth * scale) / 2;
                    posY = (size - imgHeight * scale) / 2;

                    updateTransform();
                };

                // Drag handling
                img.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = posX;
                    initialY = posY;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    posX = initialX + (e.clientX - startX);
                    posY = initialY + (e.clientY - startY);
                    updateTransform();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                // Wheel zoom
                imgContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const delta = e.deltaY > 0 ? -0.008 : 0.008;
                    scale = Math.max(baseScale * 0.5, Math.min(5, scale + delta));
                    updateTransform();
                }, { passive: false });

                imgContainer.appendChild(img);
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'photo-marker-placeholder';
                placeholder.textContent = 'üì∏';
                imgContainer.appendChild(placeholder);
            }

            // Number badge - now created as separate marker for proper z-ordering

            container.appendChild(imgContainer);

            // Add padding for shadow (shadow is up to 25px blur + 8px offset)
            const shadowPadding = 40;
            const totalSize = size + shadowPadding * 2;

            // Wrap container in a div with padding for shadow
            const wrapper = document.createElement('div');
            wrapper.style.cssText = `width: ${totalSize}px; height: ${totalSize}px; display: flex; align-items: center; justify-content: center;`;
            wrapper.appendChild(container);

            const icon = L.divIcon({
                className: 'photo-marker-icon',
                html: wrapper.outerHTML,
                iconSize: [totalSize, totalSize],
                iconAnchor: [totalSize / 2, totalSize / 2]
            });

            const marker = L.marker([displayPosition.lat, displayPosition.lng], {
                icon: icon,
                zIndexOffset: 1000,
                draggable: false  // Controlled by Option/Alt key
            }).addTo(map);

            // Create rubberband line and GPS dot if marker has been offset
            let rubberbandLine = null;
            let rubberbandBorder = null;
            let gpsDot = null;
            const RUBBERBAND_THRESHOLD = 20; // pixels - show rubberband if marker moved more than this

            function updateRubberband() {
                const markerLatLng = marker.getLatLng();
                const markerPoint = map.latLngToContainerPoint(markerLatLng);
                const gpsPoint = map.latLngToContainerPoint([gpsPosition.lat, gpsPosition.lng]);
                const distance = Math.sqrt(Math.pow(markerPoint.x - gpsPoint.x, 2) + Math.pow(markerPoint.y - gpsPoint.y, 2));

                if (distance > RUBBERBAND_THRESHOLD) {
                    if (!rubberbandLine) {
                        // Create white border line first (underneath)
                        rubberbandBorder = L.polyline([
                            [gpsPosition.lat, gpsPosition.lng],
                            [markerLatLng.lat, markerLatLng.lng]
                        ], {
                            color: 'white',
                            weight: 6,
                            opacity: 0.9,
                            pane: 'rubberbandPane',
                            renderer: map.rubberbandRenderer  // Use Canvas renderer for html2canvas compatibility
                        }).addTo(map);
                        rubberbandLines.push(rubberbandBorder);

                        // Create colored line on top
                        rubberbandLine = L.polyline([
                            [gpsPosition.lat, gpsPosition.lng],
                            [markerLatLng.lat, markerLatLng.lng]
                        ], {
                            color: '#667eea',
                            weight: 3,
                            opacity: 1,
                            dashArray: '8, 8',
                            pane: 'rubberbandPane',
                            renderer: map.rubberbandRenderer  // Use Canvas renderer for html2canvas compatibility
                        }).addTo(map);
                        rubberbandLines.push(rubberbandLine);
                    } else {
                        const coords = [
                            [gpsPosition.lat, gpsPosition.lng],
                            [markerLatLng.lat, markerLatLng.lng]
                        ];
                        if (rubberbandBorder) rubberbandBorder.setLatLngs(coords);
                        rubberbandLine.setLatLngs(coords);
                    }

                    if (!gpsDot) {
                        gpsDot = L.circleMarker([gpsPosition.lat, gpsPosition.lng], {
                            radius: 8,
                            fillColor: '#667eea',
                            fillOpacity: 1,
                            color: 'white',
                            weight: 2,
                            pane: 'rubberbandPane',
                            renderer: map.rubberbandRenderer  // Use Canvas renderer for html2canvas compatibility
                        }).addTo(map);
                        rubberbandLines.push(gpsDot);
                    }
                } else {
                    if (rubberbandBorder) {
                        map.removeLayer(rubberbandBorder);
                        const idx = rubberbandLines.indexOf(rubberbandBorder);
                        if (idx > -1) rubberbandLines.splice(idx, 1);
                        rubberbandBorder = null;
                    }
                    if (rubberbandLine) {
                        map.removeLayer(rubberbandLine);
                        const idx = rubberbandLines.indexOf(rubberbandLine);
                        if (idx > -1) rubberbandLines.splice(idx, 1);
                        rubberbandLine = null;
                    }
                    if (gpsDot) {
                        map.removeLayer(gpsDot);
                        const idx = rubberbandLines.indexOf(gpsDot);
                        if (idx > -1) rubberbandLines.splice(idx, 1);
                        gpsDot = null;
                    }
                }
            }

            // Initial rubberband check
            updateRubberband();

            // Create separate number badge marker on top layer - draggable in orbit
            const badgeSize = Math.round(BASE_BADGE_SIZE * BADGE_SCALE);

            // Get stored angle or default to bottom-left (-135 degrees = -3œÄ/4 radians)
            const defaultAngle = -Math.PI * 3 / 4; // Bottom-left
            const angle = badgeOrbitalAngles[index] !== undefined ? badgeOrbitalAngles[index] : defaultAngle;

            // Orbit radius - at larger badge scales, allow overlap with photo
            // At 1x: badge orbits outside photo. At 5x: badge can overlap significantly
            const baseOrbitRadius = size / 2 + BASE_BADGE_SIZE / 2 + 4;
            const orbitRadius = Math.max(size / 4, baseOrbitRadius - (BADGE_SCALE - 1) * BASE_BADGE_SIZE / 2);

            // Icon needs to be large enough to contain badge at any orbit position
            const badgeIconSize = size + 2 * orbitRadius + badgeSize * 2;
            const badgeIconCenter = badgeIconSize / 2;

            // Badge starts hidden, setupOrbitalDrag will position it correctly
            // Dynamic sizing via inline styles
            const badgeFontSize = Math.round(14 * BADGE_SCALE);
            const badgePadding = Math.round(6 * BADGE_SCALE);
            const badgeBorderRadius = badgeSize / 2;
            const badgeBorder = Math.max(2, Math.round(2 * BADGE_SCALE));
            const badgeHtml = `<div class="photo-marker-number orbital-badge" style="position:absolute;left:0;top:0;visibility:hidden;cursor:grab;min-width:${badgeSize}px;height:${badgeSize}px;font-size:${badgeFontSize}px;padding:0 ${badgePadding}px;border-radius:${badgeBorderRadius}px;border-width:${badgeBorder}px;line-height:${badgeSize - badgeBorder * 2}px;background:#667eea;color:white;font-weight:bold;border:${badgeBorder}px solid white;box-shadow:0 4px 8px rgba(0,0,0,0.5),0 8px 20px rgba(0,0,0,0.4),0 12px 30px rgba(0,0,0,0.25);">${index + 1}</div>`;
            const badgeIcon = L.divIcon({
                className: 'photo-marker-badge-icon',
                html: badgeHtml,
                iconSize: [badgeIconSize, badgeIconSize],
                iconAnchor: [badgeIconCenter, badgeIconCenter]
            });

            const badgeMarker = L.marker([displayPosition.lat, displayPosition.lng], {
                icon: badgeIcon,
                zIndexOffset: 5000,
                interactive: true
            }).addTo(map);

            // Setup orbital dragging for badge
            setTimeout(() => {
                const badgeEl = badgeMarker.getElement();
                if (badgeEl) {
                    const badge = badgeEl.querySelector('.orbital-badge');
                    if (badge) {
                        setupOrbitalDrag(badge, marker, index, badgeSize, orbitRadius, angle);
                    }
                }
            }, 50);

            numberBadgeMarkers.push(badgeMarker);

            // Re-attach event listeners after adding to map
            setTimeout(() => {
                const el = marker.getElement();
                if (el) {
                    setupPhotoMarkerInteraction(el, photo, index, marker, badgeMarker, updateRubberband, position);
                }
            }, 50);

            photoMarkers.push({ marker, badgeMarker, photo, index, gpsPosition, updateRubberband });
        }
        
        function setupOrbitalDrag(badge, photoMarker, photoIndex, badgeSize, orbitRadius, initialAngle) {
            function getOrbitRadius() {
                return orbitRadius;
            }
            
            function getOrbitCenter() {
                const latLng = photoMarker.getLatLng();
                const containerPoint = map.latLngToContainerPoint(latLng);
                const mapRect = map.getContainer().getBoundingClientRect();
                return {
                    x: mapRect.left + containerPoint.x,
                    y: mapRect.top + containerPoint.y
                };
            }
            
            function updateBadgePosition(angle) {
                const radius = getOrbitRadius();
                const center = getOrbitCenter();
                
                const badgeEl = badge.parentElement;
                const badgeRect = badgeEl.getBoundingClientRect();
                
                const targetScreenX = center.x + Math.cos(angle) * radius;
                const targetScreenY = center.y + Math.sin(angle) * radius;
                
                const x = targetScreenX - badgeRect.left - badgeSize / 2;
                const y = targetScreenY - badgeRect.top - badgeSize / 2;
                
                badge.style.left = x + 'px';
                badge.style.top = y + 'px';
            }
            
            // Immediately reposition badge to correct location and make visible
            updateBadgePosition(initialAngle);
            badge.style.visibility = 'visible';
            
            // Store functions for global drag handler to use
            badge._orbitalData = {
                photoMarker,
                photoIndex,
                badgeSize,
                getOrbitCenter,
                updateBadgePosition
            };
            
            badge.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                orbitalDragState = badge._orbitalData;
                badge.style.cursor = 'grabbing';
                map.dragging.disable();
            });
            
            badge.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                orbitalDragState = badge._orbitalData;
                badge.style.cursor = 'grabbing';
                map.dragging.disable();
            }, { passive: true });
        }
        
        // Global handlers for orbital badge dragging (added once, not per badge)
        document.addEventListener('mousemove', (e) => {
            if (!orbitalDragState) return;
            
            const center = orbitalDragState.getOrbitCenter();
            const angle = Math.atan2(e.clientY - center.y, e.clientX - center.x);
            orbitalDragState.updateBadgePosition(angle);
            badgeOrbitalAngles[orbitalDragState.photoIndex] = angle;
        });
        
        document.addEventListener('mouseup', () => {
            if (orbitalDragState) {
                const badge = document.querySelector(`.orbital-badge[style*="grabbing"]`);
                if (badge) badge.style.cursor = 'grab';
                map.dragging.enable();
                orbitalDragState = null;
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!orbitalDragState) return;
            const touch = e.touches[0];
            const center = orbitalDragState.getOrbitCenter();
            const angle = Math.atan2(touch.clientY - center.y, touch.clientX - center.x);
            orbitalDragState.updateBadgePosition(angle);
            badgeOrbitalAngles[orbitalDragState.photoIndex] = angle;
        }, { passive: true });
        
        document.addEventListener('touchend', () => {
            if (orbitalDragState) {
                map.dragging.enable();
                orbitalDragState = null;
            }
        });

        function setupPhotoMarkerInteraction(element, photo, index, leafletMarker, badgeMarker, updateRubberband, originalPosition) {
            const imgContainer = element.querySelector('.photo-marker-container');
            const img = element.querySelector('.photo-marker-img');
            if (!img || !imgContainer) return;

            const size = PHOTO_MARKER_SIZE;
            let scale = 1;
            let posX = 0;
            let posY = 0;
            let startX, startY, initialX, initialY;
            let baseScale = 1;
            let isMarkerDragging = false;
            let markerDragStartLatLng = null;

            function updateTransform() {
                img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
            }

            function saveTransform() {
                photoMarkerTransforms[index] = { scale, posX, posY, baseScale };
            }

            function applyInitialTransform() {
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const scaleX = size / imgWidth;
                const scaleY = size / imgHeight;
                baseScale = Math.max(scaleX, scaleY);

                // Restore saved transform or use defaults
                if (photoMarkerTransforms[index]) {
                    const saved = photoMarkerTransforms[index];
                    scale = saved.scale;
                    posX = saved.posX;
                    posY = saved.posY;
                } else {
                    scale = baseScale;
                    posX = (size - imgWidth * scale) / 2;
                    posY = (size - imgHeight * scale) / 2;
                }
                updateTransform();
            }

            if (img.complete && img.naturalWidth) {
                applyInitialTransform();
            } else {
                img.onload = applyInitialTransform;
            }

            // Store drag data on the image element for global handler
            img._photoMarkerData = {
                index,
                getState: () => ({ posX, posY, scale }),
                setState: (newPosX, newPosY) => { posX = newPosX; posY = newPosY; },
                updateTransform,
                saveTransform
            };

            // Update cursor based on Option key state
            function updateCursor(altKey) {
                if (altKey) {
                    // Alt held: pan image within circle (hand cursor)
                    element.style.cursor = 'grab';
                    img.style.cursor = 'grab';
                } else {
                    element.style.cursor = 'move';
                    img.style.cursor = 'move';
                }
            }

            // Listen for Alt key changes
            element.addEventListener('mouseenter', (e) => updateCursor(e.altKey));
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Alt' && element.matches(':hover')) {
                    updateCursor(true);
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Alt' && element.matches(':hover')) {
                    updateCursor(false);
                }
            });

            // Mousedown handler - Option/Alt key determines behavior
            element.addEventListener('mousedown', (e) => {
                if (e.altKey) {
                    // Option key held: pan image within the circle
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = posX;
                    initialY = posY;
                    photoMarkerDragState = {
                        isMarkerDrag: false,
                        img,
                        startX, startY,
                        initialX, initialY,
                        data: img._photoMarkerData
                    };
                    e.preventDefault();
                    e.stopPropagation();
                } else {
                    // No Option key: drag the entire marker
                    isMarkerDragging = true;
                    markerDragStartLatLng = leafletMarker.getLatLng();
                    startX = e.clientX;
                    startY = e.clientY;

                    // Store data for global handler
                    photoMarkerDragState = {
                        isMarkerDrag: true,
                        leafletMarker,
                        badgeMarker,
                        updateRubberband,
                        originalPosition,
                        index,
                        startX,
                        startY,
                        startLatLng: markerDragStartLatLng
                    };

                    map.dragging.disable();
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            imgContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const delta = e.deltaY > 0 ? -0.008 : 0.008;
                scale = Math.max(baseScale * 0.5, Math.min(5, scale + delta));
                updateTransform();
                saveTransform();
            }, { passive: false });
        }

        // Global handlers for photo marker interactions (added once, not per marker)
        document.addEventListener('mousemove', (e) => {
            if (!photoMarkerDragState) return;

            if (photoMarkerDragState.isMarkerDrag) {
                // Dragging the entire marker (Option key was held)
                const { leafletMarker, badgeMarker, updateRubberband, startX, startY, startLatLng } = photoMarkerDragState;

                // Convert pixel movement to lat/lng offset
                const startPoint = map.latLngToContainerPoint(startLatLng);
                const newPoint = L.point(
                    startPoint.x + (e.clientX - startX),
                    startPoint.y + (e.clientY - startY)
                );
                const newLatLng = map.containerPointToLatLng(newPoint);

                leafletMarker.setLatLng(newLatLng);
                if (badgeMarker) {
                    badgeMarker.setLatLng(newLatLng);
                }
                if (updateRubberband) {
                    updateRubberband();
                }
            } else {
                // Panning image within the circle
                const { startX, startY, initialX, initialY, data } = photoMarkerDragState;
                const newPosX = initialX + (e.clientX - startX);
                const newPosY = initialY + (e.clientY - startY);
                data.setState(newPosX, newPosY);
                data.updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            if (photoMarkerDragState) {
                if (photoMarkerDragState.isMarkerDrag) {
                    // Save marker offset
                    const { leafletMarker, originalPosition, index } = photoMarkerDragState;
                    const newLatLng = leafletMarker.getLatLng();
                    photoMarkerOffsets[index] = {
                        lat: newLatLng.lat - originalPosition.lat,
                        lng: newLatLng.lng - originalPosition.lng
                    };
                    map.dragging.enable();
                } else {
                    // Save image transform
                    photoMarkerDragState.data.saveTransform();
                }
                photoMarkerDragState = null;
            }
        });

        function createSpiderCluster(cluster) {
            const center = cluster.center;
            const count = cluster.photos.length;
            
            // Calculate positions in a circle around center
            const angleStep = (2 * Math.PI) / count;
            
            cluster.photos.forEach((photoData, i) => {
                const angle = angleStep * i - Math.PI / 2; // Start from top
                
                // Convert pixel distance to approximate lat/lng offset
                const zoom = map.getZoom();
                const metersPerPixel = 156543.03392 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom);
                const spiderDistance = PHOTO_MARKER_SIZE * 0.8; // Scale with marker size
                const offsetMeters = spiderDistance * metersPerPixel;
                
                // Rough conversion (1 degree latitude ‚âà 111,000 meters)
                const latOffset = (offsetMeters * Math.sin(angle)) / 111000;
                const lngOffset = (offsetMeters * Math.cos(angle)) / (111000 * Math.cos(center.lat * Math.PI / 180));
                
                const markerPos = {
                    lat: center.lat + latOffset,
                    lng: center.lng + lngOffset
                };
                
                // Draw spider leg
                const leg = L.polyline([
                    [center.lat, center.lng],
                    [markerPos.lat, markerPos.lng]
                ], {
                    color: '#667eea',
                    weight: 2,
                    opacity: 0.6,
                    dashArray: '4, 4'
                }).addTo(map);
                
                spiderLegs.push(leg);
                
                // Create photo marker
                createPhotoMarker(photoData, markerPos);
            });
            
            // Add center dot
            const centerDot = L.circleMarker([center.lat, center.lng], {
                radius: 5,
                fillColor: '#667eea',
                fillOpacity: 1,
                color: 'white',
                weight: 2
            }).addTo(map);
            
            spiderLegs.push(centerDot);
        }

        // Update spider positions on zoom
        function updateSpiderPositions() {
            if (!photoMarkersMode) return;
            
            // Recreate photo markers to recalculate spider positions
            showPhotoMarkers();
        }

        function showGallery() {
            galleryModal.classList.add('active');
            
            const galleryGrid = document.getElementById('galleryGrid');
            galleryGrid.innerHTML = '';
            
            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            
            // Update gallery title with date range
            const photosWithDates = photosWithGPS.filter(p => p.gps && p.gps.dateTimeObj);
            let titleText = 'Gallery';
            if (photosWithDates.length > 0) {
                const dates = photosWithDates.map(p => p.gps.dateTimeObj);
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                
                if (minDate.toDateString() === maxDate.toDateString()) {
                    // Single date
                    titleText = 'Gallery: ' + formatBrisbaneDate(minDate);
                } else {
                    // Date range
                    titleText = 'Gallery: ' + formatBrisbaneDate(minDate) + ' ‚Äì ' + formatBrisbaneDate(maxDate);
                }
            }
            document.querySelector('#galleryModal .map-header h2').textContent = titleText;
            
            photosWithGPS.forEach((photo, index) => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                
                const number = document.createElement('div');
                number.className = 'gallery-number';
                number.textContent = index + 1;
                
                if (photo.src) {
                    const imgContainer = document.createElement('div');
                    imgContainer.style.width = '100%';
                    imgContainer.style.height = '100%';
                    imgContainer.style.overflow = 'hidden';
                    imgContainer.style.position = 'relative';
                    imgContainer.style.cursor = 'grab';
                    
                    const img = document.createElement('img');
                    img.src = photo.src;
                    img.alt = photo.name;
                    img.style.userSelect = 'none';
                    img.style.display = 'block';
                    
                    // START with object-fit cover for immediate display
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.objectPosition = 'center';
                    
                    // Interactive state
                    let scale = 1;
                    let posX = 0;
                    let posY = 0;
                    let isDragging = false;
                    let startX, startY, initialX, initialY;
                    let baseScale = 1;
                    let isTransformed = false;
                    
                    img.onload = function() {
                        const imgWidth = img.naturalWidth;
                        const imgHeight = img.naturalHeight;
                        const containerRect = imgContainer.getBoundingClientRect();
                        const containerWidth = containerRect.width;
                        const containerHeight = containerRect.height;
                        
                        // Calculate base scale for cover fit
                        const scaleX = containerWidth / imgWidth;
                        const scaleY = containerHeight / imgHeight;
                        baseScale = Math.max(scaleX, scaleY);
                        scale = baseScale;
                        
                        const scaledW = imgWidth * scale;
                        const scaledH = imgHeight * scale;
                        posX = (containerWidth - scaledW) / 2;
                        posY = (containerHeight - scaledH) / 2;
                    };
                    
                    function applyTransform() {
                        if (!isTransformed) {
                            // Switch to transform mode
                            img.style.objectFit = 'none';
                            img.style.width = 'auto';
                            img.style.height = 'auto';
                            img.style.position = 'absolute';
                            img.style.top = '0';
                            img.style.left = '0';
                            isTransformed = true;
                        }
                        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                        img.style.transformOrigin = 'top left';
                        // Add sharpening to compensate for zoom blur
                        img.style.filter = 'contrast(1.05) saturate(1.05)';
                        img.style.imageRendering = 'crisp-edges';
                        img.style.imageRendering = '-webkit-optimize-contrast';
                    }
                    
                    // Mouse drag
                    imgContainer.addEventListener('mousedown', (e) => {
                        applyTransform();
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        initialX = posX;
                        initialY = posY;
                        imgContainer.style.cursor = 'grabbing';
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        applyTransform();
                    });
                    
                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            imgContainer.style.cursor = 'grab';
                        }
                    });
                    
                    // Mouse wheel zoom - MUCH FINER increments
                    imgContainer.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        applyTransform();
                        
                        const delta = e.deltaY > 0 ? -0.02 : 0.02; // Changed from 0.1 to 0.02 (5x finer)
                        const oldScale = scale;
                        scale = Math.max(baseScale * 0.5, Math.min(5, scale + delta));
                        
                        // Zoom toward mouse position
                        const rect = imgContainer.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        
                        posX = mouseX - (mouseX - posX) * (scale / oldScale);
                        posY = mouseY - (mouseY - posY) * (scale / oldScale);
                        
                        applyTransform();
                    }, { passive: false });
                    
                    // Touch support (passive: false because we use preventDefault)
                    imgContainer.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 1) {
                            applyTransform();
                            isDragging = true;
                            const touch = e.touches[0];
                            startX = touch.clientX;
                            startY = touch.clientY;
                            initialX = posX;
                            initialY = posY;
                            e.preventDefault();
                        }
                    }, { passive: false });
                    
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging || e.touches.length === 0) return;
                        const touch = e.touches[0];
                        const dx = touch.clientX - startX;
                        const dy = touch.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        applyTransform();
                    }, { passive: true });
                    
                    document.addEventListener('touchend', () => {
                        isDragging = false;
                    }, { passive: true });
                    
                    imgContainer.appendChild(img);
                    item.appendChild(imgContainer);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'gallery-item-placeholder';
                    placeholder.textContent = 'üì∏';
                    item.appendChild(placeholder);
                }
                
                item.appendChild(number);
                galleryGrid.appendChild(item);
            });
        }

        async function saveGalleryAsImage() {
            const saveBtn = document.getElementById('gallerySaveBtn');
            const galleryTitle = document.querySelector('#galleryModal .map-header h2')?.textContent || 'Gallery';
            
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            
            function safeFilename(s) {
                return (s || 'gallery')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .replace(/[^a-z0-9]+/gi, '_')
                    .replace(/^_+|_+$/g, '')
                    .toLowerCase() || 'gallery';
            }
            
            async function ensureScript(src, testFn, timeoutMs = 15000) {
                if (testFn()) return;
                
                const existing = Array.from(document.scripts).find(s => s.src === src);
                if (existing) {
                    const start = Date.now();
                    while (!testFn()) {
                        if (Date.now() - start > timeoutMs) throw new Error(`Timeout loading ${src}`);
                        await sleep(50);
                    }
                    return;
                }
                
                await new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = resolve;
                    s.onerror = reject;
                    document.head.appendChild(s);
                });
                
                const start = Date.now();
                while (!testFn()) {
                    if (Date.now() - start > timeoutMs) throw new Error(`Timeout initialising ${src}`);
                    await sleep(50);
                }
            }
            
            function downloadDataUrl(dataUrl, baseName) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `${baseName}.jpg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
            
            const prevBtnText = saveBtn?.textContent;
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
            }
            
            const galleryWrapper = document.querySelector('#galleryModal .map-container-wrapper');
            const galleryContainer = document.getElementById('galleryContainer');
            const closeBtn = document.getElementById('closeGalleryButton');
            
            // Store original styles
            const restoreStyles = {
                saveBtnDisplay: saveBtn?.style.display,
                closeBtnDisplay: closeBtn?.style.display,
                containerOverflow: galleryContainer?.style.overflowY
            };
            
            try {
                // Hide UI elements for clean capture
                if (saveBtn) saveBtn.style.display = 'none';
                if (closeBtn) closeBtn.style.display = 'none';
                if (galleryContainer) galleryContainer.style.overflowY = 'hidden';
                
                // Use dom-to-image-more which properly handles object-fit
                await ensureScript(
                    'https://cdn.jsdelivr.net/npm/dom-to-image-more@3.4.5/dist/dom-to-image-more.min.js',
                    () => typeof window.domtoimage !== 'undefined'
                );

                // Wait for all images to be visible and loaded
                await sleep(500);

                const dataUrl = await window.domtoimage.toJpeg(galleryWrapper, {
                    quality: 0.92,
                    bgcolor: '#3c3c3c'
                });
                downloadDataUrl(dataUrl, safeFilename(galleryTitle));
                
            } catch (err) {
                console.error('Gallery save error:', err);
                alert('Failed to save gallery. Error: ' + err.message);
            } finally {
                // Restore UI elements
                if (saveBtn) saveBtn.style.display = restoreStyles.saveBtnDisplay || '';
                if (closeBtn) closeBtn.style.display = restoreStyles.closeBtnDisplay || '';
                if (galleryContainer) galleryContainer.style.overflowY = restoreStyles.containerOverflow || 'auto';
                
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = prevBtnText || 'üíæ Save as JPEG';
                }
            }
        }

        async function saveMapAsImage() {
            const mapSaveBtn = document.getElementById('mapSaveBtn');
            const mapPanelTitle = (document.getElementById('mapPanelTitle')?.textContent || 'map').trim();

            if (!map) return;

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            function safeFilename(s) {
                return (s || 'map')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .replace(/[^a-z0-9]+/gi, '_')
                    .replace(/^_+|_+$/g, '')
                    .toLowerCase() || 'map';
            }

            async function ensureScript(src, testFn, timeoutMs = 15000) {
                if (testFn()) return;

                const existing = Array.from(document.scripts).find(s => s.src === src);
                if (existing) {
                    const start = Date.now();
                    while (!testFn()) {
                        if (Date.now() - start > timeoutMs) throw new Error(`Timeout loading ${src}`);
                        await sleep(50);
                    }
                    return;
                }

                await new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = resolve;
                    s.onerror = reject;
                    document.head.appendChild(s);
                });

                const start = Date.now();
                while (!testFn()) {
                    if (Date.now() - start > timeoutMs) throw new Error(`Timeout initialising ${src}`);
                    await sleep(50);
                }
            }

            async function waitForTileLayerLoad(timeoutMs = 9000) {
                try {
                    map.invalidateSize({ animate: false });
                } catch {
                    map.invalidateSize();
                }

                if (currentTileLayer && typeof currentTileLayer.once === 'function') {
                    await new Promise((resolve) => {
                        const timer = setTimeout(resolve, timeoutMs);
                        currentTileLayer.once('load', () => {
                            clearTimeout(timer);
                            resolve();
                        });
                    });
                }

                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                await sleep(600);
            }

            // Convert blob URL to base64 data URL
            async function blobUrlToDataUrl(blobUrl) {
                try {
                    const response = await fetch(blobUrl);
                    const blob = await response.blob();
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (err) {
                    console.warn('Failed to convert blob URL to data URL:', err);
                    return null;
                }
            }

            // Convert all blob URLs in photo marker images to data URLs for screenshot
            async function convertPhotoMarkersToDataUrls(container) {
                const images = container.querySelectorAll('.photo-marker-img');
                const conversions = [];

                for (const img of images) {
                    if (img.src && img.src.startsWith('blob:')) {
                        conversions.push({
                            img,
                            originalSrc: img.src,
                            promise: blobUrlToDataUrl(img.src)
                        });
                    }
                }

                // Wait for all conversions and apply them
                for (const conv of conversions) {
                    const dataUrl = await conv.promise;
                    if (dataUrl) {
                        conv.img.src = dataUrl;
                    }
                }

                // Return restoration function
                return () => {
                    for (const conv of conversions) {
                        conv.img.src = conv.originalSrc;
                    }
                };
            }

            function downloadDataUrl(dataUrl, baseName) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `${baseName}.jpg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            const prevBtnText = mapSaveBtn?.textContent;
            if (mapSaveBtn) {
                mapSaveBtn.disabled = true;
                mapSaveBtn.textContent = 'Saving...';
            }

            const mapContainer = document.getElementById('mapContainer');
            const restore = {};

            let restorePhotoMarkers = null;

            try {
                // Use dom-to-image-more (actively maintained fork of dom-to-image)
                await ensureScript(
                    'https://cdn.jsdelivr.net/npm/dom-to-image-more@3.4.5/dist/dom-to-image-more.min.js',
                    () => typeof window.domtoimage !== 'undefined'
                );

                await waitForTileLayerLoad();

                const zoomControls = mapContainer.querySelector('.leaflet-control-zoom');
                const attribControls = mapContainer.querySelector('.leaflet-control-attribution');
                if (zoomControls) { restore.zoomDisplay = zoomControls.style.display; zoomControls.style.display = 'none'; }
                if (attribControls) { restore.attribDisplay = attribControls.style.display; attribControls.style.display = 'none'; }

                // Convert blob URLs to data URLs for photo markers (fixes CORS/tainted canvas issues)
                restorePhotoMarkers = await convertPhotoMarkersToDataUrls(mapContainer);
                await sleep(200);

                const baseName = safeFilename(mapPanelTitle);

                // Force Leaflet to redraw canvas layers at current view
                map.invalidateSize({ animate: false });
                await sleep(100);

                const dataUrl = await window.domtoimage.toJpeg(mapContainer, {
                    quality: 0.92,
                    filter: (node) => {
                        if (node.classList && (
                            node.classList.contains('leaflet-control-zoom') ||
                            node.classList.contains('leaflet-control-attribution'))) {
                            return false;
                        }
                        return true;
                    }
                });

                downloadDataUrl(dataUrl, baseName);

            } catch (err) {
                console.error('saveMapAsImage failed:', err);
                alert('Failed to save map image. If you are using Satellite, the tile server may be blocking canvas export (CORS). Try Street/Cycle and retry.');
            } finally {
                // Restore blob URLs to photo markers
                if (restorePhotoMarkers) restorePhotoMarkers();

                const zoomControls = mapContainer.querySelector('.leaflet-control-zoom');
                const attribControls = mapContainer.querySelector('.leaflet-control-attribution');
                if (zoomControls) zoomControls.style.display = restore.zoomDisplay ?? '';
                if (attribControls) attribControls.style.display = restore.attribDisplay ?? '';

                if (typeof monitorMapResize === 'function') monitorMapResize();
                try { map.invalidateSize({ animate: false }); } catch { map.invalidateSize(); }

                if (mapSaveBtn) {
                    mapSaveBtn.disabled = false;
                    mapSaveBtn.textContent = prevBtnText || 'Save';
                }
            }
        }

        function clearAll() {
            if (photos.length === 0 && routes.length === 0) return;
            
            if (confirm('Clear all photos and routes?')) {
                // Close any open popups
                closeAllPhotoPopups();
                
                // Revoke object URLs to free memory
                photos.forEach(photo => {
                    if (photo.src) {
                        URL.revokeObjectURL(photo.src);
                    }
                });
                
                // Reset data arrays
                photos = [];
                routes = [];
                selectedActivities.clear();
                photosWithUnsavedEdits.clear();
                highlightedPhotoName = null;
                copiedGPS = null;
                photoMarkerTransforms = {};
                badgeOrbitalAngles = {};
                photoMarkerOffsets = {};
                userHasInteractedWithMap = false;
                savedMapState = null;

                // Reset UI
                photosGrid.innerHTML = '';
                stats.style.display = 'none';
                errorContainer.innerHTML = '';
                document.getElementById('dateRangeStats').style.display = 'none';
                document.getElementById('routeStats').style.display = 'none';
                document.getElementById('routeFilterContainer').style.display = 'none';
                document.getElementById('activityCheckboxes').innerHTML = '';
                
                // Reset file inputs
                fileInput.value = '';
                routeInput.value = '';

                // Disable buttons
                showMapButton.disabled = true;
                showGalleryButton.disabled = true;
                
                // Clear map if it exists
                if (map) {
                    markers.forEach(marker => map.removeLayer(marker));
                    markers = [];
                    clearPhotoMarkers();
                    resetPhotoMarkerTransforms();
                    routePolylines.forEach(poly => {
                        poly.border.remove();
                        poly.line.remove();
                    });
                    routePolylines = [];
                }
                
                // Close modals
                mapModal.classList.remove('active');
                galleryModal.classList.remove('active');
            }
        }

        function showError(message, type = 'error') {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'error-message';
            errorDiv.style.whiteSpace = 'pre-wrap';
            
            if (type === 'success') {
                errorDiv.style.background = '#d4edda';
                errorDiv.style.color = '#155724';
                errorDiv.style.borderLeftColor = '#28a745';
            } else if (type === 'warning') {
                errorDiv.style.background = '#fff3cd';
                errorDiv.style.color = '#856404';
                errorDiv.style.borderLeftColor = '#ffc107';
            }
            
            errorDiv.textContent = message;
            errorContainer.appendChild(errorDiv);
            
            // Longer timeout for warnings/errors with more info
            const timeout = type === 'success' ? 4000 : 8000;
            setTimeout(() => {
                errorDiv.remove();
            }, timeout);
        }

        // Close map with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && mapModal.classList.contains('active')) {
                closeAllPhotoPopups();
                clearPhotoMarkers();
                mapModal.classList.remove('active');
            }
        });
    </script>
</body>
</html>
