<!--
    Photo Location Mapper
    Copyright (c) 2026 Gordon Williams

    Licensed under the MIT License.
    See LICENSE file for details.

    https://github.com/gordon-williams/photo-location-mapper
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Photo Location Mapper</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/exifreader@4.21.1/dist/exif-reader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            line-height: 1.6;
        }

        button {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            border: none;
            outline: none;
            background: none;
            font-family: inherit;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #555;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
            border: 3px dashed transparent;
            transition: all 0.3s ease;
        }

        header {
            background: #000;
            color: white;
            padding: 8px 30px;
            text-align: center;
        }

        h1 {
            font-size: 1.3em;
            margin: 0 0 2px 0;
        }

        .subtitle {
            opacity: 0.8;
            font-size: 0.8em;
            margin-bottom: 2px;
        }

        .upload-section {
            padding: 12px 30px;
            border-bottom: 1px solid #444;
            background: #333;
            color: white;
        }

        .upload-button {
            background: #667eea;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-block;
            vertical-align: middle;
            box-sizing: border-box;
            text-align: center;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .upload-button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .upload-button:active:not(:disabled) {
            background: #4a5bb8;
            transform: translateY(1px);
            box-shadow: 0 1px 4px rgba(102, 126, 234, 0.3);
        }
        
        .upload-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        input[type="file"] {
            display: none;
        }

        #routeInput {
            display: none;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: inline-block;
            max-width: 100%;
        }

        .stats-item {
            display: inline-block;
            margin: 0 12px 0 0;
            font-weight: 500;
            white-space: nowrap;
        }

        .photos-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 30px;
            background: #555;
        }

        .photo-card {
            background: #e8e8e8;
            border: none;
            border-radius: 8px;
            transition: all 0.3s;
            position: relative;
            z-index: 0;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }

        .photo-card:hover {
            box-shadow: 0 6px 16px rgba(0,0,0,0.4);
            transform: translateY(-2px);
        }
        
        .photo-delete-btn {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(220, 53, 69, 0.95);
            color: white;
            border: 2px solid white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .photo-delete-btn:hover {
            background: rgba(200, 35, 51, 1);
            transform: scale(1.1);
        }

        .photo-delete-btn:active {
            background: rgba(160, 25, 40, 1);
            transform: scale(0.95);
        }

        .gps-input-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }
        
        .gps-input-row label {
            font-weight: 600;
            min-width: 70px;
        }
        
        .gps-input {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: inherit;
        }
        
        .gps-input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .gps-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            justify-content: flex-end;
        }
        
        .gps-btn {
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            color: #333;
            cursor: pointer;
        }
        
        .gps-btn:disabled {
            background: #f0f0f0;
            color: #999;
            cursor: not-allowed;
        }
        
        .gps-btn:hover:not(:disabled) {
            background: #f5f5f5;
            border-color: #999;
        }

        .gps-btn:active:not(:disabled) {
            background: #e8e8e8;
            transform: scale(0.97);
        }

        .photo-card.highlight-moved {
            animation: highlightPulse 1.5s ease-out;
        }
        
        @keyframes highlightPulse {
            0% { box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.8); background: rgba(102, 126, 234, 0.1); }
            100% { box-shadow: 0 0 0 0 rgba(102, 126, 234, 0); background: white; }
        }
        
        /* Lightbox for large photo preview */
        .lightbox {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 20000;
            justify-content: center;
            align-items: center;
        }
        
        .lightbox.active {
            display: flex;
        }
        
        .lightbox-content {
            position: relative;
            max-width: 95vw;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .lightbox-img {
            max-width: 95vw;
            max-height: 85vh;
            object-fit: contain;
            border-radius: 4px;
        }
        
        .lightbox-caption {
            color: white;
            margin-top: 10px;
            font-size: 14px;
            text-align: center;
        }
        
        .lightbox-close {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 32px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            cursor: pointer;
            z-index: 20001;
        }
        
        .lightbox-close:hover {
            background: rgba(255,255,255,0.3);
        }

        .lightbox-close:active {
            background: rgba(255,255,255,0.4);
            transform: scale(0.95);
        }

        .lightbox-nav {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 28px;
            width: 50px;
            height: 80px;
            cursor: pointer;
            z-index: 20001;
        }
        
        .lightbox-nav:hover {
            background: rgba(255,255,255,0.3);
        }

        .lightbox-nav:active:not(:disabled) {
            background: rgba(255,255,255,0.4);
            transform: translateY(-50%) scale(0.95);
        }

        .lightbox-nav:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .lightbox-prev {
            left: 20px;
            border-radius: 4px;
        }
        
        .lightbox-next {
            right: 20px;
            border-radius: 4px;
        }
        
        .lightbox-counter {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 20px;
        }
        
        .photo-preview {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background: #f0f0f0;
            cursor: grab;
            user-select: none;
        }

        .photo-preview:active {
            cursor: grabbing;
        }

        .photo-preview-container {
            width: 100%;
            height: 225px;
            overflow: hidden;
            position: relative;
            background: #f0f0f0;
            z-index: 1;
            cursor: pointer;
        }
        
        .photo-preview-container::before {
            content: '‚õ∂';
            position: absolute;
            top: 8px;
            right: 8px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
            background: rgba(0,0,0,0.6);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
        }
        
        .photo-preview-container:hover::before {
            opacity: 1;
        }

        .photo-preview-container::after {
            content: 'üñêÔ∏è Drag ‚Ä¢ üîç Zoom';
            position: absolute;
            bottom: 35px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.75em;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 5;
        }

        .photo-preview-container:hover::after {
            opacity: 1;
        }

        .photo-preview-draggable {
            cursor: grab;
            user-select: none;
            display: block;
            transform-origin: top left;
        }

        .photo-preview-draggable:active {
            cursor: grabbing;
        }

        .reset-pan {
            position: absolute;
            top: 5px;
            right: 5px;
            background: rgba(255,255,255,0.9);
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8em;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .reset-pan:hover {
            background: white;
        }

        .reset-pan:active {
            background: #e0e0e0;
            transform: scale(0.95);
        }

        .zoom-controls {
            position: absolute;
            bottom: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
            z-index: 10;
        }

        .zoom-btn {
            background: rgba(255,255,255,0.9);
            border: none;
            width: 28px;
            height: 28px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .zoom-btn:hover {
            background: white;
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .map-style-selector {
            padding: 8px 15px;
            background: #333;
            border-bottom: 1px solid #444;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .map-style-selector label {
            font-weight: 500;
            color: white;
        }

        .map-style-selector select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 0.9em;
            background: white;
            cursor: pointer;
        }

        #routeFilterContainer {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #activityCheckboxes {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        #activityCheckboxes label {
            transition: all 0.2s ease;
        }

        #activityCheckboxes label:hover {
            background: #666 !important;
        }

        #activityCheckboxes label:active {
            background: #555 !important;
            transform: scale(0.97);
        }

        .photo-info {
            padding: 15px;
        }

        .photo-name {
            font-weight: 600;
            margin-bottom: 10px;
            color: #333;
            font-size: 0.9em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .location-data {
            font-size: 0.85em;
            color: #666;
            line-height: 1.8;
        }

        .location-data strong {
            color: #333;
            display: inline-block;
            min-width: 80px;
        }

        .no-gps {
            color: #e74c3c;
            font-style: italic;
        }

        .map-controls {
            padding: 20px 30px;
            background: #f8f9fa;
            border-top: 1px solid #e0e0e0;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .map-button, .save-button, .clear-button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .map-button {
            background: #27ae60;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            cursor: pointer;
            transition: all 0.3s;
            box-sizing: border-box;
            vertical-align: middle;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .map-button:hover:not(:disabled) {
            background: #229954;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.4);
        }

        .map-button:active:not(:disabled) {
            background: #1e8449;
            transform: translateY(1px);
            box-shadow: 0 1px 4px rgba(39, 174, 96, 0.3);
        }

        .map-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .save-button {
            background: #667eea;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            transition: all 0.2s;
            box-sizing: border-box;
            vertical-align: middle;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .save-button:hover:not(:disabled) {
            background: #5568d3;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
        }

        .save-button:active:not(:disabled) {
            background: #4a5bb8;
            transform: translateY(1px);
            box-shadow: 0 1px 4px rgba(102, 126, 234, 0.3);
        }

        .save-button:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
        }

        .clear-button {
            background: #e74c3c;
            color: white;
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            font-weight: normal;
            line-height: normal;
            cursor: pointer;
            transition: all 0.3s;
            box-sizing: border-box;
            vertical-align: middle;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            outline: none;
        }

        .clear-button:hover {
            background: #c0392b;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.4);
        }

        .clear-button:active {
            background: #a93226;
            transform: translateY(1px);
            box-shadow: 0 1px 4px rgba(231, 76, 60, 0.3);
        }

        .mapbox-key-btn {
            margin-left: 5px;
            width: 36px;
            height: 36px;
            padding: 0;
            font-size: 16px;
            line-height: 34px;
            text-align: center;
            cursor: pointer;
            background: white;
            border: 1px solid #ccc;
            border-radius: 6px;
            transition: all 0.2s;
            box-sizing: border-box;
        }

        .mapbox-key-btn:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        .mapbox-key-btn:active {
            background: #e0e0e0;
            transform: translateY(1px);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .dialog-btn {
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .dialog-btn-cancel {
            border: 1px solid #ccc;
            background: white;
            color: #333;
        }

        .dialog-btn-cancel:hover {
            background: #f0f0f0;
            border-color: #999;
        }

        .dialog-btn-cancel:active {
            background: #e0e0e0;
            transform: translateY(1px);
        }

        .dialog-btn-danger {
            border: 1px solid #e74c3c;
            background: white;
            color: #e74c3c;
        }

        .dialog-btn-danger:hover {
            background: #fdf2f2;
            border-color: #c0392b;
        }

        .dialog-btn-danger:active {
            background: #f8d7da;
            transform: translateY(1px);
        }

        .dialog-btn-primary {
            border: none;
            background: #667eea;
            color: white;
        }

        .dialog-btn-primary:hover {
            background: #5568d3;
        }

        .dialog-btn-primary:active {
            background: #4a5bb8;
            transform: translateY(1px);
        }

        .map-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .map-modal.active {
            display: flex;
        }
        /* Gallery window: draggable + resizable (non-blocking look) */
        #galleryModal {
            background: transparent;
            align-items: flex-start;
            justify-content: flex-start;
            pointer-events: none; /* allow clicks only on the window itself */
        }
        #galleryModal .map-container-wrapper {
            position: absolute;
            top: 80px;
            left: 80px;
            width: 70vw;
            height: 70vh;
            max-width: 95vw;
            max-height: 90vh;
            min-width: 360px;
            min-height: 260px;
            resize: both;
            overflow: auto;
            border-radius: 10px;
            box-shadow: 0 12px 35px rgba(0,0,0,0.35);
            pointer-events: auto;
            display: block !important;
        }
        #galleryModal .map-header {
            cursor: move;
            user-select: none;
        }


        .map-container-wrapper {
            background: white;
            border-radius: 0;
            width: 100%;
            max-width: 100%;
            height: 100%;
            max-height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: none;
        }

        .map-header {
            padding: 8px 15px;
            background: #000;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .map-header h2 {
            margin: 0;
            font-size: 1.1em;
        }

        .close-button {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            font-size: 1.3em;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }

        .close-button:hover {
            background: rgba(255,255,255,0.3);
        }

        .close-button:active {
            background: rgba(255,255,255,0.15);
            transform: scale(0.95);
        }

        #mapContainer {
            position: relative;
            width: 100%;
            flex: 1;
            min-height: 400px;
        }

        #map {
            width: 100%;
            height: 100%;
        }

        #statusLine {
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
            font-size: 13px;
            color: #ddd;
            padding: 8px 30px;
            min-height: 18px;
            display: none;
        }

        #statusLine:not(:empty) {
            display: block;
        }

        #statusLine::after {
            content: '‚ñã';
            animation: blink 1s step-end infinite;
            color: #667eea;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        @media (max-width: 768px) {
            .photos-grid {
                grid-template-columns: 1fr;
            }

            #mapContainer {
                min-height: 300px;
            }

            .map-container-wrapper {
                max-height: 100vh;
            }

            .map-modal {
                padding: 0;
            }

            .stats-item {
                display: block;
                margin: 5px 0;
            }

            .upload-section {
                flex-direction: column;
            }

            .upload-button {
                width: 100%;
                margin: 5px 0 !important;
            }

            .map-style-selector {
                flex-wrap: wrap;
                gap: 10px;
            }

            .map-style-selector button {
                width: 100%;
                margin: 10px 0 0 0 !important;
            }

            .gallery-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }
        }

        @media (min-width: 769px) and (max-width: 1024px) {
            .gallery-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .marker-popup {
            text-align: center;
        }

        .marker-popup img {
            width: 150px;
            height: 150px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .marker-popup .filename {
            font-weight: 600;
            color: #333;
            margin-bottom: 4px;
        }

        .marker-popup .coords {
            font-size: 0.85em;
            color: #666;
        }

        .numbered-marker {
            z-index: 1000 !important;
        }

        #galleryContainer {
            transition: background 0.3s ease;
        }
        
        #galleryContainer::-webkit-scrollbar {
            width: 8px;
        }
        
        #galleryContainer::-webkit-scrollbar-track {
            background: transparent;
        }
        
        #galleryContainer::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        #galleryContainer::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        #gallerySaveBtn:hover:not(:disabled) {
            background: rgba(255, 255, 255, 0.3) !important;
        }

        #gallerySaveBtn:active:not(:disabled) {
            background: rgba(255, 255, 255, 0.4) !important;
            transform: scale(0.97);
        }

        #gallerySaveBtn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 0;
        }

        .gallery-item {
            position: relative;
            aspect-ratio: 4 / 3;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            background: #f5f5f5;
        }

        .gallery-item img {
            width: 100%;
            height: 100%;
            display: block;
        }

        .gallery-item-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 64px;
        }

        .gallery-number {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #667eea;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            border: 3px solid white;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            z-index: 2;
        }

        @keyframes glow {
            0%, 100% {
                box-shadow: 0 0 0px rgba(39, 174, 96, 0);
                transform: scale(1);
            }
            50% {
                box-shadow: 0 0 20px rgba(39, 174, 96, 0.8);
                transform: scale(1.05);
            }
        }

        /* Disney-style bouncy balloon pop animation */
        @keyframes balloonPop {
            0% {
                transform: scaleY(0.01) scaleX(0.5);
                opacity: 0;
            }
            30% {
                transform: scaleY(1.2) scaleX(0.9);
                opacity: 1;
            }
            50% {
                transform: scaleY(0.9) scaleX(1.1);
            }
            70% {
                transform: scaleY(1.05) scaleX(0.98);
            }
            100% {
                transform: scaleY(1) scaleX(1);
            }
        }

        /* Gallery thumbnails should use the same 4:3 tile behaviour as the main window */
        .gallery-item .photo-preview-container {
            height: 100%;
            background: #f0f0f0;
        }
        .gallery-item .photo-preview-container::after {
            display: none;
        }
        .gallery-item .photo-preview-draggable {
            cursor: default;
        }


/* === Unified main control buttons === */
.ctrl-btn {
  border: none;
  border-radius: 10px;
  padding: 10px 18px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: #fff;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  min-height: 36px;
}

.ctrl-btn.green { background:#4CAF50; }
.ctrl-btn.green:hover { background:#43a047; }
.ctrl-btn.green:active { background:#388e3c; transform: scale(0.97); }

.ctrl-btn.blue { background:#2196F3; }
.ctrl-btn.blue:hover { background:#1e88e5; }
.ctrl-btn.blue:active { background:#1976d2; transform: scale(0.97); }

.ctrl-btn.red { background:#f44336; }
.ctrl-btn.red:hover { background:#e53935; }
.ctrl-btn.red:active { background:#c62828; transform: scale(0.97); }

.ctrl-btn[disabled] {
  background: #9e9e9e !important;
  opacity: 1;
  cursor: not-allowed;
}
.ctrl-btn[disabled]:hover { background: #9e9e9e !important; }

/* Floating Photo Popup Panels */
.photo-popup-panel {
    position: absolute;
    background: white;
    border-radius: 10px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    min-width: 280px;
    min-height: 200px;
    max-width: 90vw;
    max-height: 80vh;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    resize: both;
}

.photo-popup-header {
    background: #000;
    color: white;
    padding: 8px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: move;
    user-select: none;
    flex-shrink: 0;
}

.photo-popup-header h3 {
    margin: 0;
    font-size: 0.95em;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: calc(100% - 30px);
}

.photo-popup-close {
    background: rgba(255,255,255,0.2);
    border: none;
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    cursor: pointer;
    font-size: 1.1em;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
    flex-shrink: 0;
}

.photo-popup-close:hover {
    background: rgba(255,255,255,0.35);
}

.photo-popup-content {
    flex: 1;
    overflow-y: auto;
    padding: 12px;
    display: flex;
    flex-direction: column;
}

.photo-popup-image-container {
    position: relative;
    width: 100%;
    min-height: 150px;
    flex: 1;
    overflow: hidden;
    border-radius: 6px;
    background: #f5f5f5;
    margin-bottom: 10px;
}

.photo-popup-image {
    display: block;
    transform-origin: top left;
    cursor: grab;
    user-select: none;
}

.photo-popup-image:active {
    cursor: grabbing;
}

.photo-popup-number {
    position: absolute;
    bottom: 10px;
    left: 10px;
    background: #667eea;
    color: white;
    width: 42px;
    height: 42px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 18px;
    border: 3px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    z-index: 5;
    pointer-events: none;
}

.photo-popup-placeholder {
    width: 100%;
    height: 150px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 48px;
    border-radius: 6px;
    margin-bottom: 10px;
    position: relative;
}

.photo-popup-details {
    font-size: 0.85em;
    color: #555;
    margin-bottom: 12px;
}

.photo-popup-details div {
    margin-bottom: 4px;
}

.photo-popup-details strong {
    color: #333;
}

.photo-popup-comment-section {
    border-top: 1px solid #eee;
    padding-top: 10px;
}

.photo-popup-comment-section label {
    display: block;
    font-weight: 600;
    font-size: 0.85em;
    color: #333;
    margin-bottom: 6px;
}

.photo-popup-comment {
    width: 100%;
    min-height: 60px;
    padding: 8px 10px;
    border: 1px solid #ddd;
    border-radius: 6px;
    font-family: inherit;
    font-size: 0.9em;
    resize: vertical;
    transition: border-color 0.2s;
}

.photo-popup-comment:focus {
    outline: none;
    border-color: #667eea;
}

.photo-popup-comment-saved {
    font-size: 0.75em;
    color: #27ae60;
    margin-top: 4px;
    opacity: 0;
    transition: opacity 0.3s;
}

.photo-popup-comment-saved.visible {
    opacity: 1;
}

.photo-popup-resize-handle {
    position: absolute;
    bottom: 0;
    right: 0;
    width: 16px;
    height: 16px;
    cursor: nwse-resize;
    background: linear-gradient(135deg, transparent 50%, #ccc 50%, #ccc 60%, transparent 60%, transparent 70%, #ccc 70%, #ccc 80%, transparent 80%);
}

/* Photo Markers on Map */
.photo-marker {
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 3px 10px rgba(0,0,0,0.6), 0 0 0 1px rgba(0,0,0,0.3), 0 8px 25px rgba(0,0,0,0.4);
    overflow: hidden;
    cursor: pointer;
    transition: transform 0.2s, box-shadow 0.2s;
    background: #667eea;
}

.photo-marker:hover {
    transform: scale(1.1);
    box-shadow: 0 5px 15px rgba(0,0,0,0.7), 0 0 0 1px rgba(0,0,0,0.4), 0 12px 35px rgba(0,0,0,0.5);
    z-index: 10000 !important;
}

.photo-marker-container {
    width: 100%;
    height: 100%;
    overflow: hidden;
    position: relative;
    will-change: transform; /* GPU acceleration hint */
}

.photo-marker-img {
    display: block;
    transform-origin: top left;
    cursor: grab;
    user-select: none;
    will-change: transform; /* GPU acceleration for smooth panning/zooming */
}

.photo-marker-img:active {
    cursor: grabbing;
}

.photo-marker-number {
    position: absolute;
    bottom: -12px;
    left: -12px;
    background: #667eea;
    color: white;
    min-width: 28px;
    height: 28px;
    border-radius: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    padding: 0 6px;
    border: 2px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.5), 0 4px 12px rgba(0,0,0,0.3);
    pointer-events: none;
}

.photo-marker-badge-icon .photo-marker-number {
    position: static;
}

/* Orbital draggable badge */
.orbital-badge {
    position: absolute !important;
    pointer-events: auto !important;
    cursor: grab;
    transition: box-shadow 0.1s ease;
    min-width: 28px;
    height: 28px;
    border-radius: 14px;
    font-size: 14px;
    padding: 0 6px;
    border: 2px solid white;
    display: flex;
    align-items: center;
    justify-content: center;
    background: #667eea;
    color: white;
    font-weight: bold;
    box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4), 0 12px 30px rgba(0,0,0,0.25);
}

.orbital-badge:hover {
    box-shadow: 0 5px 12px rgba(102, 126, 234, 0.8), 0 10px 25px rgba(0,0,0,0.5);
    background: #667eea;
}

.orbital-badge:active {
    cursor: grabbing;
    box-shadow: 0 6px 15px rgba(102, 126, 234, 1), 0 12px 30px rgba(0,0,0,0.5);
}

.photo-marker-placeholder {
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
}

.photo-marker-badge-icon {
    background: transparent !important;
    border: none !important;
    overflow: visible !important;
    position: relative;
    pointer-events: none !important;
}

.leaflet-div-icon {
    background: transparent;
    border: none;
}

.photo-marker-icon {
    overflow: visible !important;
}

/* Ensure Leaflet marker pane allows shadow overflow */
.leaflet-marker-pane,
.leaflet-marker-icon {
    overflow: visible !important;
}

/* GPS location dot (shown when marker is dragged away) */
.gps-location-dot {
    background: #667eea;
    border: 2px solid white;
    border-radius: 50%;
    box-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

/* Spider cluster lines */
.spider-leg {
    stroke: #667eea;
    stroke-width: 2;
    stroke-opacity: 0.6;
}

.spider-leg-hover {
    stroke-opacity: 1;
    stroke-width: 3;
}

</style>
</head>
<body>
    <div class="container">
        <header>
            <h1 style="margin: 0 0 2px 0; font-size: 1.3em;">Photo Location Mapper</h1>
            <div class="subtitle" style="font-size: 0.8em;">Extract GPS data from photos and visualize on a map</div>
            <div style="font-size: 0.65em; opacity: 0.6; margin-top: 1px;">v1.1.0 build 74</div>
        </header>

        <div class="upload-section">
            <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px; flex-wrap: wrap;">
                <div style="display: flex; gap: 10px;">
                    <button class="ctrl-btn blue" id="selectPhotosButton" title="Select photos or drag and drop photos anywhere on this page">Select Photos</button>
                    <input type="file" id="fileInput" accept="image/jpeg,image/jpg,image/heic,image/heif" multiple style="display: none;">
                    
                    <button class="ctrl-btn blue" id="routeButton" title="Load route file (GPX or Google Takeout JSON)">Load Route</button>
                    <input type="file" id="routeInput" accept=".gpx,.json,.gz" style="display: none;">
                </div>
                
                <div id="stats" style="display: none; font-size: 0.9em; color: #aaa;">
                    <span class="stats-item"><span id="photoCount">0</span> photos</span>
                    <span class="stats-item"><span id="gpsCount">0</span> GPS</span>
                    <span class="stats-item" id="dateRangeStats" style="display: none;"><span id="dateRange"></span></span>
                    <span class="stats-item" id="routeStats" style="display: none;"><span id="routeCount">0</span> routes</span>
                </div>
                
                <div style="display: flex; gap: 10px;">
                    <button class="ctrl-btn green" id="showMapButton" disabled>Map</button>
                    <button class="ctrl-btn green" id="showGalleryButton" disabled>Gallery</button>
                    <button class="ctrl-btn red" id="clearButton" disabled>Clear All</button>
                </div>
            </div>
        </div>

        <div id="statusLine"></div>

        <div class="photos-grid" id="photosGrid"></div>

    </div>

    <div class="map-modal" id="mapModal">
        <div class="map-container-wrapper">
            <div class="map-header">
                <h2 id="mapPanelTitle">Photo Locations</h2>
                <button class="close-button" id="closeMapButton">√ó</button>
            </div>
            <div class="map-style-selector">
                <label for="mapStyleSelect">Map Style:</label>
                <select id="mapStyleSelect">
                    <option value="osm">Street Map (Standard navigation)</option>
                    <option value="satellite">Satellite (Aerial imagery)</option>
                    <option value="cycle">Cycle Map (Bike routes with contours)</option>
                    <option value="humanitarian" selected>Humanitarian (Clear, simple)</option>
                    <optgroup label="Mapbox (API key required)">
                        <option value="mapbox-streets">Mapbox Streets</option>
                        <option value="mapbox-outdoors">Mapbox Outdoors</option>
                        <option value="mapbox-satellite">Mapbox Satellite</option>
                        <option value="mapbox-satellite-streets">Mapbox Satellite Streets</option>
                    </optgroup>
                </select>
                <button id="mapboxKeyBtn" class="mapbox-key-btn" title="Configure Mapbox API key">üîë</button>
                <button id="toggle3DBtn" class="save-button" style="margin-left: 10px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: none;" title="Toggle 3D terrain view (requires Mapbox API key)">3D</button>
                <button id="resetViewBtn" class="save-button" style="margin-left: 5px;" title="Reset view to show all markers">Reset</button>

                <div id="routeFilterContainer" style="display: none; margin-left: 30px; flex: 1; align-items: center;">
                    <label>Show Activities:</label>
                    <div id="activityCheckboxes" style="display: inline-flex; flex-wrap: wrap; gap: 10px; margin-left: 10px;">
                    </div>
                </div>
                
                <button class="save-button" id="photoMarkersBtn" style="margin-left: auto; background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);" title="Show photo thumbnails on map. Drag to pan image within circle. Hold Alt/Option + drag to move marker.">Photo Markers</button>
                <button class="save-button" id="mapSaveBtn" style="margin-left: 10px;">Save Map Image</button>
            </div>
            <div id="mapContainer" style="position: relative;">
                <div id="map"></div>
                <div id="map3d" style="display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></div>
                <!-- Slider controls overlay at top-left of map -->
                <div id="mapSliderOverlay" style="display: none; position: absolute; top: 10px; left: 50px; z-index: 1000; background: rgba(255,255,255,0.95); padding: 8px 12px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.2); flex-direction: column; gap: 6px;">
                    <div id="markerSizeControl" style="display: none; align-items: center; gap: 8px;">
                        <label style="font-size: 12px; white-space: nowrap; min-width: 50px;">Size:</label>
                        <input type="range" id="markerSizeSlider" min="50" max="400" value="70" style="width: 100px; cursor: pointer;">
                        <span id="markerSizeValue" style="font-size: 12px; min-width: 40px;">70px</span>
                    </div>
                    <div id="numberMarkerSizeControl" style="display: none; align-items: center; gap: 8px;">
                        <label style="font-size: 12px; white-space: nowrap; min-width: 50px;">‚Ññ Size:</label>
                        <input type="range" id="numberMarkerSizeSlider" min="1" max="5" step="0.5" value="1" style="width: 80px; cursor: pointer;">
                        <span id="numberMarkerSizeValue" style="font-size: 12px; min-width: 30px;">1x</span>
                    </div>
                    <div id="spiderSpreadControl" style="display: none; align-items: center; gap: 8px;">
                        <label style="font-size: 12px; white-space: nowrap; min-width: 50px;">Spread:</label>
                        <input type="range" id="spiderSpreadSlider" min="0.5" max="5" step="0.5" value="1.5" style="width: 80px; cursor: pointer;">
                        <span id="spiderSpreadValue" style="font-size: 12px; min-width: 30px;">1.5x</span>
                    </div>
                </div>
            </div>
        </div>
        </div>
    </div>

    <!-- Gallery Modal -->
    <div class="map-modal" id="galleryModal">
        <div class="map-container-wrapper">
            <div class="map-header">
                <h2>Gallery</h2>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button id="gallerySaveBtn" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 0.9em; font-weight: 500; transition: background 0.2s;">Save as JPEG</button>
                    <button class="close-button" id="closeGalleryButton">√ó</button>
                </div>
            </div>
            
            <div id="galleryContainer" style="flex: 1; overflow-y: auto; overflow-x: hidden; padding: 20px; background: #3c3c3c;">
                <div id="galleryGrid" class="gallery-grid">
                </div>
            </div>
        </div>
    </div>

    <!-- Lightbox for large photo preview -->
    <div class="lightbox" id="lightbox">
        <button class="lightbox-close" id="lightboxClose">√ó</button>
        <button class="lightbox-nav lightbox-prev" id="lightboxPrev">‚Äπ</button>
        <button class="lightbox-nav lightbox-next" id="lightboxNext">‚Ä∫</button>
        <div class="lightbox-content">
            <img class="lightbox-img" id="lightboxImg" src="" alt="">
            <div class="lightbox-caption" id="lightboxCaption"></div>
        </div>
        <div class="lightbox-counter" id="lightboxCounter"></div>
    </div>

    <!-- Mapbox API Key Dialog -->
    <div id="mapboxKeyDialog" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;">
        <div style="background: white; border-radius: 12px; max-width: 450px; width: 90%; box-shadow: 0 4px 20px rgba(0,0,0,0.3); overflow: hidden;">
            <h3 style="margin: 0; padding: 12px 24px; font-size: 16px; background: #000; color: white;">Mapbox API Key</h3>
            <div style="padding: 20px 24px;">
            <p style="margin: 0 0 12px 0; font-size: 14px; color: #666;">Enter your Mapbox API key to enable 3D terrain view and additional map styles.</p>
            <p style="margin: 0 0 16px 0; font-size: 13px;"><a href="https://www.mapbox.com/" target="_blank" style="color: #667eea;">Get a free key at mapbox.com ‚Üí</a></p>
            <input type="text" id="mapboxKeyInput" placeholder="pk.eyJ1Ijoi..." style="width: 100%; padding: 10px 12px; font-size: 14px; border: 1px solid #ccc; border-radius: 6px; margin-bottom: 16px; font-family: monospace;">
            <div style="display: flex; gap: 10px; justify-content: flex-end;">
                <button id="mapboxKeyCancelBtn" class="dialog-btn dialog-btn-cancel">Cancel</button>
                <button id="mapboxKeyClearBtn" class="dialog-btn dialog-btn-danger">Clear Key</button>
                <button id="mapboxKeySaveBtn" class="dialog-btn dialog-btn-primary">Save</button>
            </div>
            </div>
        </div>
    </div>

    <script>
        // Performance utilities
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        function throttle(func, limit) {
            let inThrottle;
            return function executedFunction(...args) {
                if (!inThrottle) {
                    func(...args);
                    inThrottle = true;
                    setTimeout(() => inThrottle = false, limit);
                }
            };
        }

        let photos = [];
        let routes = [];
        let routePolylines = [];
        let selectedActivities = new Set();
        let map = null;
        let map3d = null; // Mapbox GL JS 3D map
        let is3DMode = false;
        let mapboxApiKey = localStorage.getItem('mapboxApiKey') || '';
        let currentTileLayer = null;
        let markers = [];
        let photoMarkersMode = false;
        let photoMarkers = [];
        let numberBadgeMarkers = [];
        let spiderLegs = [];
        let PHOTO_MARKER_SIZE = 70; // pixels, adjustable via slider (2D view)
        let NUMBER_MARKER_SIZE = 32; // pixels for number markers, adjustable via slider
        let photoMarkerTransforms = {}; // Store manual adjustments by photo index
        let badgeOrbitalAngles = {}; // Store badge orbital angle by photo index (radians)
        let photoMarkerOffsets = {}; // Store marker position offsets from GPS location { index: { lat, lng } }
        let rubberbandLines = []; // Polylines connecting markers to their GPS locations
        let copiedGPS = null; // Stored GPS coordinates for copy/paste
        let highlightedPhotoName = null; // Photo name to highlight after re-sort
        let lightboxIndex = 0; // Current photo index in lightbox
        let photosWithUnsavedEdits = new Set(); // Track photos with unsaved changes
        let BADGE_SCALE = 1; // Scale factor for orbital number badges (1x to 5x) (2D view)
        const BASE_BADGE_SIZE = 28; // Base badge size in pixels
        let SPIDER_SPREAD = 1.5; // Spread multiplier for spider/rubberband clustering

        // Independent 3D view size settings
        let PHOTO_MARKER_SIZE_3D = 280; // pixels, adjustable via slider (3D view)
        let BADGE_SCALE_3D = 2; // Scale factor for number badges (3D view)

        // Map state tracking - remembers user's map configuration during session
        let userHasInteractedWithMap = false; // True once user has zoomed/panned/configured map
        let savedMapState = null; // { center: {lat, lng}, zoom: number }

        // Global state for orbital badge dragging (to avoid duplicate document listeners)
        let orbitalDragState = null; // { badge, photoMarker, photoIndex, badgeSize, updateFn }
        
        // Global state for photo marker panning (to avoid duplicate document listeners)
        let photoMarkerDragState = null; // { img, startX, startY, initialX, initialY, posX, posY, scale, updateFn, saveFn }

        const fileInput = document.getElementById('fileInput');
        const selectPhotosButton = document.getElementById('selectPhotosButton');
        const routeInput = document.getElementById('routeInput');
        const routeButton = document.getElementById('routeButton');
        const photosGrid = document.getElementById('photosGrid');
        const showMapButton = document.getElementById('showMapButton');
        const showGalleryButton = document.getElementById('showGalleryButton');
        const mapSaveBtn = document.getElementById('mapSaveBtn');
        const clearButton = document.getElementById('clearButton');
        const mapModal = document.getElementById('mapModal');
        const galleryModal = document.getElementById('galleryModal');
        const closeMapButton = document.getElementById('closeMapButton');
        const closeGalleryButton = document.getElementById('closeGalleryButton');
        const gallerySaveBtn = document.getElementById('gallerySaveBtn');
        const statusLine = document.getElementById('statusLine');
        const stats = document.getElementById('stats');
        const mapStyleSelect = document.getElementById('mapStyleSelect');
        const container = document.querySelector('.container');
        
        // Lightbox elements
        const lightbox = document.getElementById('lightbox');
        const lightboxImg = document.getElementById('lightboxImg');
        const lightboxCaption = document.getElementById('lightboxCaption');
        const lightboxCounter = document.getElementById('lightboxCounter');
        const lightboxClose = document.getElementById('lightboxClose');
        const lightboxPrev = document.getElementById('lightboxPrev');
        const lightboxNext = document.getElementById('lightboxNext');

        // Path memory using localStorage
        const STORAGE_KEY = 'photoLocationMapper_paths';
        
        function loadSavedPaths() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    return JSON.parse(saved);
                }
            } catch (e) {
                console.log('Could not load saved paths:', e);
            }
            return { photosFolder: null, routesFolder: null };
        }
        
        function savePaths(paths) {
            try {
                const existing = loadSavedPaths();
                const updated = { ...existing, ...paths };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(updated));
            } catch (e) {
                console.log('Could not save paths:', e);
            }
        }
        
        // Button clicks trigger file inputs
        // Use setTimeout to help with macOS focus issues after file dialogs
        selectPhotosButton.addEventListener('click', () => {
            fileInput.click();
        });

        // Route button opens file picker directly
        routeButton.addEventListener('click', () => {
            routeInput.click();
        });

        // Refocus window after file dialog closes (macOS focus fix)
        fileInput.addEventListener('change', (e) => {
            window.focus();
            handleFileSelect(e);
        });
        routeInput.addEventListener('change', (e) => {
            window.focus();
            handleRouteSelect(e);
        });
        showMapButton.addEventListener('click', showMap);
        showGalleryButton.addEventListener('click', showGallery);
        mapSaveBtn.addEventListener('click', saveMapAsImage);
        const photoMarkersBtn = document.getElementById('photoMarkersBtn');
        photoMarkersBtn.addEventListener('click', togglePhotoMarkers);
        
        const markerSizeSlider = document.getElementById('markerSizeSlider');
        const markerSizeValue = document.getElementById('markerSizeValue');
        const markerSizeControl = document.getElementById('markerSizeControl');

        // Performance threshold for hiding photo images during slider drag
        const SLIDER_PERF_THRESHOLD = 5;
        let sliderDragging = false;

        // Hide photo images and show placeholder circles during slider drag (2D performance mode)
        function setPhotoMarkersPlaceholderMode(enabled) {
            photoMarkers.forEach(pm => {
                if (pm.marker) {
                    const el = pm.marker.getElement();
                    if (el) {
                        const img = el.querySelector('.photo-marker-img');
                        const container = el.querySelector('.photo-marker-container');
                        if (img && container) {
                            if (enabled) {
                                img.style.visibility = 'hidden';
                                container.style.background = '#888';
                            } else {
                                img.style.visibility = 'visible';
                                container.style.background = '';
                            }
                        }
                    }
                }
            });
        }

        // Update 2D photo marker circle sizes in-place without full re-render
        function updatePhotoMarkerSizes(size) {
            const shadowPadding = 40;
            const totalSize = size + shadowPadding * 2;
            photoMarkers.forEach(pm => {
                if (pm.marker) {
                    const el = pm.marker.getElement();
                    if (el) {
                        // Update Leaflet wrapper element
                        el.style.width = totalSize + 'px';
                        el.style.height = totalSize + 'px';
                        // Update inner wrapper div (first child)
                        const wrapper = el.firstElementChild;
                        if (wrapper) {
                            wrapper.style.width = totalSize + 'px';
                            wrapper.style.height = totalSize + 'px';
                        }
                        // Update .photo-marker div
                        const photoMarker = el.querySelector('.photo-marker');
                        if (photoMarker) {
                            photoMarker.style.width = size + 'px';
                            photoMarker.style.height = size + 'px';
                        }
                    }
                    // Update icon size/anchor
                    const icon = pm.marker.getIcon();
                    if (icon && icon.options) {
                        icon.options.iconSize = [totalSize, totalSize];
                        icon.options.iconAnchor = [totalSize / 2, totalSize / 2];
                    }
                }
            });
        }

        // Update 2D number badge sizes in-place without full re-render
        function updateNumberBadgeSizes(scale) {
            const badgeSize = Math.round(BASE_BADGE_SIZE * scale);
            const badgeFontSize = Math.round(14 * scale);
            const badgePadding = Math.round(6 * scale);
            const badgeBorderRadius = badgeSize / 2;
            const badgeBorder = Math.max(2, Math.round(2 * scale));

            numberBadgeMarkers.forEach(badgeMarker => {
                if (badgeMarker) {
                    const el = badgeMarker.getElement();
                    if (el) {
                        const badge = el.querySelector('.orbital-badge');
                        if (badge) {
                            badge.style.minWidth = badgeSize + 'px';
                            badge.style.height = badgeSize + 'px';
                            badge.style.fontSize = badgeFontSize + 'px';
                            badge.style.padding = '0 ' + badgePadding + 'px';
                            badge.style.borderRadius = badgeBorderRadius + 'px';
                            badge.style.borderWidth = badgeBorder + 'px';
                            badge.style.lineHeight = (badgeSize - badgeBorder * 2) + 'px';
                        }
                    }
                }
            });
        }

        // Debounced marker refresh for slider performance
        const debouncedMarkerRefresh = debounce(() => {
            if (photoMarkersMode) {
                if (is3DMode) {
                    add3DMarkers();
                } else {
                    showPhotoMarkers();
                }
            }
        }, 150);

        markerSizeSlider.addEventListener('input', () => {
            const newSize = parseInt(markerSizeSlider.value);

            if (is3DMode) {
                // 3D mode - always dynamic (only one photo shown at a time)
                PHOTO_MARKER_SIZE_3D = newSize;
                markerSizeValue.textContent = PHOTO_MARKER_SIZE_3D + 'px';
                if (photoMarkersMode) {
                    add3DMarkers();
                }
            } else {
                // 2D mode
                const oldSize = PHOTO_MARKER_SIZE;
                PHOTO_MARKER_SIZE = newSize;
                markerSizeValue.textContent = PHOTO_MARKER_SIZE + 'px';

                // Scale the saved transforms proportionally to the new size (2D only)
                const sizeRatio = newSize / oldSize;
                Object.keys(photoMarkerTransforms).forEach(key => {
                    const transform = photoMarkerTransforms[key];
                    if (transform) {
                        transform.scale *= sizeRatio;
                        transform.baseScale *= sizeRatio;
                        transform.posX *= sizeRatio;
                        transform.posY *= sizeRatio;
                    }
                });

                // Always resize circles dynamically
                if (photoMarkersMode) {
                    const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
                    // Hide images during drag for many photos (performance)
                    if (photosWithGPS.length > SLIDER_PERF_THRESHOLD && !sliderDragging) {
                        sliderDragging = true;
                        setPhotoMarkersPlaceholderMode(true);
                    }
                    updatePhotoMarkerSizes(newSize);
                }
            }
        });

        markerSizeSlider.addEventListener('change', () => {
            // Slider released - restore images and do full re-render
            if (!is3DMode && photoMarkersMode) {
                if (sliderDragging) {
                    sliderDragging = false;
                    setPhotoMarkersPlaceholderMode(false);
                }
                showPhotoMarkers();
            }
        });

        const numberMarkerSizeSlider = document.getElementById('numberMarkerSizeSlider');
        const numberMarkerSizeValue = document.getElementById('numberMarkerSizeValue');
        const numberMarkerSizeControl = document.getElementById('numberMarkerSizeControl');

        numberMarkerSizeSlider.addEventListener('input', () => {
            const newScale = parseFloat(numberMarkerSizeSlider.value);

            if (is3DMode) {
                // 3D mode - always dynamic
                BADGE_SCALE_3D = newScale;
                numberMarkerSizeValue.textContent = BADGE_SCALE_3D + 'x';
                if (photoMarkersMode) {
                    add3DMarkers();
                }
            } else {
                // 2D mode - dynamic resize (badges are small/vector-based)
                BADGE_SCALE = newScale;
                numberMarkerSizeValue.textContent = BADGE_SCALE + 'x';
                if (photoMarkersMode) {
                    updateNumberBadgeSizes(newScale);
                }
            }
        });

        const spiderSpreadSlider = document.getElementById('spiderSpreadSlider');
        const spiderSpreadValue = document.getElementById('spiderSpreadValue');

        spiderSpreadSlider.addEventListener('input', () => {
            SPIDER_SPREAD = parseFloat(spiderSpreadSlider.value);
            spiderSpreadValue.textContent = SPIDER_SPREAD + 'x';
            debouncedMarkerRefresh();
        });

        clearButton.addEventListener('click', clearAll);
        closeMapButton.addEventListener('click', () => {
            closeAllPhotoPopups();
            clearPhotoMarkers();
            mapModal.classList.remove('active');
        });
        closeGalleryButton.addEventListener('click', () => galleryModal.classList.remove('active'));
        gallerySaveBtn.addEventListener('click', saveGalleryAsImage);

        // Make the gallery behave like a draggable + resizable window
        (function enableGalleryWindow() {
            const modal = galleryModal;
            const wrapper = modal.querySelector('.map-container-wrapper');
            const header = modal.querySelector('.map-header');

            let isDraggingWin = false;
            let startX = 0, startY = 0;
            let startLeft = 0, startTop = 0;

            header.addEventListener('mousedown', (e) => {
                // Only start drag when the modal is open
                if (!modal.classList.contains('active')) return;
                isDraggingWin = true;

                const rect = wrapper.getBoundingClientRect();
                startX = e.clientX;
                startY = e.clientY;
                startLeft = rect.left;
                startTop = rect.top;

                // Bring to front
                wrapper.style.zIndex = '2000';

                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDraggingWin) return;

                const dx = e.clientX - startX;
                const dy = e.clientY - startY;

                let newLeft = startLeft + dx;
                let newTop = startTop + dy;

                // Clamp inside viewport with a small margin
                const margin = 10;
                const w = wrapper.getBoundingClientRect().width;
                const h = wrapper.getBoundingClientRect().height;

                const maxLeft = window.innerWidth - w - margin;
                const maxTop = window.innerHeight - h - margin;

                newLeft = Math.min(maxLeft, Math.max(margin, newLeft));
                newTop = Math.min(maxTop, Math.max(margin, newTop));

                wrapper.style.left = newLeft + 'px';
                wrapper.style.top = newTop + 'px';
            });

            document.addEventListener('mouseup', () => {
                isDraggingWin = false;
            });
        })();


        mapStyleSelect.addEventListener('change', changeMapStyle);
        document.getElementById('mapboxKeyBtn').addEventListener('click', showMapboxKeyDialog);
        document.getElementById('toggle3DBtn').addEventListener('click', toggle3DView);
        document.getElementById('resetViewBtn').addEventListener('click', resetView);

        // Mapbox API key dialog buttons
        document.getElementById('mapboxKeySaveBtn').addEventListener('click', saveMapboxKey);
        document.getElementById('mapboxKeyCancelBtn').addEventListener('click', hideMapboxKeyDialog);
        document.getElementById('mapboxKeyClearBtn').addEventListener('click', clearMapboxKey);
        document.getElementById('mapboxKeyDialog').addEventListener('click', (e) => {
            if (e.target.id === 'mapboxKeyDialog') hideMapboxKeyDialog();
        });
        document.getElementById('mapboxKeyInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') saveMapboxKey();
            if (e.key === 'Escape') hideMapboxKeyDialog();
        });

        // Drag and drop support
        container.addEventListener('dragover', handleDragOver);
        container.addEventListener('drop', handleDrop);
        container.addEventListener('dragleave', handleDragLeave);
        container.addEventListener('dragenter', handleDragEnter);

        // Handle window resize to update map
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (map && mapModal.classList.contains('active')) {
                    map.invalidateSize();
                }
            }, 100);
        });

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
        }

        function handleDragEnter(e) {
            e.preventDefault();
            e.stopPropagation();
            container.style.borderColor = '#667eea';
            container.style.backgroundColor = '#f8f9ff';
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            if (e.target === container) {
                container.style.borderColor = '';
                container.style.backgroundColor = '';
            }
        }

        async function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            container.style.borderColor = '';
            container.style.backgroundColor = '';

            const files = Array.from(e.dataTransfer.files);
            if (files.length === 0) return;

            // Filter for image files
            const imageFiles = files.filter(f => 
                f.type.startsWith('image/') || 
                f.name.toLowerCase().endsWith('.heic') || 
                f.name.toLowerCase().endsWith('.heif')
            );

            if (imageFiles.length > 0) {
                for (let i = 0; i < imageFiles.length; i++) {
                    const file = imageFiles[i];
                    setStatus(`Processing ${file.name} (${i + 1}/${imageFiles.length})...`);
                    try {
                        await processPhoto(file);
                    } catch (error) {
                        console.error(`Error processing ${file.name}:`, error);
                        setStatus(`Failed to process ${file.name}: ${error.message}`, 4000);
                    }
                }

                // Sort photos by datetime (chronological order)
                photos.sort((a, b) => {
                    if (!a.gps || !a.gps.dateTimeObj) return 1;
                    if (!b.gps || !b.gps.dateTimeObj) return -1;
                    return a.gps.dateTimeObj - b.gps.dateTimeObj;
                });

                clearStatus();
                updateStats();
                renderPhotos();
                
                // Preserve route filter display if routes exist
                if (routes.length > 0) {
                    updateRouteFilter();
                }
            }
        }

        async function handleFileSelect(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;

            // Try to extract folder path from first file
            if (files[0].webkitRelativePath) {
                const pathParts = files[0].webkitRelativePath.split('/');
                if (pathParts.length > 1) {
                    savePaths({ photosFolder: pathParts.slice(0, -1).join('/') });
                }
            } else if (files[0].name) {
                // For regular file picker, we can only note that photos were loaded
                // The path isn't available, but we can store a timestamp reference
                savePaths({ photosFolder: `(${files.length} photos loaded ${new Date().toLocaleDateString()})` });
            }

            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                setStatus(`Processing ${file.name} (${i + 1}/${files.length})...`);
                try {
                    await processPhoto(file);
                } catch (error) {
                    console.error(`Error processing ${file.name}:`, error);
                    setStatus(`Failed to process ${file.name}: ${error.message}`, 4000);
                }
            }

            // Sort photos by datetime (chronological order)
            photos.sort((a, b) => {
                // Photos without GPS or datetime go to the end
                if (!a.gps || !a.gps.dateTimeObj) return 1;
                if (!b.gps || !b.gps.dateTimeObj) return -1;

                // Sort by datetime
                return a.gps.dateTimeObj - b.gps.dateTimeObj;
            });

            clearStatus();
            updateStats();
            renderPhotos();
            
            // Preserve route filter display if routes exist
            if (routes.length > 0) {
                updateRouteFilter();
            }
            
            // Reset file input
            fileInput.value = '';
        }

        async function handleRouteSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            setStatus(`Loading ${file.name}...`);

            try {
                const routesBefore = routes.length;

                // Auto-detect format based on file extension
                const fileName = file.name.toLowerCase();
                if (fileName.endsWith('.gpx')) {
                    await parseGPXFile(file);
                } else if (fileName.endsWith('.json') || fileName.endsWith('.gz')) {
                    await parseRouteFile(file);
                } else {
                    // Try to detect from content
                    const text = await file.text();
                    if (text.trim().startsWith('<?xml') || text.trim().startsWith('<gpx')) {
                        await parseGPXFile(file);
                    } else {
                        // Assume JSON format
                        await parseRouteFile(file);
                    }
                }

                const routesAdded = routes.length - routesBefore;

                if (routesAdded === 0) {
                    setStatus(`No routes found in ${file.name}`, 4000);
                } else {
                    setStatus(`Loaded ${routesAdded} route${routesAdded !== 1 ? 's' : ''} from ${file.name}`, 3000);
                }

            } catch (error) {
                console.error('Error loading route file:', error);
                setStatus(`Error loading ${file.name}: ${error.message}`, 5000);
            }

            updateStats();
            updateRouteFilter();

            routeInput.value = '';
        }

        async function parseRouteFile(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                let jsonText;

                if (file.name.endsWith('.gz')) {
                    // Decompress gzip
                    const decompressed = pako.ungzip(new Uint8Array(arrayBuffer), { to: 'string' });
                    jsonText = decompressed;
                } else {
                    jsonText = new TextDecoder().decode(arrayBuffer);
                }

                const data = JSON.parse(jsonText);
                
                if (data.timelineItems) {
                    data.timelineItems.forEach(item => {
                        if (!item.isVisit && item.samples && item.samples.length > 0) {
                            // Extract route path from samples
                            const path = item.samples
                                .filter(s => s.location && s.location.latitude && s.location.longitude)
                                .map(s => ({
                                    lat: s.location.latitude,
                                    lng: s.location.longitude,
                                    timestamp: s.date
                                }));

                            if (path.length > 1) {
                                const startTime = new Date(item.startDate);
                                const endTime = new Date(item.endDate);

                                // Get activity type from various possible fields
                                let rawActivityType = item.activityType ||
                                                      item.activity?.topActivity?.type ||
                                                      item.samples?.[0]?.classifiedType ||
                                                      'unknown';

                                // Normalize activity type names
                                const activityType = normalizeActivityType(rawActivityType);

                                // Skip stationary data
                                if (activityType === 'stationary') return;

                                routes.push({
                                    date: startTime.toISOString().split('T')[0],
                                    startTime: startTime,
                                    endTime: endTime,
                                    path: path,
                                    activityType: activityType,
                                    distance: calculateDistance(path)
                                });
                            }
                        }
                    });
                }
            } catch (error) {
                console.error('Error parsing route file:', error);
                throw error;
            }
        }

        // Normalize activity type names from various formats (Google Takeout, Arc, etc.)
        function normalizeActivityType(rawType) {
            if (!rawType) return 'unknown';

            const type = rawType.toLowerCase().trim();

            // Map various activity type names to consistent values
            const activityMap = {
                // Walking variants
                'walking': 'walking',
                'walk': 'walking',
                'on_foot': 'walking',
                'onfoot': 'walking',
                'foot': 'walking',

                // Running variants
                'running': 'running',
                'run': 'running',

                // Cycling variants
                'cycling': 'cycling',
                'cycle': 'cycling',
                'biking': 'cycling',
                'bike': 'cycling',
                'bicycle': 'cycling',
                'on_bicycle': 'cycling',

                // Driving/Car variants
                'driving': 'driving',
                'drive': 'driving',
                'car': 'driving',
                'in_vehicle': 'driving',
                'invehicle': 'driving',
                'automotive': 'driving',
                'automobile': 'driving',
                'motor_vehicle': 'driving',

                // Public transport variants
                'bus': 'bus',
                'in_bus': 'bus',
                'train': 'train',
                'in_train': 'train',
                'subway': 'subway',
                'in_subway': 'subway',
                'tram': 'tram',
                'in_tram': 'tram',
                'ferry': 'ferry',
                'in_ferry': 'ferry',

                // Air travel
                'flying': 'flying',
                'flight': 'flying',
                'airplane': 'flying',
                'in_airplane': 'flying',
                'plane': 'flying',

                // Stationary
                'stationary': 'stationary',
                'still': 'stationary',
                'not_moving': 'stationary',

                // Other
                'unknown': 'unknown',
                'unknown_activity_type': 'unknown'
            };

            return activityMap[type] || type;
        }

        function calculateDistance(path) {
            let total = 0;
            for (let i = 1; i < path.length; i++) {
                const R = 6371000; // Earth's radius in meters
                const lat1 = path[i-1].lat * Math.PI / 180;
                const lat2 = path[i].lat * Math.PI / 180;
                const dLat = (path[i].lat - path[i-1].lat) * Math.PI / 180;
                const dLon = (path[i].lng - path[i-1].lng) * Math.PI / 180;

                const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                         Math.cos(lat1) * Math.cos(lat2) *
                         Math.sin(dLon/2) * Math.sin(dLon/2);
                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
                total += R * c;
            }
            return total;
        }

        // Show activity type selection dialog
        function showActivityTypeDialog(trackName, inferredType) {
            return new Promise((resolve) => {
                const overlay = document.createElement('div');
                overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.5);z-index:10001;display:flex;align-items:center;justify-content:center;';

                const dialog = document.createElement('div');
                dialog.style.cssText = 'background:white;border-radius:12px;max-width:400px;width:90%;box-shadow:0 4px 20px rgba(0,0,0,0.3);overflow:hidden;';

                const title = document.createElement('h3');
                title.style.cssText = 'margin:0;padding:12px 20px;font-size:16px;background:#000;color:white;';
                title.textContent = 'Select Activity Type';

                const content = document.createElement('div');
                content.style.cssText = 'padding:20px;';

                const desc = document.createElement('p');
                desc.style.cssText = 'margin:0 0 15px 0;font-size:14px;color:#666;';
                desc.textContent = trackName
                    ? `The route "${trackName}" has no activity type. Please select one:`
                    : 'This GPX file has no activity type. Please select one:';
                content.appendChild(desc);

                if (inferredType && inferredType !== 'unknown') {
                    const hint = document.createElement('p');
                    hint.style.cssText = 'margin:0 0 15px 0;font-size:13px;color:#888;font-style:italic;';
                    hint.textContent = `Based on speed, this looks like: ${inferredType}`;
                    content.appendChild(hint);
                }

                const activities = ['walking', 'running', 'cycling', 'driving'];
                const colors = { walking: '#4CAF50', running: '#FF9800', cycling: '#2196F3', driving: '#9C27B0' };

                const btnContainer = document.createElement('div');
                btnContainer.style.cssText = 'display:grid;grid-template-columns:1fr 1fr;gap:10px;';

                activities.forEach(activity => {
                    const btn = document.createElement('button');
                    btn.style.cssText = `padding:12px;border:none;border-radius:8px;font-size:14px;font-weight:500;cursor:pointer;color:white;background:${colors[activity]};transition:opacity 0.2s;`;
                    btn.textContent = activity.charAt(0).toUpperCase() + activity.slice(1);
                    if (activity === inferredType) {
                        btn.style.outline = '3px solid #333';
                        btn.style.outlineOffset = '2px';
                    }
                    btn.addEventListener('mouseover', () => btn.style.opacity = '0.85');
                    btn.addEventListener('mouseout', () => { btn.style.opacity = '1'; btn.style.transform = ''; });
                    btn.addEventListener('mousedown', () => { btn.style.opacity = '0.7'; btn.style.transform = 'scale(0.97)'; });
                    btn.addEventListener('mouseup', () => { btn.style.opacity = '0.85'; btn.style.transform = ''; });
                    btn.addEventListener('click', () => {
                        document.body.removeChild(overlay);
                        resolve(activity);
                    });
                    btnContainer.appendChild(btn);
                });

                content.appendChild(btnContainer);
                dialog.appendChild(title);
                dialog.appendChild(content);
                overlay.appendChild(dialog);
                document.body.appendChild(overlay);
            });
        }

        async function parseGPXFile(file) {
            try {
                const text = await file.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'application/xml');

                // Check for parse errors
                const parseError = xml.querySelector('parsererror');
                if (parseError) {
                    throw new Error('Invalid GPX XML format');
                }

                // Parse all tracks (<trk> elements)
                const tracks = xml.querySelectorAll('trk');

                // Helper to infer activity type from average speed (km/h)
                function inferActivityFromSpeed(avgSpeedKmh) {
                    if (avgSpeedKmh < 1) return 'stationary';
                    if (avgSpeedKmh < 7) return 'walking';      // < 7 km/h
                    if (avgSpeedKmh < 15) return 'running';     // 7-15 km/h
                    if (avgSpeedKmh < 40) return 'cycling';     // 15-40 km/h
                    return 'driving';                            // > 40 km/h
                }

                // Collect routes that need activity type selection
                const pendingRoutes = [];
                let needsUserInput = false;

                for (const track of tracks) {
                    const typeEl = track.querySelector('type');
                    const nameEl = track.querySelector('name');
                    const explicitType = typeEl ? typeEl.textContent.toLowerCase() : null;
                    const trackName = nameEl ? nameEl.textContent : null;

                    // Skip stationary data
                    if (explicitType === 'stationary') continue;

                    // Get all track segments
                    const segments = track.querySelectorAll('trkseg');

                    for (const segment of segments) {
                        const trackpoints = segment.querySelectorAll('trkpt');
                        if (trackpoints.length < 2) continue;

                        const path = [];
                        let startTime = null;
                        let endTime = null;
                        let hasTimestamps = false;

                        trackpoints.forEach(trkpt => {
                            const lat = parseFloat(trkpt.getAttribute('lat'));
                            const lng = parseFloat(trkpt.getAttribute('lon'));
                            const timeEl = trkpt.querySelector('time');
                            const eleEl = trkpt.querySelector('ele');

                            if (!isNaN(lat) && !isNaN(lng)) {
                                const point = { lat, lng };

                                if (timeEl) {
                                    hasTimestamps = true;
                                    const timestamp = new Date(timeEl.textContent);
                                    point.timestamp = timestamp.toISOString();
                                    if (!startTime) startTime = timestamp;
                                    endTime = timestamp;
                                }

                                if (eleEl) {
                                    point.ele = parseFloat(eleEl.textContent);
                                }

                                path.push(point);
                            }
                        });

                        if (path.length > 1) {
                            // Calculate distance
                            const distanceKm = calculateDistance(path) / 1000;

                            // Determine activity type
                            let activityType = explicitType;
                            let inferredType = null;

                            if (!activityType) {
                                // Try to infer from speed if we have timestamps
                                if (hasTimestamps && startTime && endTime) {
                                    const durationHours = (endTime - startTime) / (1000 * 60 * 60);
                                    if (durationHours > 0.001) { // At least a few seconds
                                        const avgSpeedKmh = distanceKm / durationHours;
                                        inferredType = inferActivityFromSpeed(avgSpeedKmh);
                                        if (inferredType === 'stationary') continue;
                                    }
                                }
                                // Mark that we need user input
                                needsUserInput = true;
                            }

                            // Use current time if no explicit times
                            if (!startTime) {
                                startTime = new Date();
                                endTime = new Date();
                            }

                            const routeData = {
                                date: startTime.toISOString().split('T')[0],
                                startTime: startTime,
                                endTime: endTime,
                                path: path,
                                activityType: activityType,
                                inferredType: inferredType,
                                distance: distanceKm * 1000, // Store in meters
                                name: trackName,
                                source: 'gpx'
                            };

                            if (activityType) {
                                routes.push(routeData);
                            } else {
                                pendingRoutes.push(routeData);
                            }
                        }
                    }
                }

                // If we have pending routes, ask user for activity type (once for all)
                if (pendingRoutes.length > 0) {
                    const firstRoute = pendingRoutes[0];
                    const selectedType = await showActivityTypeDialog(
                        firstRoute.name || (pendingRoutes.length > 1 ? `${pendingRoutes.length} routes` : null),
                        firstRoute.inferredType
                    );

                    // Apply selected type to all pending routes
                    pendingRoutes.forEach(route => {
                        route.activityType = selectedType;
                        delete route.inferredType;
                        routes.push(route);
                    });
                }

            } catch (error) {
                console.error('Error parsing GPX file:', error);
                throw error;
            }
        }

        function updateRouteFilter() {
            if (routes.length === 0) return;

            const routeFilterContainer = document.getElementById('routeFilterContainer');
            routeFilterContainer.style.display = 'flex';
            
            const checkboxContainer = document.getElementById('activityCheckboxes');
            checkboxContainer.innerHTML = '';
            
            // Get unique activity types
            const activityTypes = [...new Set(routes.map(r => r.activityType))];
            
            // Initialize selectedActivities if empty (first time)
            if (selectedActivities.size === 0) {
                activityTypes.forEach(activity => selectedActivities.add(activity));
            }
            
            // Create checkbox for each activity
            activityTypes.forEach(activity => {
                const label = document.createElement('label');
                label.style.display = 'inline-flex';
                label.style.alignItems = 'center';
                label.style.gap = '5px';
                label.style.padding = '5px 10px';
                label.style.background = '#555';
                label.style.borderRadius = '6px';
                label.style.cursor = 'pointer';
                label.style.fontSize = '0.85em';
                label.style.border = '2px solid transparent';
                label.style.color = 'white';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = activity;
                checkbox.checked = selectedActivities.has(activity);

                if (!checkbox.checked) {
                    label.style.borderColor = '#777';
                    label.style.opacity = '0.6';
                }

                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedActivities.add(activity);
                        label.style.borderColor = 'transparent';
                        label.style.opacity = '1';
                    } else {
                        selectedActivities.delete(activity);
                        label.style.borderColor = '#777';
                        label.style.opacity = '0.6';
                    }
                    filterRoutes();
                });
                
                const activityName = activity.charAt(0).toUpperCase() + activity.slice(1);
                const color = getActivityColor(activity);
                
                const colorDot = document.createElement('span');
                colorDot.textContent = '‚óè';
                colorDot.style.color = color;
                colorDot.style.fontSize = '1.2em';
                
                const text = document.createElement('span');
                text.textContent = activityName;
                
                label.appendChild(checkbox);
                label.appendChild(colorDot);
                label.appendChild(text);
                checkboxContainer.appendChild(label);
            });
        }

        function filterRoutes() {
            if (is3DMode) {
                // 3D mode - rebuild routes with current filter
                // add3DRoutes handles removal of existing layers internally
                if (map3d) {
                    add3DRoutes();
                }
            } else {
                // 2D mode - hide/show routes based on selected activities
                if (!map) return;
                routes.forEach((route, index) => {
                    if (routePolylines[index]) {
                        if (selectedActivities.has(route.activityType)) {
                            routePolylines[index].border.addTo(map);
                            routePolylines[index].line.addTo(map);
                        } else {
                            routePolylines[index].border.remove();
                            routePolylines[index].line.remove();
                        }
                    }
                });
            }
        }

        async function processPhoto(file) {
            // Check if photo already exists (by filename)
            const existingIndex = photos.findIndex(p => p.name === file.name);
            
            // Extract GPS data first using ExifReader (works with HEIC and JPEG)
            const gpsData = await extractGPSData(file);
            
            // Create preview image - convert HEIC to JPEG for compatibility
            const imageSrc = await createImagePreview(file);
            
            if (existingIndex >= 0) {
                // Update existing photo but preserve comment
                const existingComment = photos[existingIndex].comment;
                const existingViewTransform = photos[existingIndex].viewTransform;
                
                // Revoke old URL to free memory
                if (photos[existingIndex].src) {
                    URL.revokeObjectURL(photos[existingIndex].src);
                }
                
                photos[existingIndex] = {
                    name: file.name,
                    src: imageSrc,
                    gps: gpsData,
                    file: file,
                    comment: existingComment,
                    viewTransform: existingViewTransform
                };
            } else {
                photos.push({
                    name: file.name,
                    src: imageSrc,
                    gps: gpsData,
                    file: file
                });
            }
        }

        async function createImagePreview(file) {
            const isHEIC = file.type === 'image/heic' || file.type === 'image/heif' || 
                          file.name.toLowerCase().endsWith('.heic') || file.name.toLowerCase().endsWith('.heif');
            
            if (isHEIC) {
                try {
                    // Try to create an image bitmap from the HEIC file
                    const bitmap = await createImageBitmap(file);
                    
                    // Create a canvas and convert to JPEG
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set canvas dimensions to match image
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    
                    // Draw the image
                    ctx.drawImage(bitmap, 0, 0);
                    
                    // Convert canvas to JPEG blob
                    return new Promise((resolve, reject) => {
                        canvas.toBlob((blob) => {
                            if (blob) {
                                resolve(URL.createObjectURL(blob));
                            } else {
                                reject(new Error('Failed to convert to JPEG'));
                            }
                        }, 'image/jpeg', 0.92);
                    });
                } catch (error) {
                    console.log('Browser cannot decode HEIC - skipping preview');
                    // Return null to indicate no preview available
                    return null;
                }
            } else {
                // For JPEG/JPG, use file directly
                return URL.createObjectURL(file);
            }
        }

        async function extractGPSData(file) {
            try {
                // Read file as ArrayBuffer for ExifReader
                const arrayBuffer = await file.arrayBuffer();
                
                // Parse EXIF data using ExifReader
                const tags = ExifReader.load(arrayBuffer, {expanded: true});

                // Check for GPS data in various possible locations
                let latitude, longitude, altitude, dateTime;

                // Try to get GPS coordinates
                if (tags.gps) {
                    latitude = tags.gps.Latitude;
                    longitude = tags.gps.Longitude;
                    altitude = tags.gps.Altitude;
                } 
                
                // Fallback to checking individual GPS tags
                if (!latitude && tags.GPSLatitude) {
                    latitude = convertGPSToDecimal(tags.GPSLatitude.description || tags.GPSLatitude.value);
                }
                if (!longitude && tags.GPSLongitude) {
                    longitude = convertGPSToDecimal(tags.GPSLongitude.description || tags.GPSLongitude.value);
                }
                if (!altitude && tags.GPSAltitude) {
                    altitude = tags.GPSAltitude.value || tags.GPSAltitude.description;
                }
                // Try to get date/time
                if (tags.exif && tags.exif.DateTimeOriginal) {
                    dateTime = tags.exif.DateTimeOriginal.description || tags.exif.DateTimeOriginal.value;
                } else if (tags.DateTime) {
                    dateTime = tags.DateTime.description || tags.DateTime.value;
                }

                // If no GPS data found, still return date/time if available
                if (!latitude || !longitude) {
                    console.log('No GPS data found in file');
                    
                    // Still extract date/time for non-GPS photos
                    if (dateTime) {
                        const dateTimeStr = dateTime.toString();
                        let dateTimeObj = null;
                        const dtStr = dateTimeStr.replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
                        dateTimeObj = new Date(dtStr);
                        if (isNaN(dateTimeObj.getTime())) {
                            dateTimeObj = null;
                        }
                        return {
                            latitude: null,
                            longitude: null,
                            altitude: null,
                            dateTime: dateTimeStr,
                            dateTimeObj: dateTimeObj,
                            latDMS: null,
                            lonDMS: null,
                            hasGPS: false
                        };
                    }
                    return null;
                }

                // Format altitude
                const altitudeStr = altitude ? `${parseFloat(altitude).toFixed(1)} m` : 'N/A';
                const dateTimeStr = dateTime || 'N/A';
                
                // Parse datetime string to Date object for sorting
                let dateTimeObj = null;
                if (dateTime) {
                    // EXIF datetime format is typically "YYYY:MM:DD HH:MM:SS"
                    const dtStr = dateTime.toString().replace(/^(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
                    dateTimeObj = new Date(dtStr);
                    
                    // If parsing failed, try alternative formats
                    if (isNaN(dateTimeObj.getTime())) {
                        dateTimeObj = null;
                    }
                }

                // Convert to DMS format for display
                const latDMS = convertDDToDMS(latitude, latitude >= 0 ? 'N' : 'S');
                const lonDMS = convertDDToDMS(longitude, longitude >= 0 ? 'E' : 'W');


                return {
                    latitude,
                    longitude,
                    altitude: altitudeStr,
                    dateTime: dateTimeStr,
                    dateTimeObj: dateTimeObj,
                    latDMS,
                    lonDMS,
                    hasGPS: true
                };
            } catch (error) {
                console.error('Error extracting GPS data:', error);
                return null;
            }
        }

        function convertGPSToDecimal(gpsString) {
            // GPS string might be in format like "27¬∞ 32' 43.81"" or already a number
            if (typeof gpsString === 'number') {
                return gpsString;
            }
            
            if (typeof gpsString === 'string') {
                // Try to parse DMS format
                const match = gpsString.match(/(\d+)¬∞\s*(\d+)'\s*([\d.]+)"/);
                if (match) {
                    const degrees = parseFloat(match[1]);
                    const minutes = parseFloat(match[2]);
                    const seconds = parseFloat(match[3]);
                    return degrees + minutes / 60 + seconds / 3600;
                }
                
                // If it's just a decimal number as string
                const parsed = parseFloat(gpsString);
                if (!isNaN(parsed)) {
                    return parsed;
                }
            }
            
            return null;
        }

        function convertDDToDMS(dd, direction) {
            const absolute = Math.abs(dd);
            const degrees = Math.floor(absolute);
            const minutesDecimal = (absolute - degrees) * 60;
            const minutes = Math.floor(minutesDecimal);
            const seconds = ((minutesDecimal - minutes) * 60).toFixed(2);
            
            return `${degrees}¬∞ ${minutes}' ${seconds}" ${direction}`;
        }

        function formatBrisbaneDate(date) {
            // Format date in Brisbane timezone as "Monday, 3rd January 2026"
            const dateOptions = {
                timeZone: 'Australia/Brisbane',
                weekday: 'long',
                day: 'numeric',
                month: 'long',
                year: 'numeric'
            };
            
            // Get date parts
            const dateFormatter = new Intl.DateTimeFormat('en-AU', dateOptions);
            const parts = dateFormatter.formatToParts(date);
            
            let weekday = '', day = '', month = '', year = '';
            parts.forEach(part => {
                if (part.type === 'weekday') weekday = part.value;
                if (part.type === 'day') day = part.value;
                if (part.type === 'month') month = part.value;
                if (part.type === 'year') year = part.value;
            });
            
            // Add ordinal suffix
            const dayNum = parseInt(day, 10);
            let ordinal = 'th';
            if (dayNum === 1 || dayNum === 21 || dayNum === 31) ordinal = 'st';
            else if (dayNum === 2 || dayNum === 22) ordinal = 'nd';
            else if (dayNum === 3 || dayNum === 23) ordinal = 'rd';
            
            return `${weekday}, ${dayNum}${ordinal} ${month} ${year}`;
        }

        function formatBrisbaneShortDate(date) {
            // Short format for stats bar: "3 Jan 2026"
            return date.toLocaleDateString('en-AU', {
                timeZone: 'Australia/Brisbane',
                day: 'numeric',
                month: 'short',
                year: 'numeric'
            });
        }

        function formatBrisbaneDateTime(date) {
            // Returns separate date and time strings
            return {
                date: formatBrisbaneDate(date),
                time: date.toLocaleTimeString('en-AU', {
                    timeZone: 'Australia/Brisbane',
                    hour: 'numeric',
                    minute: '2-digit',
                    hour12: true
                })
            };
        }

        // Lightbox functions
        function openLightbox(index) {
            if (index < 0 || index >= photos.length) return;
            lightboxIndex = index;
            updateLightbox();
            lightbox.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
        
        function closeLightbox() {
            lightbox.classList.remove('active');
            document.body.style.overflow = '';
        }
        
        function updateLightbox() {
            const photo = photos[lightboxIndex];
            lightboxImg.src = photo.src;
            
            // Build caption with name, date/time, and GPS
            let caption = photo.name;
            if (photo.gps && photo.gps.dateTimeObj) {
                const dt = formatBrisbaneDateTime(photo.gps.dateTimeObj);
                caption += ` ‚Ä¢ ${dt.date} ${dt.time}`;
            }
            if (photo.gps && photo.gps.hasGPS) {
                caption += ` ‚Ä¢ ${photo.gps.latDMS}, ${photo.gps.lonDMS}`;
            }
            lightboxCaption.textContent = caption;
            
            lightboxCounter.textContent = `${lightboxIndex + 1} / ${photos.length}`;
            
            // Update nav button states
            lightboxPrev.disabled = lightboxIndex === 0;
            lightboxNext.disabled = lightboxIndex === photos.length - 1;
        }
        
        function lightboxPrevPhoto() {
            if (lightboxIndex > 0) {
                lightboxIndex--;
                updateLightbox();
            }
        }
        
        function lightboxNextPhoto() {
            if (lightboxIndex < photos.length - 1) {
                lightboxIndex++;
                updateLightbox();
            }
        }
        
        // Lightbox event listeners
        lightboxClose.addEventListener('click', closeLightbox);
        lightboxPrev.addEventListener('click', lightboxPrevPhoto);
        lightboxNext.addEventListener('click', lightboxNextPhoto);
        
        lightbox.addEventListener('click', (e) => {
            // Close if clicking the background (not the image or buttons)
            if (e.target === lightbox) {
                closeLightbox();
            }
        });
        
        document.addEventListener('keydown', (e) => {
            if (!lightbox.classList.contains('active')) return;
            
            switch(e.key) {
                case 'Escape':
                    closeLightbox();
                    break;
                case 'ArrowLeft':
                    lightboxPrevPhoto();
                    break;
                case 'ArrowRight':
                    lightboxNextPhoto();
                    break;
            }
        });

        function updateStats() {
            const photoCount = photos.length;
            const gpsCount = photos.filter(p => p.gps && p.gps.hasGPS).length;

            document.getElementById('photoCount').textContent = photoCount;
            document.getElementById('gpsCount').textContent = gpsCount;

            if (photoCount > 0) {
                stats.style.display = 'inline-block';
                
                // Calculate and display date range
                const photosWithDates = photos.filter(p => p.gps && p.gps.dateTimeObj);
                if (photosWithDates.length > 0) {
                    const dates = photosWithDates.map(p => p.gps.dateTimeObj);
                    const minDate = new Date(Math.min(...dates));
                    const maxDate = new Date(Math.max(...dates));
                    
                    const dateRangeEl = document.getElementById('dateRange');
                    const dateRangeStats = document.getElementById('dateRangeStats');
                    
                    if (minDate.toDateString() === maxDate.toDateString()) {
                        // Single date - short format for stats bar
                        dateRangeEl.textContent = formatBrisbaneShortDate(minDate);
                    } else {
                        // Date range
                        dateRangeEl.textContent = `${formatBrisbaneShortDate(minDate)} ‚Äì ${formatBrisbaneShortDate(maxDate)}`;
                    }
                    dateRangeStats.style.display = 'inline';
                }
            }

            if (routes.length > 0) {
                document.getElementById('routeStats').style.display = 'inline';
                document.getElementById('routeCount').textContent = routes.length;
            }

            // Enable map if we have GPS photos OR routes
            showMapButton.disabled = (gpsCount === 0 && routes.length === 0);
            showGalleryButton.disabled = gpsCount === 0;
            clearButton.disabled = (photos.length === 0 && routes.length === 0);
        }
        
        function deletePhoto(index) {
            if (index < 0 || index >= photos.length) return;
            
            // Revoke object URL to free memory
            if (photos[index].src) {
                URL.revokeObjectURL(photos[index].src);
            }
            
            // Remove the photo
            photos.splice(index, 1);
            
            // Re-index saved transforms (shift down indices above deleted)
            const newTransforms = {};
            Object.keys(photoMarkerTransforms).forEach(key => {
                const oldIndex = parseInt(key);
                if (oldIndex < index) {
                    newTransforms[oldIndex] = photoMarkerTransforms[key];
                } else if (oldIndex > index) {
                    newTransforms[oldIndex - 1] = photoMarkerTransforms[key];
                }
                // Skip the deleted index
            });
            photoMarkerTransforms = newTransforms;
            
            // Re-render
            renderPhotos();
            updateStats();
            
            // Update map if open
            if (mapModal.classList.contains('active')) {
                if (is3DMode && map3d) {
                    // Clear active photo marker if it was the deleted photo
                    if (activePhotoMarker3d) {
                        activePhotoMarker3d.remove();
                        activePhotoMarker3d = null;
                        activePhotoMarker3dData = null;
                    }
                    add3DMarkers();
                } else if (map) {
                    if (photoMarkersMode) {
                        showPhotoMarkers();
                    } else {
                        showNumberMarkers();
                    }
                }
            }
        }
        
        function copyGPS(index) {
            if (index < 0 || index >= photos.length) return;
            const photo = photos[index];
            if (!photo.gps || !photo.gps.hasGPS) return;
            
            copiedGPS = {
                latitude: photo.gps.latitude,
                longitude: photo.gps.longitude,
                altitude: photo.gps.altitude,
                dateTimeObj: photo.gps.dateTimeObj,
                dateTime: photo.gps.dateTime
            };
            
            // Update all paste buttons to be enabled
            document.querySelectorAll('.gps-btn-paste').forEach(btn => {
                btn.disabled = false;
            });
            
            // Show feedback
            const toast = document.createElement('div');
            toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:white;padding:10px 20px;border-radius:8px;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
            toast.textContent = `GPS + Date/Time copied from ${photo.name}`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
            
        }
        
        function pasteGPS(index) {
            if (index < 0 || index >= photos.length || !copiedGPS) return;
            
            const photo = photos[index];
            if (!photo.gps) {
                photo.gps = {};
            }
            
            photo.gps.latitude = copiedGPS.latitude;
            photo.gps.longitude = copiedGPS.longitude;
            photo.gps.altitude = copiedGPS.altitude;
            photo.gps.latDMS = convertDDToDMS(copiedGPS.latitude, copiedGPS.latitude >= 0 ? 'N' : 'S');
            photo.gps.lonDMS = convertDDToDMS(copiedGPS.longitude, copiedGPS.longitude >= 0 ? 'E' : 'W');
            photo.gps.hasGPS = true;
            
            // Also paste date/time if available
            if (copiedGPS.dateTimeObj) {
                photo.gps.dateTimeObj = copiedGPS.dateTimeObj;
                photo.gps.dateTime = copiedGPS.dateTime;
            }
            
            // Mark this photo as having unsaved edits
            photosWithUnsavedEdits.add(photo.name);
            
            // Highlight this specific photo after re-sort
            highlightedPhotoName = photo.name;
            
            // Re-sort photos chronologically after date/time change
            photos.sort((a, b) => {
                if (!a.gps || !a.gps.dateTimeObj) return 1;
                if (!b.gps || !b.gps.dateTimeObj) return -1;
                return a.gps.dateTimeObj - b.gps.dateTimeObj;
            });
            
            renderPhotos();
            updateStats();
            
            // Clear highlight after animation
            setTimeout(() => {
                highlightedPhotoName = null;
            }, 1500);
            
            // Update map if open
            if (map && mapModal.classList.contains('active')) {
                if (photoMarkersMode) {
                    showPhotoMarkers();
                } else {
                    showNumberMarkers();
                }
            }
            
            // Show feedback
            const toast = document.createElement('div');
            toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:white;padding:10px 20px;border-radius:8px;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
            toast.textContent = `GPS + Date/Time pasted to ${photo.name}`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
            
        }
        
        function parseDMSToDecimal(dmsStr) {
            // Parse DMS format like "27¬∞ 28' 0.00" S" or "153¬∞ 1' 30.00" E"
            // Also handle incomplete formats like "27¬∞ 32' 43.24" (missing direction and/or closing quote)
            if (!dmsStr || typeof dmsStr !== 'string') return null;
            
            dmsStr = dmsStr.trim();
            
            // Normalize quote characters (handle ", ", ‚Ä≥, etc.)
            dmsStr = dmsStr.replace(/[""‚Ä≥]/g, '"').replace(/[''‚Ä≤]/g, "'");
            
            // Try full format with direction: 27¬∞ 28' 0.00" S
            let match = dmsStr.match(/(\d+)¬∞\s*(\d+)[''‚Ä≤]?\s*([\d.]+)[""‚Ä≥]?\s*([NSEW])/i);
            if (match) {
                const degrees = parseFloat(match[1]);
                const minutes = parseFloat(match[2]);
                const seconds = parseFloat(match[3]);
                const direction = match[4].toUpperCase();
                
                let decimal = degrees + minutes / 60 + seconds / 3600;
                if (direction === 'S' || direction === 'W') {
                    decimal = -decimal;
                }
                return decimal;
            }
            
            // Try format without direction: 27¬∞ 32' 43.24 or 27¬∞ 32' 43.24"
            match = dmsStr.match(/(\d+)¬∞\s*(\d+)[''‚Ä≤]?\s*([\d.]+)[""‚Ä≥]?/);
            if (match) {
                const degrees = parseFloat(match[1]);
                const minutes = parseFloat(match[2]);
                const seconds = parseFloat(match[3]);
                
                let decimal = degrees + minutes / 60 + seconds / 3600;
                return decimal; // Return positive, caller will handle sign
            }
            
            // Try parsing as plain decimal number
            const num = parseFloat(dmsStr);
            if (!isNaN(num)) {
                return num;
            }
            
            console.log('Failed to parse DMS:', dmsStr);
            return null;
        }
        
        function degToDmsRational(deg) {
            const d = Math.floor(deg);
            const minFloat = (deg - d) * 60;
            const m = Math.floor(minFloat);
            const secFloat = (minFloat - m) * 60;
            const s = Math.round(secFloat * 100);
            
            return [[d, 1], [m, 1], [s, 100]];
        }
        
        function saveGPSFromInputs(index) {
            if (index < 0 || index >= photos.length) {
                return;
            }
            
            const photo = photos[index];
            const latInput = document.querySelector(`.gps-input[data-field="lat"][data-index="${index}"]`);
            const lngInput = document.querySelector(`.gps-input[data-field="lng"][data-index="${index}"]`);
            const altInput = document.querySelector(`.gps-input[data-field="alt"][data-index="${index}"]`);
            const dateInput = document.querySelector(`.gps-input[data-field="date"][data-index="${index}"]`);
            const timeInput = document.querySelector(`.gps-input[data-field="time"][data-index="${index}"]`);
            
            if (!latInput || !lngInput) {
                return;
            }
            
            // Parse DMS format to decimal
            let lat = parseDMSToDecimal(latInput.value);
            let lng = parseDMSToDecimal(lngInput.value);
            const alt = altInput.value.trim();
            
            // If direction not specified in DMS, infer from existing photo data or Brisbane defaults
            if (lat !== null && !(/[NS]/i.test(latInput.value))) {
                // If photo already has GPS, match its sign; otherwise assume South for Brisbane
                if (photo.gps && photo.gps.latitude < 0) {
                    lat = -Math.abs(lat);
                } else if (!photo.gps || !photo.gps.latitude) {
                    // Default to South (Brisbane area)
                    lat = -Math.abs(lat);
                }
            }
            
            if (lng !== null && !(/[EW]/i.test(lngInput.value))) {
                // If photo already has GPS, match its sign; otherwise assume East for Brisbane
                if (photo.gps && photo.gps.longitude > 0) {
                    lng = Math.abs(lng);
                } else if (!photo.gps || !photo.gps.longitude) {
                    // Default to East (Brisbane area)
                    lng = Math.abs(lng);
                }
            }
            
            if (lat === null || lng === null) {
                alert('Please enter valid coordinates in DMS format\nExample: 27¬∞ 28\' 0.00" S');
                return;
            }
            
            if (lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                alert('Latitude must be -90 to 90, Longitude must be -180 to 180');
                return;
            }
            
            // Parse date and time
            let dateTimeObj = null;
            const dateStr = dateInput ? dateInput.value.trim() : '';
            const timeStr = timeInput ? timeInput.value.trim() : '';
            
            if (dateStr && timeStr) {
                // Parse DD/MM/YYYY format
                const dateParts = dateStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                const timeParts = timeStr.match(/(\d{1,2}):(\d{2}):?(\d{2})?/);
                
                if (dateParts && timeParts) {
                    const day = parseInt(dateParts[1]);
                    const month = parseInt(dateParts[2]) - 1;
                    const year = parseInt(dateParts[3]);
                    const hours = parseInt(timeParts[1]);
                    const minutes = parseInt(timeParts[2]);
                    const seconds = parseInt(timeParts[3] || '0');
                    
                    dateTimeObj = new Date(year, month, day, hours, minutes, seconds);
                }
            }
            
            // Update in-memory data
            if (!photo.gps) {
                photo.gps = {
                    dateTime: 'N/A',
                    dateTimeObj: null
                };
            }
            
            photo.gps.latitude = lat;
            photo.gps.longitude = lng;
            photo.gps.altitude = alt || 'N/A';
            photo.gps.latDMS = convertDDToDMS(lat, lat >= 0 ? 'N' : 'S');
            photo.gps.lonDMS = convertDDToDMS(lng, lng >= 0 ? 'E' : 'W');
            photo.gps.hasGPS = true;
            
            if (dateTimeObj && !isNaN(dateTimeObj.getTime())) {
                photo.gps.dateTimeObj = dateTimeObj;
                photo.gps.dateTime = dateTimeObj.toLocaleString('en-AU', { 
                    timeZone: 'Australia/Brisbane',
                    year: 'numeric', month: '2-digit', day: '2-digit',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
            }
            
            // Save to file with EXIF
            const img = new Image();
            // Don't set crossOrigin for blob URLs (same-origin already)
            if (!photo.src.startsWith('blob:')) {
                img.crossOrigin = 'anonymous';
            }
            
            img.onload = function() {
                const canvas = document.createElement('canvas');
                canvas.width = img.naturalWidth;
                canvas.height = img.naturalHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0);
                
                // Get as JPEG data URL
                const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
                
                try {
                    // Check if piexif is available
                    if (typeof piexif === 'undefined') {
                        throw new Error('piexifjs library not loaded');
                    }
                    
                    // Create new EXIF object
                    let exifObj = {"0th":{}, "Exif":{}, "GPS":{}, "1st":{}, "thumbnail": null};
                    
                    // Set GPS data
                    exifObj.GPS[piexif.GPSIFD.GPSLatitudeRef] = lat >= 0 ? 'N' : 'S';
                    exifObj.GPS[piexif.GPSIFD.GPSLatitude] = degToDmsRational(Math.abs(lat));
                    exifObj.GPS[piexif.GPSIFD.GPSLongitudeRef] = lng >= 0 ? 'E' : 'W';
                    exifObj.GPS[piexif.GPSIFD.GPSLongitude] = degToDmsRational(Math.abs(lng));
                    
                    // Set altitude if available
                    if (alt && alt !== 'N/A') {
                        const altNum = parseFloat(alt);
                        if (!isNaN(altNum)) {
                            exifObj.GPS[piexif.GPSIFD.GPSAltitudeRef] = altNum >= 0 ? 0 : 1;
                            exifObj.GPS[piexif.GPSIFD.GPSAltitude] = [Math.abs(Math.round(altNum * 100)), 100];
                        }
                    }
                    
                    // Set date/time from edited values
                    const dtToSave = dateTimeObj || photo.gps.dateTimeObj;
                    if (dtToSave) {
                        const exifDateStr = dtToSave.getFullYear() + ':' +
                            String(dtToSave.getMonth() + 1).padStart(2, '0') + ':' +
                            String(dtToSave.getDate()).padStart(2, '0') + ' ' +
                            String(dtToSave.getHours()).padStart(2, '0') + ':' +
                            String(dtToSave.getMinutes()).padStart(2, '0') + ':' +
                            String(dtToSave.getSeconds()).padStart(2, '0');
                        exifObj.Exif[piexif.ExifIFD.DateTimeOriginal] = exifDateStr;
                        exifObj.Exif[piexif.ExifIFD.DateTimeDigitized] = exifDateStr;
                        exifObj["0th"][piexif.ImageIFD.DateTime] = exifDateStr;
                    }
                    
                    // Insert EXIF into image
                    const exifBytes = piexif.dump(exifObj);
                    const newDataUrl = piexif.insert(exifBytes, dataUrl);
                    
                    // Download the file
                    const link = document.createElement('a');
                    link.href = newDataUrl;
                    const baseName = photo.name.replace(/\.[^.]+$/, '');
                    link.download = baseName + '_gps.jpg';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Clear unsaved edits for this photo (it's been saved)
                    photosWithUnsavedEdits.delete(photo.name);
                    
                    // Highlight this specific photo after re-sort
                    highlightedPhotoName = photo.name;
                    
                    // Re-sort photos chronologically after date/time edit
                    photos.sort((a, b) => {
                        if (!a.gps || !a.gps.dateTimeObj) return 1;
                        if (!b.gps || !b.gps.dateTimeObj) return -1;
                        return a.gps.dateTimeObj - b.gps.dateTimeObj;
                    });
                    
                    // Update display
                    renderPhotos();
                    updateStats();
                    
                    // Clear highlight after animation
                    setTimeout(() => {
                        highlightedPhotoName = null;
                    }, 1500);
                    
                    // Update map if open
                    if (map && mapModal.classList.contains('active')) {
                        if (photoMarkersMode) {
                            showPhotoMarkers();
                        } else {
                            showNumberMarkers();
                        }
                    }
                    
                    // Show feedback
                    const toast = document.createElement('div');
                    toast.style.cssText = 'position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:#333;color:white;padding:10px 20px;border-radius:8px;z-index:10000;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
                    toast.textContent = `Saved ${baseName}_gps.jpg with metadata`;
                    document.body.appendChild(toast);
                    setTimeout(() => toast.remove(), 3000);
                    
                } catch (exifError) {
                    console.error('EXIF error:', exifError);
                    alert('Error saving EXIF data: ' + exifError.message);
                }
            };
            
            img.onerror = function(e) {
                console.error('Error loading image for processing:', e);
                alert('Error loading image for processing');
            };
            
            img.src = photo.src;
        }
        
        function renderPhotos() {
            photosGrid.innerHTML = '';

            photos.forEach((photo, index) => {
                const card = document.createElement('div');
                card.className = 'photo-card';
                
                // Add highlight class if this photo was just edited
                if (highlightedPhotoName === photo.name) {
                    card.classList.add('highlight-moved');
                }

                // Only add image if preview is available
                if (photo.src) {
                    const container = document.createElement('div');
                    container.className = 'photo-preview-container';
                    
                    const img = document.createElement('img');
                    img.className = 'photo-preview-draggable';
                    img.src = photo.src;
                    img.alt = photo.name;
                    
                    // State for this image
                    let containerWidth = 0;  // set after element is in DOM
                    let containerHeight = 0; // set after element is in DOM
                    
                    function readContainerSize() {
                        const r = container.getBoundingClientRect();
                        containerWidth = Math.max(1, Math.round(r.width));
                        containerHeight = Math.max(1, Math.round(r.height));
                    }

                    let imgWidth = 0;
                    let imgHeight = 0;
                    let baseScale = 1;
                    let minScale = 0.1;

                    let scale = 1;
                    let posX = 0;
                    let posY = 0;
                    let isDragging = false;
                    let startX, startY, initialX, initialY;
                    
                    // Wait for image to load to get dimensions
                    img.onload = function() {
                        imgWidth = img.naturalWidth;
                        imgHeight = img.naturalHeight;
                        
                        readContainerSize();
                        // Determine if image is portrait or landscape
                        const isPortrait = imgHeight > imgWidth;

                        if (isPortrait) {
                            // Portrait: fit to width (fills the tile width; crop vertically)
                            baseScale = containerWidth / imgWidth;
                        } else {
                            // Landscape: cover (fills the tile; crop horizontally if needed)
                            const scaleX = containerWidth / imgWidth;
                            const scaleY = containerHeight / imgHeight;
                            baseScale = Math.max(scaleX, scaleY);
                        }

                        scale = baseScale;
                        minScale = baseScale; // never allow zooming out to reveal background

                        // Centre the image within the 4:3 tile
                        const scaledW = imgWidth * scale;
                        const scaledH = imgHeight * scale;
                        posX = (containerWidth - scaledW) / 2;
                        posY = (containerHeight - scaledH) / 2;

                        // Apply initial transform
                        updateTransform();};
                    
                    function updateTransform() {
                        // Clamp pan so the image always covers the tile (no background showing)
                        const scaledW = imgWidth * scale;
                        const scaledH = imgHeight * scale;

                        if (scaledW > containerWidth) {
                            const minX = containerWidth - scaledW;
                            posX = Math.min(0, Math.max(minX, posX));
                        } else {
                            posX = (containerWidth - scaledW) / 2;
                        }

                        if (scaledH > containerHeight) {
                            const minY = containerHeight - scaledH;
                            posY = Math.min(0, Math.max(minY, posY));
                        } else {
                            posY = (containerHeight - scaledH) / 2;
                        }

                        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                        img.style.transformOrigin = 'top left';
                        // Persist the current view so the Gallery can mirror the same zoom + offsets
                        photo.viewTransform = { scale, posX, posY };
                    }
                    
                    // Keep tiles correct if the container size changes (responsive layout)
                    const ro = new ResizeObserver(() => {
                        if (!imgWidth || !imgHeight) return;
                        readContainerSize();
                        const isPortrait = imgHeight > imgWidth;

                        if (isPortrait) {
                            baseScale = containerWidth / imgWidth;
                        } else {
                            const scaleX = containerWidth / imgWidth;
                            const scaleY = containerHeight / imgHeight;
                            baseScale = Math.max(scaleX, scaleY);
                        }

                        // Never allow a scale that reveals background
                        minScale = baseScale;
                        if (scale < minScale) scale = minScale;

                        updateTransform();
                    });
                    ro.observe(container);

                    // Mouse drag
                    img.addEventListener('mousedown', (e) => {
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        initialX = posX;
                        initialY = posY;
                        e.preventDefault();
                    });
                    
                    // Double-click to open lightbox
                    container.addEventListener('dblclick', (e) => {
                        e.stopPropagation();
                        openLightbox(index);
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        updateTransform();
                    });
                    
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                    });
                    
                    // Mouse wheel zoom - zoom from center of container
                    container.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? -0.05 : 0.05;
                        const oldScale = scale;
                        scale = Math.max(minScale, Math.min(5, scale + delta));

                        // Adjust position to zoom from center of container
                        const containerRect = container.getBoundingClientRect();
                        const centerX = containerRect.width / 2;
                        const centerY = containerRect.height / 2;

                        // Calculate the point in image space that's at the center
                        const imgCenterX = (centerX - posX) / oldScale;
                        const imgCenterY = (centerY - posY) / oldScale;

                        // Adjust position so that same image point stays at center
                        posX = centerX - imgCenterX * scale;
                        posY = centerY - imgCenterY * scale;

                        updateTransform();
                    }, { passive: false });
                    
                    // Touch support (passive: false because we use preventDefault)
                    img.addEventListener('touchstart', (e) => {
                        isDragging = true;
                        const touch = e.touches[0];
                        startX = touch.clientX;
                        startY = touch.clientY;
                        initialX = posX;
                        initialY = posY;
                        e.preventDefault();
                    }, { passive: false });
                    
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging || e.touches.length === 0) return;
                        const touch = e.touches[0];
                        const dx = touch.clientX - startX;
                        const dy = touch.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        updateTransform();
                    }, { passive: true });
                    
                    document.addEventListener('touchend', () => {
                        isDragging = false;
                    }, { passive: true });
                    
                    // Reset button
                    const resetBtn = document.createElement('button');
                    resetBtn.className = 'reset-pan';
                    resetBtn.textContent = '‚Ü∫ Reset';
                    resetBtn.onclick = () => {
                        posX = 0;
                        posY = 0;
                        // Recalculate initial scale
                        if (img.naturalWidth && img.naturalHeight) {
                            let containerWidth = 0;  // set after element is in DOM
                    let containerHeight = 0; // set after element is in DOM
                    
                    function readContainerSize() {
                        const r = container.getBoundingClientRect();
                        containerWidth = Math.max(1, Math.round(r.width));
                        containerHeight = Math.max(1, Math.round(r.height));
                    }

                            const imgWidth = img.naturalWidth;
                            const imgHeight = img.naturalHeight;
                        readContainerSize();
                            const isPortrait = imgHeight > imgWidth;
                            
                            if (isPortrait) {
                                scale = containerWidth / imgWidth;
                            } else {
                                const scaleX = containerWidth / imgWidth;
                                const scaleY = containerHeight / imgHeight;
                                scale = Math.max(scaleX, scaleY);
                            }
                        } else {
                            scale = 1;
                        }
                        updateTransform();
                    };
                    
                    // Zoom controls
                    const zoomControls = document.createElement('div');
                    zoomControls.className = 'zoom-controls';
                    
                    const zoomIn = document.createElement('button');
                    zoomIn.className = 'zoom-btn';
                    zoomIn.textContent = '+';
                    zoomIn.onclick = () => {
                        scale = Math.min(5, scale + 0.1);
                        updateTransform();
                    };
                    
                    const zoomOut = document.createElement('button');
                    zoomOut.className = 'zoom-btn';
                    zoomOut.textContent = '‚àí';
                    zoomOut.onclick = () => {
                        scale = Math.max(minScale, scale - 0.1);
                        updateTransform();
                    };
                    
                    zoomControls.appendChild(zoomOut);
                    zoomControls.appendChild(zoomIn);
                    
                    container.appendChild(img);
                    container.appendChild(resetBtn);
                    container.appendChild(zoomControls);
                    card.appendChild(container);
                }

                const info = document.createElement('div');
                info.className = 'photo-info';

                const name = document.createElement('div');
                name.className = 'photo-name';
                name.textContent = `${index + 1}. ${photo.name}`;

                const locationData = document.createElement('div');
                locationData.className = 'location-data';

                // Create editable GPS inputs with DMS format
                const hasGPS = photo.gps && photo.gps.hasGPS;
                const latDMS = hasGPS ? photo.gps.latDMS : '';
                const lngDMS = hasGPS ? photo.gps.lonDMS : '';
                const alt = hasGPS ? photo.gps.altitude : '';
                
                // Escape double quotes for HTML attributes
                const escapeHtml = (str) => str ? str.replace(/"/g, '&quot;') : '';
                
                // Date/time display (from GPS or file metadata)
                const dateTime = photo.gps && photo.gps.dateTimeObj ? formatBrisbaneDateTime(photo.gps.dateTimeObj) : null;
                
                locationData.innerHTML = `
                    <div class="gps-input-row">
                        <label>Latitude:</label>
                        <input type="text" class="gps-input" data-field="lat" data-index="${index}" value="${escapeHtml(latDMS)}" placeholder="27¬∞ 28' 0.00&quot; S">
                    </div>
                    <div class="gps-input-row">
                        <label>Longitude:</label>
                        <input type="text" class="gps-input" data-field="lng" data-index="${index}" value="${escapeHtml(lngDMS)}" placeholder="153¬∞ 1' 30.00&quot; E">
                    </div>
                    <div class="gps-input-row">
                        <label>Altitude:</label>
                        <input type="text" class="gps-input" data-field="alt" data-index="${index}" value="${escapeHtml(alt) || ''}" placeholder="0 m">
                    </div>
                    <div class="gps-input-row">
                        <label>Date:</label>
                        <input type="text" class="gps-input" data-field="date" data-index="${index}" value="${dateTime ? dateTime.date : ''}" placeholder="08/01/2026">
                    </div>
                    <div class="gps-input-row">
                        <label>Time:</label>
                        <input type="text" class="gps-input" data-field="time" data-index="${index}" value="${dateTime ? dateTime.time : ''}" placeholder="10:30:00">
                    </div>
                    ${photo.comment ? `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;"><strong>üí¨</strong> ${photo.comment}</div>` : ''}
                `;
                
                // Create buttons programmatically for reliable event handling
                const buttonRow = document.createElement('div');
                buttonRow.className = 'gps-buttons';
                
                if (hasGPS) {
                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'gps-btn';
                    copyBtn.textContent = 'Copy';
                    copyBtn.addEventListener('click', () => copyGPS(index));
                    buttonRow.appendChild(copyBtn);
                }
                
                const pasteBtn = document.createElement('button');
                pasteBtn.className = 'gps-btn';
                pasteBtn.textContent = 'Paste';
                pasteBtn.disabled = !copiedGPS;
                pasteBtn.classList.add('gps-btn-paste');
                pasteBtn.addEventListener('click', () => pasteGPS(index));
                buttonRow.appendChild(pasteBtn);
                
                const saveBtn = document.createElement('button');
                saveBtn.className = 'gps-btn gps-btn-save';
                saveBtn.textContent = 'Save to File';
                // Enable if this photo has unsaved edits
                saveBtn.disabled = !photosWithUnsavedEdits.has(photo.name);
                saveBtn.addEventListener('click', () => {
                    saveGPSFromInputs(index);
                });
                buttonRow.appendChild(saveBtn);
                
                // Insert buttons after the time input row
                const lastInputRow = locationData.querySelector('.gps-input-row:last-of-type');
                if (lastInputRow) {
                    lastInputRow.after(buttonRow);
                } else {
                    locationData.appendChild(buttonRow);
                }
                
                // Add input listeners to enable Save button when any field is edited
                const allInputs = locationData.querySelectorAll('.gps-input');
                allInputs.forEach(input => {
                    input.addEventListener('input', () => {
                        saveBtn.disabled = false;
                        photosWithUnsavedEdits.add(photo.name);
                    });
                });
                
                // Add change listeners for date/time fields to update and re-sort
                const dateInput = locationData.querySelector('.gps-input[data-field="date"]');
                const timeInput = locationData.querySelector('.gps-input[data-field="time"]');
                
                const updateDateTime = () => {
                    const dateStr = dateInput ? dateInput.value.trim() : '';
                    const timeStr = timeInput ? timeInput.value.trim() : '';
                    
                    if (dateStr && timeStr) {
                        const dateParts = dateStr.match(/(\d{1,2})\/(\d{1,2})\/(\d{4})/);
                        const timeParts = timeStr.match(/(\d{1,2}):(\d{2}):?(\d{2})?/);
                        
                        if (dateParts && timeParts) {
                            const day = parseInt(dateParts[1]);
                            const month = parseInt(dateParts[2]) - 1;
                            const year = parseInt(dateParts[3]);
                            const hours = parseInt(timeParts[1]);
                            const minutes = parseInt(timeParts[2]);
                            const seconds = parseInt(timeParts[3] || '0');
                            
                            const newDateTime = new Date(year, month, day, hours, minutes, seconds);
                            
                            if (!isNaN(newDateTime.getTime())) {
                                if (!photo.gps) photo.gps = {};
                                photo.gps.dateTimeObj = newDateTime;
                                photo.gps.dateTime = newDateTime.toLocaleString('en-AU', { 
                                    timeZone: 'Australia/Brisbane',
                                    year: 'numeric', month: '2-digit', day: '2-digit',
                                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                                });
                                
                                // Mark as having unsaved edits and highlight this photo
                                photosWithUnsavedEdits.add(photo.name);
                                highlightedPhotoName = photo.name;
                                
                                // Re-sort chronologically
                                photos.sort((a, b) => {
                                    if (!a.gps || !a.gps.dateTimeObj) return 1;
                                    if (!b.gps || !b.gps.dateTimeObj) return -1;
                                    return a.gps.dateTimeObj - b.gps.dateTimeObj;
                                });
                                
                                renderPhotos();
                                updateStats();
                                
                                // Clear highlight after animation
                                setTimeout(() => {
                                    highlightedPhotoName = null;
                                }, 1500);
                                
                            }
                        }
                    }
                };
                
                if (dateInput) dateInput.addEventListener('change', updateDateTime);
                if (timeInput) timeInput.addEventListener('change', updateDateTime);

                info.appendChild(name);
                info.appendChild(locationData);
                card.appendChild(info);
                
                // Delete button - added last to render on top
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'photo-delete-btn';
                deleteBtn.textContent = '√ó';
                deleteBtn.title = 'Delete photo';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deletePhoto(index);
                });
                card.appendChild(deleteBtn);
                
                photosGrid.appendChild(card);
            });
        }

        const mapStyles = {
            osm: {
                name: 'Street Map',
                url: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
                attribution: '¬© OpenStreetMap contributors'
            },
            satellite: {
                name: 'Satellite',
                url: 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
                attribution: 'Tiles ¬© Esri'
            },
            cycle: {
                name: 'Cycle Map',
                url: 'https://{s}.tile-cyclosm.openstreetmap.fr/cyclosm/{z}/{x}/{y}.png',
                attribution: '¬© OpenStreetMap contributors, CyclOSM'
            },
            humanitarian: {
                name: 'Humanitarian',
                url: 'https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png',
                attribution: '¬© OpenStreetMap contributors, Humanitarian OSM'
            },
            'mapbox-streets': {
                name: 'Mapbox Streets',
                url: 'https://api.mapbox.com/styles/v1/mapbox/streets-v12/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            },
            'mapbox-outdoors': {
                name: 'Mapbox Outdoors',
                url: 'https://api.mapbox.com/styles/v1/mapbox/outdoors-v12/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            },
            'mapbox-satellite': {
                name: 'Mapbox Satellite',
                url: 'https://api.mapbox.com/styles/v1/mapbox/satellite-v9/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            },
            'mapbox-satellite-streets': {
                name: 'Mapbox Satellite Streets',
                url: 'https://api.mapbox.com/styles/v1/mapbox/satellite-streets-v12/tiles/{z}/{x}/{y}?access_token={accessToken}',
                attribution: '¬© Mapbox ¬© OpenStreetMap',
                requiresApiKey: true,
                tileSize: 512,
                zoomOffset: -1
            }
        };

        // Arc Timeline color scheme
        const arcColors = {
            arcDarkPurple: '#2D2D73',
            arcPurple: '#7A3CFC',
            arcGreen: '#12A656',
            arcDarkGreen: '#0E8444',
            arcRed: '#E35641',
            arcOrange: '#EB781B',
            arcRuby: '#D85582',
            arcByzantine: '#8B408C',
            arcMagenta: '#8E1DD2',
            arcJade: '#079260',
            arcJungle: '#18A1B1',
            arcYellow: '#EEA10A',
            arcGold: '#AA9131',
            arcBrown: '#B4831D',
            arcDarkBlue: '#26398B',
            arcBlue: '#3B71F6',
            arcLightBlue: '#039FD4',
            arcNavy: '#4056B5',
            arcSapphire: '#4884AE',
            arcAnchor: '#4E5268',
            arcSpaniard: '#2D2F3E'
        };

        function getActivityColor(activityType) {
            const type = activityType.toLowerCase();
            
            switch (type) {
                case 'bogus':
                    return arcColors.arcBrown;
                case 'stationary':
                    return arcColors.arcPurple;
                case 'walking':
                case 'golf':
                case 'wheelchair':
                    return arcColors.arcGreen;
                case 'hiking':
                    return arcColors.arcDarkGreen;
                case 'running':
                    return arcColors.arcOrange;
                case 'cycling':
                case 'rowing':
                case 'swimming':
                case 'kayaking':
                    return arcColors.arcLightBlue;
                case 'car':
                case 'taxi':
                    return arcColors.arcAnchor;
                case 'bus':
                    return arcColors.arcNavy;
                case 'motorcycle':
                case 'scooter':
                    return arcColors.arcRed;
                case 'airplane':
                case 'hotairballoon':
                    return arcColors.arcMagenta;
                case 'boat':
                    return arcColors.arcBlue;
                case 'train':
                case 'metro':
                case 'tram':
                case 'cablecar':
                case 'funicular':
                case 'chairlift':
                case 'skilift':
                    return arcColors.arcGold;
                case 'tractor':
                    return arcColors.arcSpaniard;
                case 'tuktuk':
                case 'songthaew':
                    return arcColors.arcBrown;
                case 'skateboarding':
                    return arcColors.arcJungle;
                case 'inlineskating':
                    return arcColors.arcRuby;
                case 'snowboarding':
                    return arcColors.arcSapphire;
                case 'skiing':
                    return arcColors.arcDarkBlue;
                case 'horseback':
                    return arcColors.arcByzantine;
                case 'surfing':
                    return arcColors.arcRuby;
                case 'unknown':
                default:
                    return '#808080'; // gray
            }
        }

        function changeMapStyle() {
            // Handle 3D mode separately
            if (is3DMode) {
                change3DStyle();
                return;
            }

            if (!map || !currentTileLayer) return;

            const style = mapStyleSelect.value;
            current2DStyle = style;
            const styleConfig = mapStyles[style];

            // Check if Mapbox style requires API key
            if (styleConfig.requiresApiKey) {
                if (!mapboxApiKey) {
                    alert('Please configure your Mapbox API key first by clicking the üîë button.');
                    // Revert to previous selection
                    mapStyleSelect.value = 'humanitarian';
                    return;
                }
            }

            // Remove current tile layer
            map.removeLayer(currentTileLayer);

            // Build tile layer options
            const tileOptions = {
                attribution: styleConfig.attribution,
                maxZoom: 19
            };

            // Add Mapbox-specific options
            if (styleConfig.tileSize) tileOptions.tileSize = styleConfig.tileSize;
            if (styleConfig.zoomOffset) tileOptions.zoomOffset = styleConfig.zoomOffset;

            // Build URL with API key if needed
            let tileUrl = styleConfig.url;
            if (styleConfig.requiresApiKey) {
                tileUrl = tileUrl.replace('{accessToken}', mapboxApiKey);
            }

            // Add new tile layer
            currentTileLayer = L.tileLayer(tileUrl, tileOptions).addTo(map);
        }

        function showMapboxKeyDialog() {
            const dialog = document.getElementById('mapboxKeyDialog');
            const input = document.getElementById('mapboxKeyInput');

            // Pre-fill with current key
            input.value = mapboxApiKey || '';

            // Show dialog
            dialog.style.display = 'flex';
            input.focus();
        }

        function hideMapboxKeyDialog() {
            document.getElementById('mapboxKeyDialog').style.display = 'none';
        }

        function saveMapboxKey() {
            const input = document.getElementById('mapboxKeyInput');
            mapboxApiKey = input.value.trim();

            if (mapboxApiKey) {
                localStorage.setItem('mapboxApiKey', mapboxApiKey);
                document.getElementById('toggle3DBtn').style.display = '';
            } else {
                localStorage.removeItem('mapboxApiKey');
                document.getElementById('toggle3DBtn').style.display = 'none';
            }

            hideMapboxKeyDialog();
        }

        function clearMapboxKey() {
            document.getElementById('mapboxKeyInput').value = '';
            mapboxApiKey = '';
            localStorage.removeItem('mapboxApiKey');
            document.getElementById('toggle3DBtn').style.display = 'none';
            hideMapboxKeyDialog();
        }

        // Store 2D map style options HTML for restoring
        const map2DStyleOptions = `
            <option value="osm">Street Map (Standard navigation)</option>
            <option value="satellite">Satellite (Aerial imagery)</option>
            <option value="cycle">Cycle Map (Bike routes with contours)</option>
            <option value="humanitarian" selected>Humanitarian (Clear, simple)</option>
            <optgroup label="Mapbox (API key required)">
                <option value="mapbox-streets">Mapbox Streets</option>
                <option value="mapbox-outdoors">Mapbox Outdoors</option>
                <option value="mapbox-satellite">Mapbox Satellite</option>
                <option value="mapbox-satellite-streets">Mapbox Satellite Streets</option>
            </optgroup>
        `;

        // 3D map style options
        const map3DStyleOptions = `
            <option value="standard">Standard (3D Buildings)</option>
            <option value="satellite-streets-v12">Satellite Streets</option>
            <option value="satellite-v9">Satellite</option>
            <option value="outdoors-v12">Outdoors (with contours)</option>
            <option value="streets-v12">Streets</option>
        `;

        let current2DStyle = 'humanitarian'; // Track current 2D style
        let current3DStyle = 'satellite-streets-v12'; // Track current 3D style

        function toggle3DView() {
            if (!mapboxApiKey) {
                alert('Please configure your Mapbox API key first by clicking the üîë button.');
                return;
            }

            is3DMode = !is3DMode;
            const btn = document.getElementById('toggle3DBtn');
            const map2dContainer = document.getElementById('map');
            const map3dContainer = document.getElementById('map3d');
            const mapStyleSelect = document.getElementById('mapStyleSelect');

            const sliderOverlay = document.getElementById('mapSliderOverlay');

            const markerSizeSlider = document.getElementById('markerSizeSlider');
            const markerSizeValue = document.getElementById('markerSizeValue');
            const numberMarkerSizeSlider = document.getElementById('numberMarkerSizeSlider');
            const numberMarkerSizeValue = document.getElementById('numberMarkerSizeValue');

            if (is3DMode) {
                btn.textContent = '2D';
                btn.title = 'Switch back to 2D map view';
                map2dContainer.style.display = 'none';
                map3dContainer.style.display = 'block';

                // Save current 2D style and switch to 3D styles
                current2DStyle = mapStyleSelect.value;
                mapStyleSelect.innerHTML = map3DStyleOptions;
                mapStyleSelect.value = current3DStyle;

                // Update sliders to show 3D values
                markerSizeSlider.value = PHOTO_MARKER_SIZE_3D;
                markerSizeValue.textContent = PHOTO_MARKER_SIZE_3D + 'px';
                numberMarkerSizeSlider.value = BADGE_SCALE_3D;
                numberMarkerSizeValue.textContent = BADGE_SCALE_3D + 'x';

                // Show photo markers controls in 3D mode if in photo markers mode
                // Hide spread control in 3D (not needed with balloon display)
                // Move slider overlay to left edge (3D zoom controls are on right)
                if (photoMarkersMode) {
                    sliderOverlay.style.display = 'flex';
                    sliderOverlay.style.left = '10px';
                    document.getElementById('markerSizeControl').style.display = 'flex';
                    document.getElementById('numberMarkerSizeControl').style.display = 'flex';
                }
                document.getElementById('spiderSpreadControl').style.display = 'none';

                init3DMap();
            } else {
                btn.textContent = '3D';
                btn.title = 'Toggle 3D terrain view (requires Mapbox API key)';
                map2dContainer.style.display = 'block';
                map3dContainer.style.display = 'none';

                // Save current 3D style and restore 2D styles
                current3DStyle = mapStyleSelect.value;
                mapStyleSelect.innerHTML = map2DStyleOptions;
                mapStyleSelect.value = current2DStyle;

                // Update sliders to show 2D values
                markerSizeSlider.value = PHOTO_MARKER_SIZE;
                markerSizeValue.textContent = PHOTO_MARKER_SIZE + 'px';
                numberMarkerSizeSlider.value = BADGE_SCALE;
                numberMarkerSizeValue.textContent = BADGE_SCALE + 'x';

                // Restore photo markers controls if in photo markers mode
                // Show spread control in 2D (needed for clustering)
                // Move slider overlay back to clear Leaflet zoom controls (on left)
                if (photoMarkersMode) {
                    sliderOverlay.style.display = 'flex';
                    sliderOverlay.style.left = '50px';
                    document.getElementById('markerSizeControl').style.display = 'flex';
                    document.getElementById('numberMarkerSizeControl').style.display = 'flex';
                    document.getElementById('spiderSpreadControl').style.display = 'flex';
                } else {
                    document.getElementById('spiderSpreadControl').style.display = 'none';
                }

                // Sync view from 3D to 2D
                if (map3d && map) {
                    const center = map3d.getCenter();
                    const zoom = map3d.getZoom();
                    map.setView([center.lat, center.lng], zoom, { animate: false });
                }

                map.invalidateSize();
            }
        }

        function change3DStyle() {
            if (!map3d) return;

            const styleId = document.getElementById('mapStyleSelect').value;
            current3DStyle = styleId;
            const styleUrl = `mapbox://styles/mapbox/${styleId}`;

            map3d.setStyle(styleUrl);

            // The 'style.load' event will handle re-adding terrain, sky, routes and markers
        }

        function init3DMap() {
            if (!mapboxApiKey) return;

            mapboxgl.accessToken = mapboxApiKey;

            // Get current view from 2D map
            let center = [-122.4, 37.8]; // Default
            let zoom = 10;
            let pitch = 60;
            let bearing = 0;

            if (map) {
                const mapCenter = map.getCenter();
                center = [mapCenter.lng, mapCenter.lat];
                zoom = map.getZoom();
            }

            // If 3D map doesn't exist, create it
            if (!map3d) {
                const styleId = current3DStyle;
                map3d = new mapboxgl.Map({
                    container: 'map3d',
                    style: `mapbox://styles/mapbox/${styleId}`,
                    center: center,
                    zoom: zoom,
                    pitch: pitch,
                    bearing: bearing,
                    antialias: true,
                    preserveDrawingBuffer: true  // Required for canvas export (Save as JPEG)
                });

                map3d.on('style.load', () => {
                    // Add terrain
                    if (!map3d.getSource('mapbox-dem')) {
                        map3d.addSource('mapbox-dem', {
                            type: 'raster-dem',
                            url: 'mapbox://mapbox.mapbox-terrain-dem-v1',
                            tileSize: 512,
                            maxzoom: 14
                        });
                    }

                    map3d.setTerrain({ source: 'mapbox-dem', exaggeration: 1.5 });

                    // Add sky (not for Standard style which has its own lighting)
                    if (!map3d.getLayer('sky') && current3DStyle !== 'standard') {
                        map3d.addLayer({
                            id: 'sky',
                            type: 'sky',
                            paint: {
                                'sky-type': 'atmosphere',
                                'sky-atmosphere-sun': [0.0, 90.0],
                                'sky-atmosphere-sun-intensity': 15
                            }
                        });
                    }

                    // Add 3D buildings for streets style (Standard has them built-in)
                    if (current3DStyle === 'streets-v12' && !map3d.getLayer('3d-buildings')) {
                        const layers = map3d.getStyle().layers;
                        const labelLayerId = layers.find(
                            (layer) => layer.type === 'symbol' && layer.layout['text-field']
                        )?.id;

                        map3d.addLayer({
                            id: '3d-buildings',
                            source: 'composite',
                            'source-layer': 'building',
                            filter: ['==', 'extrude', 'true'],
                            type: 'fill-extrusion',
                            minzoom: 15,
                            paint: {
                                'fill-extrusion-color': '#aaa',
                                'fill-extrusion-height': ['get', 'height'],
                                'fill-extrusion-base': ['get', 'min_height'],
                                'fill-extrusion-opacity': 0.6
                            }
                        }, labelLayerId);
                    }

                    // Add routes and markers after a short delay to ensure style is fully ready
                    setTimeout(() => {
                        console.log('3D style loaded, adding routes and markers');
                        add3DRoutes();
                        add3DMarkers();
                        setup3DDepthSorting();
                    }, 200);
                });

                // Add navigation controls
                map3d.addControl(new mapboxgl.NavigationControl());
            } else {
                // Update existing map view
                map3d.setCenter(center);
                map3d.setZoom(zoom);
                map3d.resize();

                // Update routes and markers with a delay to ensure map is ready
                setTimeout(() => {
                    add3DRoutes();
                    add3DMarkers();
                    update3DMarkerDepths();
                }, 100);
            }
        }

        function resetView() {
            // Calculate bounds from marker positions (not GPS) and visible routes
            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);

            // Check if we have any visible content
            const hasVisibleRoutes = routes.some(route =>
                selectedActivities.has(route.activityType)
            );

            if (photosWithGPS.length === 0 && !hasVisibleRoutes) {
                // No data to show
                return;
            }

            // Build bounds from marker positions (may be offset from GPS)
            let minLng = Infinity, minLat = Infinity;
            let maxLng = -Infinity, maxLat = -Infinity;

            photosWithGPS.forEach((photo, idx) => {
                // Use marker offset position if available, otherwise use GPS
                const originalIndex = photos.indexOf(photo);
                const offset = photoMarkerOffsets[originalIndex];
                const lat = offset ? offset.lat : photo.gps.latitude;
                const lng = offset ? offset.lng : photo.gps.longitude;

                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
            });

            // Only include visible routes (filtered by selectedActivities)
            routes.forEach(route => {
                // Skip if activity type is filtered out
                if (!selectedActivities.has(route.activityType)) {
                    return;
                }
                route.path.forEach(point => {
                    minLng = Math.min(minLng, point.lng);
                    maxLng = Math.max(maxLng, point.lng);
                    minLat = Math.min(minLat, point.lat);
                    maxLat = Math.max(maxLat, point.lat);
                });
            });

            // Handle case where we have no valid bounds
            if (minLng === Infinity) {
                return;
            }

            if (is3DMode && map3d) {
                // 3D mode - fit with extra top padding for balloons
                map3d.fitBounds(
                    [[minLng, minLat], [maxLng, maxLat]],
                    {
                        padding: { top: 150, bottom: 50, left: 50, right: 50 },
                        pitch: 60,
                        bearing: 0,
                        duration: 1500
                    }
                );
            } else if (map) {
                // 2D mode - use Leaflet fitBounds
                const bounds = L.latLngBounds(
                    [minLat, minLng],
                    [maxLat, maxLng]
                );
                map.flyToBounds(bounds.pad(0.1), { duration: 1.5 });
            }
        }

        function add3DRoutes() {
            if (!map3d) {
                console.log('add3DRoutes: map3d not initialized');
                return;
            }

            // Remove existing route layers
            try {
                if (map3d.getLayer('routes-line')) map3d.removeLayer('routes-line');
                if (map3d.getLayer('routes-border')) map3d.removeLayer('routes-border');
                if (map3d.getSource('routes')) map3d.removeSource('routes');
            } catch (e) {
                console.log('add3DRoutes: error removing layers:', e);
            }

            console.log('add3DRoutes: routes array length =', routes.length);
            if (routes.length === 0) return;

            // Build GeoJSON from routes
            const features = routes.map((route, index) => {
                // Check if this activity type is selected (hide if not selected)
                if (!selectedActivities.has(route.activityType)) {
                    return null;
                }

                // Validate route path
                if (!route.path || route.path.length === 0) {
                    console.log('add3DRoutes: route', index, 'has no path');
                    return null;
                }

                return {
                    type: 'Feature',
                    properties: {
                        color: getActivityColor(route.activityType) || '#3388ff',
                        activityType: route.activityType
                    },
                    geometry: {
                        type: 'LineString',
                        coordinates: route.path.map(p => [p.lng, p.lat])
                    }
                };
            }).filter(f => f !== null);

            console.log('add3DRoutes: features count =', features.length);
            if (features.length === 0) return;

            try {
                map3d.addSource('routes', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    },
                    lineMetrics: true
                });

                // White border - rendered on ground with terrain draping
                map3d.addLayer({
                    id: 'routes-border',
                    type: 'line',
                    source: 'routes',
                    layout: {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    paint: {
                        'line-color': '#ffffff',
                        'line-width': 8,
                        'line-opacity': 0.9,
                        'line-emissive-strength': 1
                    }
                });

                // Colored line - rendered on ground with terrain draping
                map3d.addLayer({
                    id: 'routes-line',
                    type: 'line',
                    source: 'routes',
                    layout: {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    paint: {
                        'line-color': ['get', 'color'],
                        'line-width': 5,
                        'line-opacity': 0.9,
                        'line-emissive-strength': 1
                    }
                });

                console.log('add3DRoutes: layers added successfully');
            } catch (e) {
                console.error('add3DRoutes: error adding layers:', e);
            }
        }

        // Store 3D markers for cleanup
        let markers3d = [];
        let activePhotoMarker3d = null; // Currently displayed photo marker

        // Track currently shown photo for re-showing after marker refresh
        let activePhotoMarker3dData = null;

        function add3DMarkers() {
            if (!map3d) return;

            // Remove existing markers
            markers3d.forEach(m => m.remove());
            markers3d = [];

            // Store active photo data before removing (to restore after refresh)
            const savedActivePhoto = activePhotoMarker3dData;

            // Remove active photo marker if any
            if (activePhotoMarker3d) {
                activePhotoMarker3d.remove();
                activePhotoMarker3d = null;
            }

            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            const badgeSize = BASE_BADGE_SIZE * BADGE_SCALE_3D;

            photosWithGPS.forEach((photo, index) => {
                // Find the original index in the full photos array for transform lookup
                const originalIndex = photos.indexOf(photo);

                // Create numbered marker
                const el = document.createElement('div');
                el.className = 'marker-3d';
                el.style.cssText = `
                    width: ${badgeSize}px;
                    height: ${badgeSize}px;
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    border: 3px solid white;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-weight: bold;
                    font-size: ${badgeSize * 0.5}px;
                    box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
                    cursor: pointer;
                `;
                el.textContent = index + 1;

                // Click handler to show photo marker
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    show3DPhotoMarker(photo, index, originalIndex);
                });

                // Create marker
                const marker = new mapboxgl.Marker({
                    element: el,
                    anchor: 'center',
                    rotationAlignment: 'viewport',
                    pitchAlignment: 'viewport'
                })
                    .setLngLat([photo.gps.longitude, photo.gps.latitude])
                    .addTo(map3d);

                // Set z-index for number markers (between string z:1 and photo z:1000)
                el.style.zIndex = '500';

                // Store position for depth sorting
                marker._lngLat3d = [photo.gps.longitude, photo.gps.latitude];
                markers3d.push(marker);
            });

            // Restore active photo marker if there was one (skip animation on restore)
            if (savedActivePhoto) {
                const { photo, displayIndex, originalIndex } = savedActivePhoto;
                show3DPhotoMarker(photo, displayIndex, originalIndex, true);
            }
        }

        function show3DPhotoMarker(photo, displayIndex, originalIndex, skipAnimation = false) {
            // Remove previous photo marker if any
            if (activePhotoMarker3d) {
                activePhotoMarker3d.remove();
                activePhotoMarker3d = null;
            }

            // Store active photo data for restoration after slider changes
            activePhotoMarker3dData = { photo, displayIndex, originalIndex };

            const size = PHOTO_MARKER_SIZE_3D;
            const badgeSize = BASE_BADGE_SIZE * BADGE_SCALE_3D;

            // String starts at edge of number marker (not center), plus a small gap
            // Number marker radius = badgeSize / 2
            const numberMarkerRadius = badgeSize / 2;
            const gap = 5; // Small gap between number marker edge and string

            // String length from edge of number marker to bottom of photo
            const stringLength = badgeSize + 20; // Visible string above the number marker

            // Total height = photo + string + offset for number marker
            // The bottom of container is at GPS (center of number marker)
            // String starts at numberMarkerRadius + gap above GPS point
            const totalHeight = size + stringLength + numberMarkerRadius + gap;

            // Single container for photo + string, anchored at bottom (GPS point)
            const el = document.createElement('div');
            el.className = 'marker-3d-photo-popup';
            el.style.cssText = `
                width: ${size}px;
                height: ${totalHeight}px;
                cursor: pointer;
                position: relative;
            `;

            // Inner wrapper for animation (keeps Mapbox transforms separate)
            const animWrapper = document.createElement('div');
            animWrapper.style.cssText = `
                width: 100%;
                height: 100%;
                position: relative;
                transform-origin: bottom center;
            `;
            el.appendChild(animWrapper);

            // Photo circle at TOP of container
            const photoCircle = document.createElement('div');
            photoCircle.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: ${size}px;
                height: ${size}px;
                border-radius: 50%;
                overflow: hidden;
                border: 3px solid white;
                box-shadow: 0 4px 8px rgba(0,0,0,0.5), 0 8px 20px rgba(0,0,0,0.4);
                background: #333;
            `;

            const img = document.createElement('img');
            img.src = photo.src;

            // Check for saved image transform from 2D editing using original photo index
            const savedTransform = photoMarkerTransforms[originalIndex];
            if (savedTransform) {
                // Scale the transform values from 2D size to 3D size
                const sizeRatio = size / PHOTO_MARKER_SIZE;
                const scaledPosX = savedTransform.posX * sizeRatio;
                const scaledPosY = savedTransform.posY * sizeRatio;
                const scaledScale = savedTransform.scale * sizeRatio;
                img.style.cssText = `
                    position: absolute;
                    left: 0;
                    top: 0;
                    transform-origin: 0 0;
                    transform: translate(${scaledPosX}px, ${scaledPosY}px) scale(${scaledScale});
                `;
            } else {
                img.style.cssText = `
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                `;
            }
            photoCircle.appendChild(img);
            animWrapper.appendChild(photoCircle);

            // String from bottom of photo to edge of number marker (not center)
            // String starts at top: size (below photo) and ends at: totalHeight - numberMarkerRadius - gap
            const stringEl = document.createElement('div');
            stringEl.style.cssText = `
                position: absolute;
                left: 50%;
                top: ${size}px;
                transform: translateX(-50%);
                width: 3px;
                height: ${stringLength}px;
                background: linear-gradient(to bottom, rgba(102, 126, 234, 0.9), rgba(118, 75, 162, 0.9));
                border-radius: 2px;
                box-shadow: 0 0 0 2px white, 0 2px 4px rgba(0,0,0,0.3);
            `;
            animWrapper.appendChild(stringEl);

            // Click handler to dismiss
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                if (activePhotoMarker3d) {
                    activePhotoMarker3d.remove();
                    activePhotoMarker3d = null;
                }
                activePhotoMarker3dData = null;
            });

            // Create marker with anchor at bottom (GPS point)
            activePhotoMarker3d = new mapboxgl.Marker({
                element: el,
                anchor: 'bottom',
                rotationAlignment: 'viewport',
                pitchAlignment: 'viewport'
            })
                .setLngLat([photo.gps.longitude, photo.gps.latitude])
                .addTo(map3d);

            // Balloon z-index: 1000 (ABOVE number markers at 500)
            // String now starts at edge of number marker, not center
            el.style.zIndex = '1000';

            // Apply Disney-style bouncy animation (skip when restoring after slider change)
            if (!skipAnimation) {
                animWrapper.style.animation = 'balloonPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
            }
        }

        // Update marker z-indices based on distance from camera
        function update3DMarkerDepths() {
            if (!map3d || markers3d.length === 0) return;

            const camera = map3d.getFreeCameraOptions();
            const cameraPos = camera.position;

            // Calculate distance from camera to each marker
            const markerDistances = markers3d.map((marker, index) => {
                const lngLat = marker._lngLat3d || marker.getLngLat();
                const lng = Array.isArray(lngLat) ? lngLat[0] : lngLat.lng;
                const lat = Array.isArray(lngLat) ? lngLat[1] : lngLat.lat;

                // Convert to approximate 3D position
                // Use mercator projection approximation
                const mercX = (lng + 180) / 360;
                const mercY = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2;

                // Get camera position in same coordinate space
                const camX = cameraPos ? cameraPos.x : 0.5;
                const camY = cameraPos ? cameraPos.y : 0.5;
                const camZ = cameraPos ? cameraPos.z : 1;

                // Calculate distance (simplified)
                const dx = mercX - camX;
                const dy = mercY - camY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                return { marker, index, distance };
            });

            // Sort by distance (farthest first = lowest z-index)
            markerDistances.sort((a, b) => b.distance - a.distance);

            // Apply z-indices (base of 500 to stay above balloon at z-index 100)
            markerDistances.forEach((item, zOrder) => {
                const el = item.marker.getElement();
                if (el) {
                    el.style.zIndex = 500 + zOrder;
                }
            });
        }

        // Set up depth sorting when 3D map is initialized
        function setup3DDepthSorting() {
            if (!map3d) return;

            // Throttled update for performance (runs at most every 50ms during camera movement)
            const throttledDepthUpdate = throttle(update3DMarkerDepths, 50);

            // Update on camera movement
            map3d.on('move', throttledDepthUpdate);
            map3d.on('zoom', throttledDepthUpdate);
            map3d.on('pitch', throttledDepthUpdate);
            map3d.on('rotate', throttledDepthUpdate);

            // Initial update
            update3DMarkerDepths();
        }

        function showMap() {
            mapModal.classList.add('active');

            // Show/hide 3D button based on API key availability
            document.getElementById('toggle3DBtn').style.display = mapboxApiKey ? '' : 'none';

            // Close any existing popups
            closeAllPhotoPopups();

            // Remember if photo markers mode was active to restore it later
            const wasPhotoMarkersMode = photoMarkersMode;

            // Temporarily reset photo markers mode while rebuilding
            photoMarkersMode = false;
            document.getElementById('photoMarkersBtn').textContent = 'Photo Markers';
            document.getElementById('mapSliderOverlay').style.display = 'none';
            document.getElementById('markerSizeControl').style.display = 'none';
            document.getElementById('numberMarkerSizeControl').style.display = 'none';
            document.getElementById('spiderSpreadControl').style.display = 'none';

            if (!map) {
                map = L.map('map', {
                    scrollWheelZoom: true,
                    wheelPxPerZoomLevel: 240,  // Default is 60, 4x makes zoom 4x finer
                    wheelDebounceTime: 40,      // Smoother scrolling
                    zoomSnap: 0.25              // Allow quarter-zoom levels for smoother transitions
                });

                // Create custom pane for rubberband lines (above routes in shadowPane, below markers)
                map.createPane('rubberbandPane');
                map.getPane('rubberbandPane').style.zIndex = 550; // Above shadowPane (500), below markerPane (600)

                // Create Canvas renderers for polylines (fixes html2canvas SVG rendering issues)
                map.routeRenderer = L.canvas({ pane: 'shadowPane' });
                map.rubberbandRenderer = L.canvas({ pane: 'rubberbandPane' });

                // Default to Mapbox Streets if API key is available, otherwise humanitarian
                const defaultStyleKey = mapboxApiKey ? 'mapbox-streets' : 'humanitarian';
                const defaultStyle = mapStyles[defaultStyleKey];
                let tileUrl = defaultStyle.url;
                if (mapboxApiKey && defaultStyle.requiresKey) {
                    tileUrl = tileUrl.replace('{accessToken}', mapboxApiKey);
                }
                currentTileLayer = L.tileLayer(tileUrl, {
                    attribution: defaultStyle.attribution,
                    maxZoom: 19
                }).addTo(map);
                mapStyleSelect.value = defaultStyleKey;

                // Update spider positions on zoom
                map.on('zoomend', () => {
                    if (photoMarkersMode) {
                        updateSpiderPositions();
                    }
                });

                // Track user interactions with the map
                map.on('zoomend moveend', () => {
                    userHasInteractedWithMap = true;
                    savedMapState = {
                        center: map.getCenter(),
                        zoom: map.getZoom()
                    };
                });
            }

            // Force map to recalculate size after modal is displayed
            setTimeout(() => {
                map.invalidateSize();
            }, 100);

            // Clear existing markers and routes
            markers.forEach(marker => map.removeLayer(marker));
            markers = [];
            routePolylines.forEach(poly => {
                poly.border.remove();
                poly.line.remove();
            });
            routePolylines = [];

            // Draw routes first (so they appear under markers)
            routes.forEach((route, index) => {
                const color = getActivityColor(route.activityType);
                
                // Draw white border first (wider line)
                const borderLine = L.polyline(route.path, {
                    color: '#ffffff',
                    weight: 12,
                    opacity: 0.9,
                    pane: 'shadowPane',
                    renderer: map.routeRenderer  // Use Canvas renderer for html2canvas compatibility
                }).addTo(map);

                // Draw colored route on top
                const polyline = L.polyline(route.path, {
                    color: color,
                    weight: 8,
                    opacity: 0.8,
                    pane: 'shadowPane',
                    renderer: map.routeRenderer  // Use Canvas renderer for html2canvas compatibility
                }).addTo(map);
                
                // Add popup to route
                const distKm = (route.distance / 1000).toFixed(2);
                const activityName = route.activityType.charAt(0).toUpperCase() + route.activityType.slice(1);
                polyline.bindPopup(`
                    <div style="text-align: center;">
                        <div style="font-weight: 600; color: ${color}; margin-bottom: 4px;">${activityName}</div>
                        <div style="font-size: 0.9em;">Start: ${route.startTime.toLocaleTimeString()}</div>
                        <div style="font-size: 0.9em;">End: ${route.endTime.toLocaleTimeString()}</div>
                        <div style="font-size: 0.9em; font-weight: 500; margin-top: 4px;">Distance: ${distKm} km</div>
                    </div>
                `);
                
                routePolylines.push({ border: borderLine, line: polyline });
            });

            // Apply saved route filters
            filterRoutes();

            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            
            photosWithGPS.forEach((photo, index) => {
                // Create numbered marker
                const numberIcon = L.divIcon({
                    className: 'numbered-marker',
                    html: `<div style="background: #667eea; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: 14px; border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${index + 1}</div>`,
                    iconSize: [32, 32],
                    iconAnchor: [16, 16],
                    popupAnchor: [0, -16]
                });
                
                const marker = L.marker([photo.gps.latitude, photo.gps.longitude], {
                    icon: numberIcon,
                    zIndexOffset: 1000  // Ensure markers are above routes
                }).addTo(map);
                
                // Use custom floating popup instead of Leaflet popup
                marker.on('click', () => {
                    openPhotoPopup(photo, index, marker);
                });
                
                markers.push(marker);
            });

            // Restore saved map view if user has interacted, otherwise fit to bounds
            if (userHasInteractedWithMap && savedMapState) {
                // Restore user's saved view
                map.setView(savedMapState.center, savedMapState.zoom, { animate: false });
            } else {
                // Fit map to show all GPS data (photos and routes)
                const bounds = L.latLngBounds();

                // Add photo marker positions to bounds
                markers.forEach(marker => {
                    bounds.extend(marker.getLatLng());
                });

                // Add route positions to bounds
                routes.forEach(route => {
                    route.path.forEach(point => {
                        bounds.extend([point.lat, point.lng]);
                    });
                });

                if (bounds.isValid()) {
                    map.fitBounds(bounds.pad(0.1));
                }
            }

            // Restore photo markers mode if it was active before
            if (wasPhotoMarkersMode) {
                setTimeout(() => {
                    togglePhotoMarkers();
                }, 150);
            }
        }

        // Floating popup management
        let activePopups = [];
        let popupZIndex = 2000;

        function openPhotoPopup(photo, index, marker) {
            // Create the popup panel
            const panel = document.createElement('div');
            panel.className = 'photo-popup-panel';
            panel.dataset.photoIndex = index;
            panel.style.zIndex = ++popupZIndex;
            
            // Position near the marker
            const mapContainer = document.getElementById('mapContainer');
            const mapRect = mapContainer.getBoundingClientRect();
            const point = map.latLngToContainerPoint([photo.gps.latitude, photo.gps.longitude]);
            
            // Initial position - offset from marker
            let left = point.x + 40;
            let top = point.y - 100;
            
            // Keep within map bounds
            left = Math.max(10, Math.min(left, mapRect.width - 300));
            top = Math.max(10, Math.min(top, mapRect.height - 250));
            
            panel.style.left = left + 'px';
            panel.style.top = top + 'px';
            panel.style.width = '320px';
            panel.style.height = '420px';
            
            // Header
            const header = document.createElement('div');
            header.className = 'photo-popup-header';
            
            const title = document.createElement('h3');
            title.textContent = photo.name;
            
            const closeBtn = document.createElement('button');
            closeBtn.className = 'photo-popup-close';
            closeBtn.innerHTML = '√ó';
            closeBtn.onclick = () => closePhotoPopup(panel);
            
            header.appendChild(title);
            header.appendChild(closeBtn);
            
            // Content
            const content = document.createElement('div');
            content.className = 'photo-popup-content';
            
            // Image container with pan/zoom
            const imgContainer = document.createElement('div');
            imgContainer.className = 'photo-popup-image-container';
            
            // Number badge
            const numberBadge = document.createElement('div');
            numberBadge.className = 'photo-popup-number';
            numberBadge.textContent = index + 1;
            imgContainer.appendChild(numberBadge);
            
            if (photo.src) {
                const img = document.createElement('img');
                img.className = 'photo-popup-image';
                img.src = photo.src;
                img.alt = photo.name;
                
                // Pan/zoom state
                let scale = 1;
                let posX = 0;
                let posY = 0;
                let isDragging = false;
                let startX, startY, initialX, initialY;
                let baseScale = 1;
                let minScale = 0.1;
                let imgWidth = 0;
                let imgHeight = 0;
                
                function readContainerSize() {
                    const r = imgContainer.getBoundingClientRect();
                    return {
                        width: Math.max(1, r.width),
                        height: Math.max(1, r.height)
                    };
                }
                
                function updateTransform() {
                    img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                    img.style.transformOrigin = 'top left';
                }
                
                function fitImage() {
                    if (!imgWidth || !imgHeight) return;
                    const container = readContainerSize();
                    const isPortrait = imgHeight > imgWidth;
                    
                    if (isPortrait) {
                        baseScale = container.width / imgWidth;
                    } else {
                        const scaleX = container.width / imgWidth;
                        const scaleY = container.height / imgHeight;
                        baseScale = Math.max(scaleX, scaleY);
                    }
                    
                    minScale = baseScale;
                    scale = baseScale;
                    posX = 0;
                    posY = 0;
                    updateTransform();
                }
                
                img.onload = function() {
                    imgWidth = img.naturalWidth;
                    imgHeight = img.naturalHeight;
                    fitImage();
                };
                
                // Observe container resize
                const ro = new ResizeObserver(() => {
                    if (imgWidth && imgHeight) {
                        const container = readContainerSize();
                        const isPortrait = imgHeight > imgWidth;
                        
                        if (isPortrait) {
                            baseScale = container.width / imgWidth;
                        } else {
                            const scaleX = container.width / imgWidth;
                            const scaleY = container.height / imgHeight;
                            baseScale = Math.max(scaleX, scaleY);
                        }
                        
                        minScale = baseScale;
                        if (scale < minScale) scale = minScale;
                        updateTransform();
                    }
                });
                ro.observe(imgContainer);
                
                // Mouse drag
                img.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = posX;
                    initialY = posY;
                    e.preventDefault();
                });
                
                imgContainer.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const dx = e.clientX - startX;
                    const dy = e.clientY - startY;
                    posX = initialX + dx;
                    posY = initialY + dy;
                    updateTransform();
                });
                
                imgContainer.addEventListener('mouseup', () => isDragging = false);
                imgContainer.addEventListener('mouseleave', () => isDragging = false);
                
                // Mouse wheel zoom - finer control
                imgContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.03 : 0.03;
                    scale = Math.max(minScale, Math.min(5, scale + delta));
                    updateTransform();
                }, { passive: false });
                
                imgContainer.appendChild(img);
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'photo-popup-placeholder';
                placeholder.textContent = 'üì∏';
                placeholder.appendChild(numberBadge.cloneNode(true));
                imgContainer.appendChild(placeholder);
            }
            
            content.appendChild(imgContainer);
            
            // Format date in Brisbane time
            const dateTime = photo.gps.dateTimeObj ? formatBrisbaneDateTime(photo.gps.dateTimeObj) : null;
            
            // Details
            const details = document.createElement('div');
            details.className = 'photo-popup-details';
            details.innerHTML = `
                <div><strong>Coordinates:</strong> ${photo.gps.latitude.toFixed(6)}, ${photo.gps.longitude.toFixed(6)}</div>
                <div><strong>Altitude:</strong> ${photo.gps.altitude}</div>
                ${dateTime ? `<div><strong>Date:</strong> ${dateTime.date}</div>` : ''}
                ${dateTime ? `<div><strong>Time:</strong> ${dateTime.time}</div>` : ''}
            `;
            content.appendChild(details);
            
            // Comment section
            const commentSection = document.createElement('div');
            commentSection.className = 'photo-popup-comment-section';
            
            const commentLabel = document.createElement('label');
            commentLabel.textContent = 'üí¨ Comment';
            commentLabel.htmlFor = `comment-${index}`;
            
            const commentArea = document.createElement('textarea');
            commentArea.className = 'photo-popup-comment';
            commentArea.id = `comment-${index}`;
            commentArea.placeholder = 'Add a comment about this photo...';
            commentArea.value = photo.comment || '';
            
            const savedIndicator = document.createElement('div');
            savedIndicator.className = 'photo-popup-comment-saved';
            savedIndicator.textContent = '‚úì Saved';
            
            // Auto-save comment on input
            let saveTimeout;
            commentArea.addEventListener('input', () => {
                clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    photo.comment = commentArea.value;
                    savedIndicator.classList.add('visible');
                    setTimeout(() => savedIndicator.classList.remove('visible'), 1500);
                    // Update the card display too
                    renderPhotos();
                }, 500);
            });
            
            commentSection.appendChild(commentLabel);
            commentSection.appendChild(commentArea);
            commentSection.appendChild(savedIndicator);
            content.appendChild(commentSection);
            
            // Resize handle
            const resizeHandle = document.createElement('div');
            resizeHandle.className = 'photo-popup-resize-handle';
            
            panel.appendChild(header);
            panel.appendChild(content);
            panel.appendChild(resizeHandle);
            
            // Add to map container
            mapContainer.appendChild(panel);
            activePopups.push(panel);
            
            // Make draggable
            setupPanelDrag(panel, header);
            
            // Make resizable
            setupPanelResize(panel, resizeHandle);
            
            // Bring to front on click
            panel.addEventListener('mousedown', () => {
                panel.style.zIndex = ++popupZIndex;
            });
        }

        function closePhotoPopup(panel) {
            panel.remove();
            activePopups = activePopups.filter(p => p !== panel);
        }

        function closeAllPhotoPopups() {
            activePopups.forEach(p => p.remove());
            activePopups = [];
        }

        function setupPanelDrag(panel, header) {
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            header.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('photo-popup-close')) return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                startLeft = panel.offsetLeft;
                startTop = panel.offsetTop;
                
                panel.style.zIndex = ++popupZIndex;
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                const mapContainer = document.getElementById('mapContainer');
                const mapRect = mapContainer.getBoundingClientRect();
                const panelRect = panel.getBoundingClientRect();
                
                let newLeft = startLeft + dx;
                let newTop = startTop + dy;
                
                // Keep within map container
                newLeft = Math.max(0, Math.min(newLeft, mapRect.width - panelRect.width));
                newTop = Math.max(0, Math.min(newTop, mapRect.height - panelRect.height));
                
                panel.style.left = newLeft + 'px';
                panel.style.top = newTop + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        function setupPanelResize(panel, handle) {
            let isResizing = false;
            let startX, startY, startWidth, startHeight;
            
            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = panel.offsetWidth;
                startHeight = panel.offsetHeight;
                
                panel.style.zIndex = ++popupZIndex;
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                const newWidth = Math.max(280, startWidth + dx);
                const newHeight = Math.max(200, startHeight + dy);
                
                panel.style.width = newWidth + 'px';
                panel.style.height = newHeight + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isResizing = false;
            });
        }

        // Photo Markers Mode
        function togglePhotoMarkers() {
            photoMarkersMode = !photoMarkersMode;
            const btn = document.getElementById('photoMarkersBtn');
            const photoSizeControl = document.getElementById('markerSizeControl');
            const numberSizeControl = document.getElementById('numberMarkerSizeControl');
            const spiderSpreadControl = document.getElementById('spiderSpreadControl');
            const sliderOverlay = document.getElementById('mapSliderOverlay');

            if (photoMarkersMode) {
                btn.textContent = 'Number Markers';
                sliderOverlay.style.display = 'flex';
                // Position slider overlay based on view mode (3D controls on right, 2D on left)
                sliderOverlay.style.left = is3DMode ? '10px' : '50px';
                photoSizeControl.style.display = 'flex';
                numberSizeControl.style.display = 'flex';
                // Show spread control only in 2D mode (not needed in 3D with balloon display)
                spiderSpreadControl.style.display = is3DMode ? 'none' : 'flex';
                closeAllPhotoPopups(); // Close popups in photo marker mode
                if (is3DMode) {
                    add3DMarkers(); // Refresh 3D markers with photo mode
                } else {
                    showPhotoMarkers();
                }
            } else {
                btn.textContent = 'Photo Markers';
                sliderOverlay.style.display = 'none';
                photoSizeControl.style.display = 'none';
                numberSizeControl.style.display = 'none';
                spiderSpreadControl.style.display = 'none';
                if (is3DMode) {
                    add3DMarkers(); // Refresh 3D markers with number mode
                } else {
                    hidePhotoMarkers();
                    showNumberMarkers();
                }
            }
        }

        function showPhotoMarkers() {
            // Hide numbered markers
            markers.forEach(m => map.removeLayer(m));
            
            // Clear existing photo markers
            clearPhotoMarkers();
            
            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            
            // Group photos by proximity
            const clusters = clusterPhotosByProximity(photosWithGPS);
            
            // Create markers for each cluster
            clusters.forEach(cluster => {
                if (cluster.photos.length === 1) {
                    // Single photo - just create marker at location
                    createPhotoMarker(cluster.photos[0], cluster.center);
                } else {
                    // Multiple photos - create spider
                    createSpiderCluster(cluster);
                }
            });
        }

        function hidePhotoMarkers() {
            clearPhotoMarkers();
        }

        function clearPhotoMarkers() {
            photoMarkers.forEach(pm => {
                if (pm.marker) map.removeLayer(pm.marker);
            });
            photoMarkers = [];

            numberBadgeMarkers.forEach(m => {
                if (m) map.removeLayer(m);
            });
            numberBadgeMarkers = [];

            spiderLegs.forEach(leg => {
                if (leg) map.removeLayer(leg);
            });
            spiderLegs = [];

            // Clear rubberband lines and GPS dots
            rubberbandLines.forEach(line => {
                if (line) map.removeLayer(line);
            });
            rubberbandLines = [];
        }
        
        function resetPhotoMarkerTransforms() {
            photoMarkerTransforms = {};
            photoMarkerOffsets = {};
        }

        function showNumberMarkers() {
            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            markers.forEach(m => map.removeLayer(m));
            markers = [];
            
            const size = NUMBER_MARKER_SIZE;
            const fontSize = Math.round(size * 0.44);
            const borderWidth = Math.max(2, Math.round(size * 0.09));
            
            photosWithGPS.forEach((photo, index) => {
                const numberIcon = L.divIcon({
                    className: 'numbered-marker',
                    html: `<div style="background: #667eea; color: white; border-radius: 50%; width: ${size}px; height: ${size}px; display: flex; align-items: center; justify-content: center; font-weight: bold; font-size: ${fontSize}px; border: ${borderWidth}px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${index + 1}</div>`,
                    iconSize: [size, size],
                    iconAnchor: [size / 2, size / 2],
                    popupAnchor: [0, -size / 2]
                });
                
                const marker = L.marker([photo.gps.latitude, photo.gps.longitude], {
                    icon: numberIcon,
                    zIndexOffset: 1000
                }).addTo(map);
                
                marker.on('click', () => {
                    openPhotoPopup(photo, index, marker);
                });
                
                markers.push(marker);
            });
        }

        function clusterPhotosByProximity(photosWithGPS) {
            const clusters = [];
            const assigned = new Set();
            const proximityThreshold = 0.0001; // ~11 meters
            
            photosWithGPS.forEach((photo, idx) => {
                if (assigned.has(idx)) return;
                
                const cluster = {
                    photos: [{ photo, index: photos.indexOf(photo) }],
                    center: { lat: photo.gps.latitude, lng: photo.gps.longitude }
                };
                assigned.add(idx);
                
                // Find nearby photos
                photosWithGPS.forEach((other, otherIdx) => {
                    if (assigned.has(otherIdx)) return;
                    
                    const dist = Math.sqrt(
                        Math.pow(photo.gps.latitude - other.gps.latitude, 2) +
                        Math.pow(photo.gps.longitude - other.gps.longitude, 2)
                    );
                    
                    if (dist < proximityThreshold) {
                        cluster.photos.push({ photo: other, index: photos.indexOf(other) });
                        assigned.add(otherIdx);
                    }
                });
                
                // Calculate center
                if (cluster.photos.length > 1) {
                    let sumLat = 0, sumLng = 0;
                    cluster.photos.forEach(p => {
                        sumLat += p.photo.gps.latitude;
                        sumLng += p.photo.gps.longitude;
                    });
                    cluster.center = {
                        lat: sumLat / cluster.photos.length,
                        lng: sumLng / cluster.photos.length
                    };
                }
                
                clusters.push(cluster);
            });
            
            return clusters;
        }

        function createPhotoMarker(photoData, position) {
            const { photo, index } = photoData;
            const size = PHOTO_MARKER_SIZE;

            // Store the original GPS position (position might already be offset for spider clusters)
            const gpsPosition = { lat: photo.gps.latitude, lng: photo.gps.longitude };

            // Apply any saved offset to the display position
            const savedOffset = photoMarkerOffsets[index];
            let displayPosition = { ...position };
            if (savedOffset) {
                displayPosition.lat = position.lat + savedOffset.lat;
                displayPosition.lng = position.lng + savedOffset.lng;
            }

            const container = document.createElement('div');
            container.className = 'photo-marker';
            container.style.width = size + 'px';
            container.style.height = size + 'px';
            container.style.boxShadow = '0 3px 10px rgba(0,0,0,0.6), 0 0 0 1px rgba(0,0,0,0.3), 0 8px 25px rgba(0,0,0,0.4)';

            const imgContainer = document.createElement('div');
            imgContainer.className = 'photo-marker-container';

            if (photo.src) {
                const img = document.createElement('img');
                img.className = 'photo-marker-img';
                img.loading = 'lazy'; // Lazy load for performance
                img.decoding = 'async'; // Async decode for smoother rendering
                img.src = photo.src;

                // Pan/zoom state
                let scale = 1;
                let posX = 0;
                let posY = 0;
                let isDragging = false;
                let startX, startY, initialX, initialY;
                let baseScale = 1;
                let imgWidth = 0, imgHeight = 0;

                function updateTransform() {
                    img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                }

                img.onload = function() {
                    imgWidth = img.naturalWidth;
                    imgHeight = img.naturalHeight;

                    // Cover the circular area
                    const scaleX = size / imgWidth;
                    const scaleY = size / imgHeight;
                    baseScale = Math.max(scaleX, scaleY);
                    scale = baseScale;

                    // Center
                    posX = (size - imgWidth * scale) / 2;
                    posY = (size - imgHeight * scale) / 2;

                    updateTransform();
                };

                // Drag handling
                img.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = posX;
                    initialY = posY;
                    e.preventDefault();
                    e.stopPropagation();
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    posX = initialX + (e.clientX - startX);
                    posY = initialY + (e.clientY - startY);
                    updateTransform();
                });

                document.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                // Wheel zoom - zoom from center of marker
                imgContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const delta = e.deltaY > 0 ? -0.008 : 0.008;
                    const oldScale = scale;
                    scale = Math.max(baseScale * 0.5, Math.min(5, scale + delta));

                    // Zoom from center: adjust position by half the size change
                    const oldWidth = imgWidth * oldScale;
                    const oldHeight = imgHeight * oldScale;
                    const newWidth = imgWidth * scale;
                    const newHeight = imgHeight * scale;

                    // Move top-left corner by half the difference (negative when growing)
                    posX -= (newWidth - oldWidth) / 2;
                    posY -= (newHeight - oldHeight) / 2;

                    updateTransform();
                }, { passive: false });

                imgContainer.appendChild(img);
            } else {
                const placeholder = document.createElement('div');
                placeholder.className = 'photo-marker-placeholder';
                placeholder.textContent = 'üì∏';
                imgContainer.appendChild(placeholder);
            }

            // Number badge - now created as separate marker for proper z-ordering

            container.appendChild(imgContainer);

            // Add padding for shadow (shadow is up to 25px blur + 8px offset)
            const shadowPadding = 40;
            const totalSize = size + shadowPadding * 2;

            // Wrap container in a div with padding for shadow
            const wrapper = document.createElement('div');
            wrapper.style.cssText = `width: ${totalSize}px; height: ${totalSize}px; display: flex; align-items: center; justify-content: center;`;
            wrapper.appendChild(container);

            const icon = L.divIcon({
                className: 'photo-marker-icon',
                html: wrapper.outerHTML,
                iconSize: [totalSize, totalSize],
                iconAnchor: [totalSize / 2, totalSize / 2]
            });

            const marker = L.marker([displayPosition.lat, displayPosition.lng], {
                icon: icon,
                zIndexOffset: 1000,
                draggable: false  // Controlled by Option/Alt key
            }).addTo(map);

            // Create rubberband line and GPS dot if marker has been offset
            let rubberbandLine = null;
            let rubberbandBorder = null;
            let gpsDot = null;
            const RUBBERBAND_THRESHOLD = 20; // pixels - show rubberband if marker moved more than this

            function updateRubberband() {
                const markerLatLng = marker.getLatLng();
                const markerPoint = map.latLngToContainerPoint(markerLatLng);
                const gpsPoint = map.latLngToContainerPoint([gpsPosition.lat, gpsPosition.lng]);
                const distance = Math.sqrt(Math.pow(markerPoint.x - gpsPoint.x, 2) + Math.pow(markerPoint.y - gpsPoint.y, 2));

                if (distance > RUBBERBAND_THRESHOLD) {
                    if (!rubberbandLine) {
                        // Create white border line first (underneath)
                        rubberbandBorder = L.polyline([
                            [gpsPosition.lat, gpsPosition.lng],
                            [markerLatLng.lat, markerLatLng.lng]
                        ], {
                            color: 'white',
                            weight: 6,
                            opacity: 0.9,
                            pane: 'rubberbandPane',
                            renderer: map.rubberbandRenderer  // Use Canvas renderer for html2canvas compatibility
                        }).addTo(map);
                        rubberbandLines.push(rubberbandBorder);

                        // Create colored line on top
                        rubberbandLine = L.polyline([
                            [gpsPosition.lat, gpsPosition.lng],
                            [markerLatLng.lat, markerLatLng.lng]
                        ], {
                            color: '#667eea',
                            weight: 3,
                            opacity: 1,
                            dashArray: '8, 8',
                            pane: 'rubberbandPane',
                            renderer: map.rubberbandRenderer  // Use Canvas renderer for html2canvas compatibility
                        }).addTo(map);
                        rubberbandLines.push(rubberbandLine);
                    } else {
                        const coords = [
                            [gpsPosition.lat, gpsPosition.lng],
                            [markerLatLng.lat, markerLatLng.lng]
                        ];
                        if (rubberbandBorder) rubberbandBorder.setLatLngs(coords);
                        rubberbandLine.setLatLngs(coords);
                    }

                    if (!gpsDot) {
                        gpsDot = L.circleMarker([gpsPosition.lat, gpsPosition.lng], {
                            radius: 8,
                            fillColor: '#667eea',
                            fillOpacity: 1,
                            color: 'white',
                            weight: 2,
                            pane: 'rubberbandPane',
                            renderer: map.rubberbandRenderer  // Use Canvas renderer for html2canvas compatibility
                        }).addTo(map);
                        rubberbandLines.push(gpsDot);
                    }
                } else {
                    if (rubberbandBorder) {
                        map.removeLayer(rubberbandBorder);
                        const idx = rubberbandLines.indexOf(rubberbandBorder);
                        if (idx > -1) rubberbandLines.splice(idx, 1);
                        rubberbandBorder = null;
                    }
                    if (rubberbandLine) {
                        map.removeLayer(rubberbandLine);
                        const idx = rubberbandLines.indexOf(rubberbandLine);
                        if (idx > -1) rubberbandLines.splice(idx, 1);
                        rubberbandLine = null;
                    }
                    if (gpsDot) {
                        map.removeLayer(gpsDot);
                        const idx = rubberbandLines.indexOf(gpsDot);
                        if (idx > -1) rubberbandLines.splice(idx, 1);
                        gpsDot = null;
                    }
                }
            }

            // Initial rubberband check
            updateRubberband();

            // Create separate number badge marker on top layer - draggable in orbit
            const badgeSize = Math.round(BASE_BADGE_SIZE * BADGE_SCALE);

            // Get stored angle or default to bottom-left (-135 degrees = -3œÄ/4 radians)
            const defaultAngle = -Math.PI * 3 / 4; // Bottom-left
            const angle = badgeOrbitalAngles[index] !== undefined ? badgeOrbitalAngles[index] : defaultAngle;

            // Orbit radius - at larger badge scales, allow overlap with photo
            // At 1x: badge orbits outside photo. At 5x: badge can overlap significantly
            const baseOrbitRadius = size / 2 + BASE_BADGE_SIZE / 2 + 4;
            const orbitRadius = Math.max(size / 4, baseOrbitRadius - (BADGE_SCALE - 1) * BASE_BADGE_SIZE / 2);

            // Icon needs to be large enough to contain badge at any orbit position
            const badgeIconSize = size + 2 * orbitRadius + badgeSize * 2;
            const badgeIconCenter = badgeIconSize / 2;

            // Badge starts hidden, setupOrbitalDrag will position it correctly
            // Dynamic sizing via inline styles
            const badgeFontSize = Math.round(14 * BADGE_SCALE);
            const badgePadding = Math.round(6 * BADGE_SCALE);
            const badgeBorderRadius = badgeSize / 2;
            const badgeBorder = Math.max(2, Math.round(2 * BADGE_SCALE));
            const badgeHtml = `<div class="photo-marker-number orbital-badge" style="position:absolute;left:0;top:0;visibility:hidden;cursor:grab;min-width:${badgeSize}px;height:${badgeSize}px;font-size:${badgeFontSize}px;padding:0 ${badgePadding}px;border-radius:${badgeBorderRadius}px;border-width:${badgeBorder}px;line-height:${badgeSize - badgeBorder * 2}px;background:#667eea;color:white;font-weight:bold;border:${badgeBorder}px solid white;box-shadow:0 4px 8px rgba(0,0,0,0.5),0 8px 20px rgba(0,0,0,0.4),0 12px 30px rgba(0,0,0,0.25);">${index + 1}</div>`;
            const badgeIcon = L.divIcon({
                className: 'photo-marker-badge-icon',
                html: badgeHtml,
                iconSize: [badgeIconSize, badgeIconSize],
                iconAnchor: [badgeIconCenter, badgeIconCenter]
            });

            const badgeMarker = L.marker([displayPosition.lat, displayPosition.lng], {
                icon: badgeIcon,
                zIndexOffset: 5000,
                interactive: true
            }).addTo(map);

            // Setup orbital dragging for badge
            setTimeout(() => {
                const badgeEl = badgeMarker.getElement();
                if (badgeEl) {
                    const badge = badgeEl.querySelector('.orbital-badge');
                    if (badge) {
                        setupOrbitalDrag(badge, marker, index, badgeSize, orbitRadius, angle);
                    }
                }
            }, 50);

            numberBadgeMarkers.push(badgeMarker);

            // Re-attach event listeners after adding to map
            setTimeout(() => {
                const el = marker.getElement();
                if (el) {
                    setupPhotoMarkerInteraction(el, photo, index, marker, badgeMarker, updateRubberband, position);
                }
            }, 50);

            photoMarkers.push({ marker, badgeMarker, photo, index, gpsPosition, updateRubberband });
        }
        
        function setupOrbitalDrag(badge, photoMarker, photoIndex, badgeSize, orbitRadius, initialAngle) {
            function getOrbitRadius() {
                return orbitRadius;
            }
            
            function getOrbitCenter() {
                const latLng = photoMarker.getLatLng();
                const containerPoint = map.latLngToContainerPoint(latLng);
                const mapRect = map.getContainer().getBoundingClientRect();
                return {
                    x: mapRect.left + containerPoint.x,
                    y: mapRect.top + containerPoint.y
                };
            }
            
            function updateBadgePosition(angle) {
                const radius = getOrbitRadius();
                const center = getOrbitCenter();
                
                const badgeEl = badge.parentElement;
                const badgeRect = badgeEl.getBoundingClientRect();
                
                const targetScreenX = center.x + Math.cos(angle) * radius;
                const targetScreenY = center.y + Math.sin(angle) * radius;
                
                const x = targetScreenX - badgeRect.left - badgeSize / 2;
                const y = targetScreenY - badgeRect.top - badgeSize / 2;
                
                badge.style.left = x + 'px';
                badge.style.top = y + 'px';
            }
            
            // Immediately reposition badge to correct location and make visible
            updateBadgePosition(initialAngle);
            badge.style.visibility = 'visible';
            
            // Store functions for global drag handler to use
            badge._orbitalData = {
                photoMarker,
                photoIndex,
                badgeSize,
                getOrbitCenter,
                updateBadgePosition
            };
            
            badge.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                e.preventDefault();
                orbitalDragState = badge._orbitalData;
                badge.style.cursor = 'grabbing';
                map.dragging.disable();
            });
            
            badge.addEventListener('touchstart', (e) => {
                e.stopPropagation();
                orbitalDragState = badge._orbitalData;
                badge.style.cursor = 'grabbing';
                map.dragging.disable();
            }, { passive: true });
        }
        
        // Global handlers for orbital badge dragging (added once, not per badge)
        document.addEventListener('mousemove', (e) => {
            if (!orbitalDragState) return;
            
            const center = orbitalDragState.getOrbitCenter();
            const angle = Math.atan2(e.clientY - center.y, e.clientX - center.x);
            orbitalDragState.updateBadgePosition(angle);
            badgeOrbitalAngles[orbitalDragState.photoIndex] = angle;
        });
        
        document.addEventListener('mouseup', () => {
            if (orbitalDragState) {
                const badge = document.querySelector(`.orbital-badge[style*="grabbing"]`);
                if (badge) badge.style.cursor = 'grab';
                map.dragging.enable();
                orbitalDragState = null;
            }
        });
        
        document.addEventListener('touchmove', (e) => {
            if (!orbitalDragState) return;
            const touch = e.touches[0];
            const center = orbitalDragState.getOrbitCenter();
            const angle = Math.atan2(touch.clientY - center.y, touch.clientX - center.x);
            orbitalDragState.updateBadgePosition(angle);
            badgeOrbitalAngles[orbitalDragState.photoIndex] = angle;
        }, { passive: true });
        
        document.addEventListener('touchend', () => {
            if (orbitalDragState) {
                map.dragging.enable();
                orbitalDragState = null;
            }
        });

        function setupPhotoMarkerInteraction(element, photo, index, leafletMarker, badgeMarker, updateRubberband, originalPosition) {
            const imgContainer = element.querySelector('.photo-marker-container');
            const img = element.querySelector('.photo-marker-img');
            if (!img || !imgContainer) return;

            const size = PHOTO_MARKER_SIZE;
            let scale = 1;
            let posX = 0;
            let posY = 0;
            let startX, startY, initialX, initialY;
            let baseScale = 1;
            let isMarkerDragging = false;
            let markerDragStartLatLng = null;

            function updateTransform() {
                img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
            }

            function saveTransform() {
                photoMarkerTransforms[index] = { scale, posX, posY, baseScale };
            }

            function applyInitialTransform() {
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const scaleX = size / imgWidth;
                const scaleY = size / imgHeight;
                baseScale = Math.max(scaleX, scaleY);

                // Restore saved transform or use defaults
                if (photoMarkerTransforms[index]) {
                    const saved = photoMarkerTransforms[index];
                    scale = saved.scale;
                    posX = saved.posX;
                    posY = saved.posY;
                } else {
                    scale = baseScale;
                    posX = (size - imgWidth * scale) / 2;
                    posY = (size - imgHeight * scale) / 2;
                }
                updateTransform();
            }

            if (img.complete && img.naturalWidth) {
                applyInitialTransform();
            } else {
                img.onload = applyInitialTransform;
            }

            // Store drag data on the image element for global handler
            img._photoMarkerData = {
                index,
                getState: () => ({ posX, posY, scale }),
                setState: (newPosX, newPosY) => { posX = newPosX; posY = newPosY; },
                updateTransform,
                saveTransform
            };

            // Update cursor based on Option key state
            // Default: grab (pan image), Alt held: move (drag marker)
            function updateCursor(altKey) {
                if (altKey) {
                    // Alt held: move the marker
                    element.style.cursor = 'move';
                    img.style.cursor = 'move';
                } else {
                    // Default: pan image within circle (hand cursor)
                    element.style.cursor = 'grab';
                    img.style.cursor = 'grab';
                }
            }

            // Listen for Alt key changes
            element.addEventListener('mouseenter', (e) => updateCursor(e.altKey));
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Alt' && element.matches(':hover')) {
                    updateCursor(true);
                }
            });
            document.addEventListener('keyup', (e) => {
                if (e.key === 'Alt' && element.matches(':hover')) {
                    updateCursor(false);
                }
            });

            // Disable context menu on photo markers (right-click is used for dragging)
            element.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });

            // Mousedown handler - Option/Alt key OR right-click determines behavior
            // Default: pan image, Alt held OR right-click: drag marker
            element.addEventListener('mousedown', (e) => {
                const isMarkerDragAction = e.altKey || e.button === 2;

                if (isMarkerDragAction) {
                    // Option key held OR right-click: drag the entire marker
                    isMarkerDragging = true;
                    markerDragStartLatLng = leafletMarker.getLatLng();
                    startX = e.clientX;
                    startY = e.clientY;

                    // Store data for global handler
                    photoMarkerDragState = {
                        isMarkerDrag: true,
                        leafletMarker,
                        badgeMarker,
                        updateRubberband,
                        originalPosition,
                        index,
                        startX,
                        startY,
                        startLatLng: markerDragStartLatLng
                    };

                    map.dragging.disable();
                    e.preventDefault();
                    e.stopPropagation();
                } else if (e.button === 0) {
                    // Left-click without Option key: pan image within the circle
                    startX = e.clientX;
                    startY = e.clientY;
                    initialX = posX;
                    initialY = posY;
                    photoMarkerDragState = {
                        isMarkerDrag: false,
                        img,
                        startX, startY,
                        initialX, initialY,
                        data: img._photoMarkerData
                    };
                    e.preventDefault();
                    e.stopPropagation();
                }
            });

            imgContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const delta = e.deltaY > 0 ? -0.008 : 0.008;
                const oldScale = scale;
                scale = Math.max(baseScale * 0.5, Math.min(5, scale + delta));

                // Zoom from center: adjust position by half the size change
                const imgWidth = img.naturalWidth;
                const imgHeight = img.naturalHeight;
                const oldWidth = imgWidth * oldScale;
                const oldHeight = imgHeight * oldScale;
                const newWidth = imgWidth * scale;
                const newHeight = imgHeight * scale;

                // Move top-left corner by half the difference (negative when growing)
                posX -= (newWidth - oldWidth) / 2;
                posY -= (newHeight - oldHeight) / 2;

                updateTransform();
                saveTransform();
            }, { passive: false });
        }

        // Global handlers for photo marker interactions (added once, not per marker)
        document.addEventListener('mousemove', (e) => {
            if (!photoMarkerDragState) return;

            if (photoMarkerDragState.isMarkerDrag) {
                // Dragging the entire marker (Alt/Option key held)
                const { leafletMarker, badgeMarker, updateRubberband, startX, startY, startLatLng } = photoMarkerDragState;

                // Convert pixel movement to lat/lng offset
                const startPoint = map.latLngToContainerPoint(startLatLng);
                const newPoint = L.point(
                    startPoint.x + (e.clientX - startX),
                    startPoint.y + (e.clientY - startY)
                );
                const newLatLng = map.containerPointToLatLng(newPoint);

                leafletMarker.setLatLng(newLatLng);
                if (badgeMarker) {
                    badgeMarker.setLatLng(newLatLng);
                }
                if (updateRubberband) {
                    updateRubberband();
                }
            } else {
                // Panning image within the circle
                const { startX, startY, initialX, initialY, data } = photoMarkerDragState;
                const newPosX = initialX + (e.clientX - startX);
                const newPosY = initialY + (e.clientY - startY);
                data.setState(newPosX, newPosY);
                data.updateTransform();
            }
        });

        document.addEventListener('mouseup', () => {
            if (photoMarkerDragState) {
                if (photoMarkerDragState.isMarkerDrag) {
                    // Save marker offset
                    const { leafletMarker, originalPosition, index } = photoMarkerDragState;
                    const newLatLng = leafletMarker.getLatLng();
                    photoMarkerOffsets[index] = {
                        lat: newLatLng.lat - originalPosition.lat,
                        lng: newLatLng.lng - originalPosition.lng
                    };
                    map.dragging.enable();
                } else {
                    // Save image transform
                    photoMarkerDragState.data.saveTransform();
                }
                photoMarkerDragState = null;
            }
        });

        function createSpiderCluster(cluster) {
            const center = cluster.center;
            const count = cluster.photos.length;
            
            // Calculate positions in a circle around center
            const angleStep = (2 * Math.PI) / count;
            
            cluster.photos.forEach((photoData, i) => {
                const angle = angleStep * i - Math.PI / 2; // Start from top
                
                // Convert pixel distance to approximate lat/lng offset
                const zoom = map.getZoom();
                const metersPerPixel = 156543.03392 * Math.cos(center.lat * Math.PI / 180) / Math.pow(2, zoom);
                const spiderDistance = PHOTO_MARKER_SIZE * 0.8 * SPIDER_SPREAD; // Scale with marker size and spread
                const offsetMeters = spiderDistance * metersPerPixel;
                
                // Rough conversion (1 degree latitude ‚âà 111,000 meters)
                const latOffset = (offsetMeters * Math.sin(angle)) / 111000;
                const lngOffset = (offsetMeters * Math.cos(angle)) / (111000 * Math.cos(center.lat * Math.PI / 180));
                
                const markerPos = {
                    lat: center.lat + latOffset,
                    lng: center.lng + lngOffset
                };
                
                // Draw spider leg
                const leg = L.polyline([
                    [center.lat, center.lng],
                    [markerPos.lat, markerPos.lng]
                ], {
                    color: '#667eea',
                    weight: 2,
                    opacity: 0.6,
                    dashArray: '4, 4'
                }).addTo(map);
                
                spiderLegs.push(leg);
                
                // Create photo marker
                createPhotoMarker(photoData, markerPos);
            });
            
            // Add center dot
            const centerDot = L.circleMarker([center.lat, center.lng], {
                radius: 5,
                fillColor: '#667eea',
                fillOpacity: 1,
                color: 'white',
                weight: 2
            }).addTo(map);
            
            spiderLegs.push(centerDot);
        }

        // Update spider positions on zoom
        function updateSpiderPositions() {
            if (!photoMarkersMode) return;
            
            // Recreate photo markers to recalculate spider positions
            showPhotoMarkers();
        }

        function showGallery() {
            galleryModal.classList.add('active');
            
            const galleryGrid = document.getElementById('galleryGrid');
            galleryGrid.innerHTML = '';
            
            const photosWithGPS = photos.filter(p => p.gps && p.gps.hasGPS);
            
            // Update gallery title with date range
            const photosWithDates = photosWithGPS.filter(p => p.gps && p.gps.dateTimeObj);
            let titleText = 'Gallery';
            if (photosWithDates.length > 0) {
                const dates = photosWithDates.map(p => p.gps.dateTimeObj);
                const minDate = new Date(Math.min(...dates));
                const maxDate = new Date(Math.max(...dates));
                
                if (minDate.toDateString() === maxDate.toDateString()) {
                    // Single date
                    titleText = 'Gallery: ' + formatBrisbaneDate(minDate);
                } else {
                    // Date range
                    titleText = 'Gallery: ' + formatBrisbaneDate(minDate) + ' ‚Äì ' + formatBrisbaneDate(maxDate);
                }
            }
            document.querySelector('#galleryModal .map-header h2').textContent = titleText;
            
            photosWithGPS.forEach((photo, index) => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                
                const number = document.createElement('div');
                number.className = 'gallery-number';
                number.textContent = index + 1;
                
                if (photo.src) {
                    const imgContainer = document.createElement('div');
                    imgContainer.style.width = '100%';
                    imgContainer.style.height = '100%';
                    imgContainer.style.overflow = 'hidden';
                    imgContainer.style.position = 'relative';
                    imgContainer.style.cursor = 'grab';
                    
                    const img = document.createElement('img');
                    img.src = photo.src;
                    img.alt = photo.name;
                    img.style.userSelect = 'none';
                    img.style.display = 'block';
                    
                    // START with object-fit cover for immediate display
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'cover';
                    img.style.objectPosition = 'center';
                    
                    // Interactive state
                    let scale = 1;
                    let posX = 0;
                    let posY = 0;
                    let isDragging = false;
                    let startX, startY, initialX, initialY;
                    let baseScale = 1;
                    let isTransformed = false;
                    
                    img.onload = function() {
                        const imgWidth = img.naturalWidth;
                        const imgHeight = img.naturalHeight;
                        const containerRect = imgContainer.getBoundingClientRect();
                        const containerWidth = containerRect.width;
                        const containerHeight = containerRect.height;
                        
                        // Calculate base scale for cover fit
                        const scaleX = containerWidth / imgWidth;
                        const scaleY = containerHeight / imgHeight;
                        baseScale = Math.max(scaleX, scaleY);
                        scale = baseScale;
                        
                        const scaledW = imgWidth * scale;
                        const scaledH = imgHeight * scale;
                        posX = (containerWidth - scaledW) / 2;
                        posY = (containerHeight - scaledH) / 2;
                    };
                    
                    function applyTransform() {
                        if (!isTransformed) {
                            // Switch to transform mode
                            img.style.objectFit = 'none';
                            img.style.width = 'auto';
                            img.style.height = 'auto';
                            img.style.position = 'absolute';
                            img.style.top = '0';
                            img.style.left = '0';
                            isTransformed = true;
                        }
                        img.style.transform = `translate(${posX}px, ${posY}px) scale(${scale})`;
                        img.style.transformOrigin = 'top left';
                        // Add sharpening to compensate for zoom blur
                        img.style.filter = 'contrast(1.05) saturate(1.05)';
                        img.style.imageRendering = 'crisp-edges';
                        img.style.imageRendering = '-webkit-optimize-contrast';
                    }
                    
                    // Mouse drag
                    imgContainer.addEventListener('mousedown', (e) => {
                        applyTransform();
                        isDragging = true;
                        startX = e.clientX;
                        startY = e.clientY;
                        initialX = posX;
                        initialY = posY;
                        imgContainer.style.cursor = 'grabbing';
                        e.preventDefault();
                    });
                    
                    document.addEventListener('mousemove', (e) => {
                        if (!isDragging) return;
                        const dx = e.clientX - startX;
                        const dy = e.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        applyTransform();
                    });
                    
                    document.addEventListener('mouseup', () => {
                        if (isDragging) {
                            isDragging = false;
                            imgContainer.style.cursor = 'grab';
                        }
                    });
                    
                    // Mouse wheel zoom - MUCH FINER increments
                    imgContainer.addEventListener('wheel', (e) => {
                        e.preventDefault();
                        applyTransform();
                        
                        const delta = e.deltaY > 0 ? -0.02 : 0.02; // Changed from 0.1 to 0.02 (5x finer)
                        const oldScale = scale;
                        scale = Math.max(baseScale * 0.5, Math.min(5, scale + delta));
                        
                        // Zoom toward mouse position
                        const rect = imgContainer.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        
                        posX = mouseX - (mouseX - posX) * (scale / oldScale);
                        posY = mouseY - (mouseY - posY) * (scale / oldScale);
                        
                        applyTransform();
                    }, { passive: false });
                    
                    // Touch support (passive: false because we use preventDefault)
                    imgContainer.addEventListener('touchstart', (e) => {
                        if (e.touches.length === 1) {
                            applyTransform();
                            isDragging = true;
                            const touch = e.touches[0];
                            startX = touch.clientX;
                            startY = touch.clientY;
                            initialX = posX;
                            initialY = posY;
                            e.preventDefault();
                        }
                    }, { passive: false });
                    
                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging || e.touches.length === 0) return;
                        const touch = e.touches[0];
                        const dx = touch.clientX - startX;
                        const dy = touch.clientY - startY;
                        posX = initialX + dx;
                        posY = initialY + dy;
                        applyTransform();
                    }, { passive: true });
                    
                    document.addEventListener('touchend', () => {
                        isDragging = false;
                    }, { passive: true });
                    
                    imgContainer.appendChild(img);
                    item.appendChild(imgContainer);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'gallery-item-placeholder';
                    placeholder.textContent = 'üì∏';
                    item.appendChild(placeholder);
                }
                
                item.appendChild(number);
                galleryGrid.appendChild(item);
            });
        }

        async function saveGalleryAsImage() {
            const saveBtn = document.getElementById('gallerySaveBtn');
            const galleryTitle = document.querySelector('#galleryModal .map-header h2')?.textContent || 'Gallery';
            
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));
            
            function safeFilename(s) {
                return (s || 'gallery')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .replace(/[^a-z0-9]+/gi, '_')
                    .replace(/^_+|_+$/g, '')
                    .toLowerCase() || 'gallery';
            }
            
            async function ensureScript(src, testFn, timeoutMs = 15000) {
                if (testFn()) return;
                
                const existing = Array.from(document.scripts).find(s => s.src === src);
                if (existing) {
                    const start = Date.now();
                    while (!testFn()) {
                        if (Date.now() - start > timeoutMs) throw new Error(`Timeout loading ${src}`);
                        await sleep(50);
                    }
                    return;
                }
                
                await new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = resolve;
                    s.onerror = reject;
                    document.head.appendChild(s);
                });
                
                const start = Date.now();
                while (!testFn()) {
                    if (Date.now() - start > timeoutMs) throw new Error(`Timeout initialising ${src}`);
                    await sleep(50);
                }
            }
            
            function downloadDataUrl(dataUrl, baseName) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `${baseName}.jpg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
            
            const prevBtnText = saveBtn?.textContent;
            if (saveBtn) {
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
            }
            
            const galleryWrapper = document.querySelector('#galleryModal .map-container-wrapper');
            const galleryContainer = document.getElementById('galleryContainer');
            const closeBtn = document.getElementById('closeGalleryButton');
            
            // Store original styles
            const restoreStyles = {
                saveBtnDisplay: saveBtn?.style.display,
                closeBtnDisplay: closeBtn?.style.display,
                containerOverflow: galleryContainer?.style.overflowY
            };
            
            try {
                // Hide UI elements for clean capture
                if (saveBtn) saveBtn.style.display = 'none';
                if (closeBtn) closeBtn.style.display = 'none';
                if (galleryContainer) galleryContainer.style.overflowY = 'hidden';
                
                // Use dom-to-image-more which properly handles object-fit
                await ensureScript(
                    'https://cdn.jsdelivr.net/npm/dom-to-image-more@3.4.5/dist/dom-to-image-more.min.js',
                    () => typeof window.domtoimage !== 'undefined'
                );

                // Wait for all images to be visible and loaded
                await sleep(500);

                const dataUrl = await window.domtoimage.toJpeg(galleryWrapper, {
                    quality: 0.92,
                    bgcolor: '#3c3c3c'
                });
                downloadDataUrl(dataUrl, safeFilename(galleryTitle));
                
            } catch (err) {
                console.error('Gallery save error:', err);
                alert('Failed to save gallery. Error: ' + err.message);
            } finally {
                // Restore UI elements
                if (saveBtn) saveBtn.style.display = restoreStyles.saveBtnDisplay || '';
                if (closeBtn) closeBtn.style.display = restoreStyles.closeBtnDisplay || '';
                if (galleryContainer) galleryContainer.style.overflowY = restoreStyles.containerOverflow || 'auto';
                
                if (saveBtn) {
                    saveBtn.disabled = false;
                    saveBtn.textContent = prevBtnText || 'Save as JPEG';
                }
            }
        }

        async function saveMapAsImage() {
            const mapSaveBtn = document.getElementById('mapSaveBtn');
            const mapPanelTitle = (document.getElementById('mapPanelTitle')?.textContent || 'map').trim();

            if (!map) return;

            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            function safeFilename(s) {
                return (s || 'map')
                    .replace(/\s+/g, ' ')
                    .trim()
                    .replace(/[^a-z0-9]+/gi, '_')
                    .replace(/^_+|_+$/g, '')
                    .toLowerCase() || 'map';
            }

            async function ensureScript(src, testFn, timeoutMs = 15000) {
                if (testFn()) return;

                const existing = Array.from(document.scripts).find(s => s.src === src);
                if (existing) {
                    const start = Date.now();
                    while (!testFn()) {
                        if (Date.now() - start > timeoutMs) throw new Error(`Timeout loading ${src}`);
                        await sleep(50);
                    }
                    return;
                }

                await new Promise((resolve, reject) => {
                    const s = document.createElement('script');
                    s.src = src;
                    s.async = true;
                    s.onload = resolve;
                    s.onerror = reject;
                    document.head.appendChild(s);
                });

                const start = Date.now();
                while (!testFn()) {
                    if (Date.now() - start > timeoutMs) throw new Error(`Timeout initialising ${src}`);
                    await sleep(50);
                }
            }

            async function waitForTileLayerLoad(timeoutMs = 9000) {
                try {
                    map.invalidateSize({ animate: false });
                } catch {
                    map.invalidateSize();
                }

                if (currentTileLayer && typeof currentTileLayer.once === 'function') {
                    await new Promise((resolve) => {
                        const timer = setTimeout(resolve, timeoutMs);
                        currentTileLayer.once('load', () => {
                            clearTimeout(timer);
                            resolve();
                        });
                    });
                }

                await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
                await sleep(600);
            }

            // Convert blob URL to base64 data URL
            async function blobUrlToDataUrl(blobUrl) {
                try {
                    const response = await fetch(blobUrl);
                    const blob = await response.blob();
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onloadend = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });
                } catch (err) {
                    console.warn('Failed to convert blob URL to data URL:', err);
                    return null;
                }
            }

            // Convert all blob URLs in photo marker images to data URLs for screenshot
            async function convertPhotoMarkersToDataUrls(container) {
                const images = container.querySelectorAll('.photo-marker-img');
                const conversions = [];

                for (const img of images) {
                    if (img.src && img.src.startsWith('blob:')) {
                        conversions.push({
                            img,
                            originalSrc: img.src,
                            promise: blobUrlToDataUrl(img.src)
                        });
                    }
                }

                // Wait for all conversions and apply them
                for (const conv of conversions) {
                    const dataUrl = await conv.promise;
                    if (dataUrl) {
                        conv.img.src = dataUrl;
                    }
                }

                // Return restoration function
                return () => {
                    for (const conv of conversions) {
                        conv.img.src = conv.originalSrc;
                    }
                };
            }

            function downloadDataUrl(dataUrl, baseName) {
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = `${baseName}.jpg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            const prevBtnText = mapSaveBtn?.textContent;
            if (mapSaveBtn) {
                mapSaveBtn.disabled = true;
                mapSaveBtn.textContent = 'Saving...';
            }

            const mapContainer = document.getElementById('mapContainer');
            const restore = {};
            const baseName = safeFilename(mapPanelTitle);

            let restorePhotoMarkers = null;

            try {
                // Handle 3D view differently - use Mapbox's canvas export
                if (is3DMode && map3d) {
                    await save3DMapAsImage(baseName);
                } else {
                    // 2D view - use dom-to-image-more
                    await ensureScript(
                        'https://cdn.jsdelivr.net/npm/dom-to-image-more@3.4.5/dist/dom-to-image-more.min.js',
                        () => typeof window.domtoimage !== 'undefined'
                    );

                    await waitForTileLayerLoad();

                    const zoomControls = mapContainer.querySelector('.leaflet-control-zoom');
                    const attribControls = mapContainer.querySelector('.leaflet-control-attribution');
                    if (zoomControls) { restore.zoomDisplay = zoomControls.style.display; zoomControls.style.display = 'none'; }
                    if (attribControls) { restore.attribDisplay = attribControls.style.display; attribControls.style.display = 'none'; }

                    // Hide slider controls during save
                    const markerSizeCtrl = document.getElementById('markerSizeControl');
                    const numberSizeCtrl = document.getElementById('numberMarkerSizeControl');
                    const spiderSpreadCtrl = document.getElementById('spiderSpreadControl');
                    if (markerSizeCtrl) { restore.markerSizeDisplay = markerSizeCtrl.style.display; markerSizeCtrl.style.display = 'none'; }
                    if (numberSizeCtrl) { restore.numberSizeDisplay = numberSizeCtrl.style.display; numberSizeCtrl.style.display = 'none'; }
                    if (spiderSpreadCtrl) { restore.spiderSpreadDisplay = spiderSpreadCtrl.style.display; spiderSpreadCtrl.style.display = 'none'; }

                    // Convert blob URLs to data URLs for photo markers (fixes CORS/tainted canvas issues)
                    restorePhotoMarkers = await convertPhotoMarkersToDataUrls(mapContainer);
                    await sleep(200);

                    // Force Leaflet to redraw canvas layers at current view
                    map.invalidateSize({ animate: false });
                    await sleep(100);

                    const dataUrl = await window.domtoimage.toJpeg(mapContainer, {
                        quality: 0.92,
                        filter: (node) => {
                            if (node.classList && (
                                node.classList.contains('leaflet-control-zoom') ||
                                node.classList.contains('leaflet-control-attribution'))) {
                                return false;
                            }
                            return true;
                        }
                    });

                    downloadDataUrl(dataUrl, baseName);
                }

            } catch (err) {
                console.error('saveMapAsImage failed:', err);
                alert('Failed to save map image. If you are using Satellite, the tile server may be blocking canvas export (CORS). Try Street/Cycle and retry.');
            } finally {
                // Restore blob URLs to photo markers
                if (restorePhotoMarkers) restorePhotoMarkers();

                const zoomControls = mapContainer.querySelector('.leaflet-control-zoom');
                const attribControls = mapContainer.querySelector('.leaflet-control-attribution');
                if (zoomControls) zoomControls.style.display = restore.zoomDisplay ?? '';
                if (attribControls) attribControls.style.display = restore.attribDisplay ?? '';

                // Restore slider controls
                const markerSizeCtrl = document.getElementById('markerSizeControl');
                const numberSizeCtrl = document.getElementById('numberMarkerSizeControl');
                const spiderSpreadCtrl = document.getElementById('spiderSpreadControl');
                if (markerSizeCtrl) markerSizeCtrl.style.display = restore.markerSizeDisplay ?? '';
                if (numberSizeCtrl) numberSizeCtrl.style.display = restore.numberSizeDisplay ?? '';
                if (spiderSpreadCtrl) spiderSpreadCtrl.style.display = restore.spiderSpreadDisplay ?? '';

                if (typeof monitorMapResize === 'function') monitorMapResize();
                if (map) {
                    try { map.invalidateSize({ animate: false }); } catch { map.invalidateSize(); }
                }

                if (mapSaveBtn) {
                    mapSaveBtn.disabled = false;
                    mapSaveBtn.textContent = prevBtnText || 'Save';
                }
            }
        }

        // Save 3D map using Mapbox's canvas export with markers overlay
        async function save3DMapAsImage(baseName) {
            const sleep = (ms) => new Promise(r => setTimeout(r, ms));

            // Wait for map to be fully rendered
            await new Promise(resolve => {
                if (map3d.loaded()) {
                    resolve();
                } else {
                    map3d.once('idle', resolve);
                }
            });
            await sleep(200);

            // Get the Mapbox canvas
            const mapCanvas = map3d.getCanvas();
            const pixelRatio = window.devicePixelRatio || 1;

            // Create a new canvas to composite map + markers
            const canvas = document.createElement('canvas');
            canvas.width = mapCanvas.width;
            canvas.height = mapCanvas.height;
            const ctx = canvas.getContext('2d');

            // Draw the map canvas
            ctx.drawImage(mapCanvas, 0, 0);

            // Get map container for position calculations
            const map3dContainer = document.getElementById('map3d');
            const containerRect = map3dContainer.getBoundingClientRect();

            // Draw number markers (from markers3d array)
            for (const marker of markers3d) {
                const el = marker.getElement();
                if (!el || el.style.display === 'none') continue;

                const markerDiv = el.classList.contains('marker-3d') ? el : el.querySelector('.marker-3d');
                if (!markerDiv) continue;

                const rect = markerDiv.getBoundingClientRect();
                const size = rect.width * pixelRatio;
                const centerX = (rect.left - containerRect.left + rect.width / 2) * pixelRatio;
                const centerY = (rect.top - containerRect.top + rect.height / 2) * pixelRatio;
                const radius = size / 2;

                ctx.save();

                // Gradient background
                const gradient = ctx.createLinearGradient(centerX - radius, centerY - radius, centerX + radius, centerY + radius);
                gradient.addColorStop(0, '#667eea');
                gradient.addColorStop(1, '#764ba2');

                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // White border
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3 * pixelRatio;
                ctx.stroke();

                // Number text
                const number = markerDiv.textContent;
                ctx.fillStyle = 'white';
                ctx.font = `bold ${size * 0.5}px -apple-system, BlinkMacSystemFont, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(number, centerX, centerY);

                ctx.restore();
            }

            // Draw photo balloon marker if visible
            if (activePhotoMarker3d) {
                const el = activePhotoMarker3d.getElement();
                if (el && el.style.display !== 'none') {
                    const popup = el.classList.contains('marker-3d-photo-popup') ? el : el.querySelector('.marker-3d-photo-popup');
                    if (popup) {
                        await draw3DPhotoPopupToCanvas(ctx, popup, containerRect, pixelRatio);
                    }
                }
            }

            // Convert canvas to JPEG data URL
            const dataUrl = canvas.toDataURL('image/jpeg', 0.92);

            // Download
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = `${baseName}.jpg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // Draw 3D photo popup (balloon with string) to canvas
        async function draw3DPhotoPopupToCanvas(ctx, popup, containerRect, pixelRatio) {
            // Find the photo circle (first div with border-radius: 50% inside animWrapper)
            const animWrapper = popup.firstElementChild;
            if (!animWrapper) return;

            const photoCircle = animWrapper.querySelector('div');
            if (!photoCircle) return;

            const circleRect = photoCircle.getBoundingClientRect();
            const circleSize = circleRect.width * pixelRatio;
            const circleX = (circleRect.left - containerRect.left) * pixelRatio;
            const circleY = (circleRect.top - containerRect.top) * pixelRatio;

            // Find and draw the string
            const stringEl = animWrapper.querySelector('div[style*="width: 3px"]');
            if (stringEl) {
                const stringRect = stringEl.getBoundingClientRect();
                const stringX = (stringRect.left - containerRect.left + stringRect.width / 2) * pixelRatio;
                const stringY = (stringRect.top - containerRect.top) * pixelRatio;
                const stringHeight = stringRect.height * pixelRatio;
                const stringWidth = 3 * pixelRatio;

                ctx.save();
                const stringGradient = ctx.createLinearGradient(stringX, stringY, stringX, stringY + stringHeight);
                stringGradient.addColorStop(0, 'rgba(102, 126, 234, 0.9)');
                stringGradient.addColorStop(1, 'rgba(118, 75, 162, 0.9)');
                ctx.fillStyle = stringGradient;
                ctx.fillRect(stringX - stringWidth / 2, stringY, stringWidth, stringHeight);

                // White outline for string
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 * pixelRatio;
                ctx.strokeRect(stringX - stringWidth / 2, stringY, stringWidth, stringHeight);
                ctx.restore();
            }

            // Draw the photo circle
            const img = photoCircle.querySelector('img');
            if (img && img.complete) {
                ctx.save();

                // Clip to circle for the photo
                ctx.beginPath();
                ctx.arc(circleX + circleSize / 2, circleY + circleSize / 2, circleSize / 2 - 3 * pixelRatio, 0, Math.PI * 2);
                ctx.clip();

                // Draw the image - handle transform if present
                const imgStyle = img.style.transform;
                if (imgStyle && imgStyle.includes('translate')) {
                    // Has custom transform from 2D editing
                    const translateMatch = imgStyle.match(/translate\(([-\d.]+)px,\s*([-\d.]+)px\)/);
                    const scaleMatch = imgStyle.match(/scale\(([-\d.]+)\)/);
                    const tx = translateMatch ? parseFloat(translateMatch[1]) * pixelRatio : 0;
                    const ty = translateMatch ? parseFloat(translateMatch[2]) * pixelRatio : 0;
                    const scale = scaleMatch ? parseFloat(scaleMatch[1]) : 1;

                    ctx.drawImage(img, circleX + tx, circleY + ty, img.naturalWidth * scale * pixelRatio, img.naturalHeight * scale * pixelRatio);
                } else {
                    // Default cover fit
                    ctx.drawImage(img, circleX, circleY, circleSize, circleSize);
                }

                ctx.restore();

                // Draw circle border
                ctx.save();
                ctx.beginPath();
                ctx.arc(circleX + circleSize / 2, circleY + circleSize / 2, circleSize / 2, 0, Math.PI * 2);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3 * pixelRatio;
                ctx.stroke();
                ctx.restore();
            }

            // Draw the number badge
            const badge = animWrapper.querySelector('div[style*="gradient"]');
            if (badge && badge !== photoCircle) {
                const badgeRect = badge.getBoundingClientRect();
                const badgeSize = badgeRect.width * pixelRatio;
                const badgeX = (badgeRect.left - containerRect.left) * pixelRatio;
                const badgeY = (badgeRect.top - containerRect.top) * pixelRatio;

                ctx.save();
                const badgeGradient = ctx.createLinearGradient(badgeX, badgeY, badgeX + badgeSize, badgeY + badgeSize);
                badgeGradient.addColorStop(0, '#667eea');
                badgeGradient.addColorStop(1, '#764ba2');

                ctx.beginPath();
                ctx.arc(badgeX + badgeSize / 2, badgeY + badgeSize / 2, badgeSize / 2, 0, Math.PI * 2);
                ctx.fillStyle = badgeGradient;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2 * pixelRatio;
                ctx.stroke();

                // Badge number
                const badgeNum = badge.textContent;
                ctx.fillStyle = 'white';
                ctx.font = `bold ${badgeSize * 0.5}px -apple-system, BlinkMacSystemFont, sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(badgeNum, badgeX + badgeSize / 2, badgeY + badgeSize / 2);
                ctx.restore();
            }
        }

        function clearAll() {
            if (photos.length === 0 && routes.length === 0) return;

            // Use double-click or shift-click for instant clear, otherwise show confirmation
            if (event && (event.detail === 2 || event.shiftKey)) {
                performClearAll();
                return;
            }

            // Show confirmation by changing button text temporarily
            const btn = document.getElementById('clearButton');
            if (btn.dataset.confirming === 'true') {
                // Second click - perform the clear
                btn.dataset.confirming = 'false';
                btn.textContent = 'Clear All';
                performClearAll();
            } else {
                // First click - ask for confirmation
                btn.dataset.confirming = 'true';
                btn.textContent = 'Confirm?';
                // Reset after 3 seconds if not confirmed
                setTimeout(() => {
                    if (btn.dataset.confirming === 'true') {
                        btn.dataset.confirming = 'false';
                        btn.textContent = 'Clear All';
                    }
                }, 3000);
            }
        }

        function performClearAll() {
            // Close any open popups
            closeAllPhotoPopups();

            // Revoke object URLs to free memory
            photos.forEach(photo => {
                if (photo.src) {
                    URL.revokeObjectURL(photo.src);
                }
            });

            // Reset data arrays
            photos = [];
            routes = [];
            selectedActivities.clear();
            photosWithUnsavedEdits.clear();
            highlightedPhotoName = null;
            copiedGPS = null;
            photoMarkerTransforms = {};
            badgeOrbitalAngles = {};
            photoMarkerOffsets = {};
            userHasInteractedWithMap = false;
            savedMapState = null;

            // Reset UI
            photosGrid.innerHTML = '';
            stats.style.display = 'none';
            clearStatus();
            document.getElementById('dateRangeStats').style.display = 'none';
            document.getElementById('routeStats').style.display = 'none';
            document.getElementById('routeFilterContainer').style.display = 'none';
            document.getElementById('activityCheckboxes').innerHTML = '';

            // Reset file inputs
            fileInput.value = '';
            routeInput.value = '';

            // Disable buttons
            showMapButton.disabled = true;
            showGalleryButton.disabled = true;
            clearButton.disabled = true;

            // Clear map if it exists
            if (map) {
                markers.forEach(marker => map.removeLayer(marker));
                markers = [];
                clearPhotoMarkers();
                resetPhotoMarkerTransforms();
                routePolylines.forEach(poly => {
                    poly.border.remove();
                    poly.line.remove();
                });
                routePolylines = [];
            }

            // Close modals
            mapModal.classList.remove('active');
            galleryModal.classList.remove('active');
        }

        let statusTimeout = null;

        function setStatus(message, duration = 0) {
            if (statusTimeout) {
                clearTimeout(statusTimeout);
                statusTimeout = null;
            }
            statusLine.textContent = message;
            if (duration > 0) {
                statusTimeout = setTimeout(() => {
                    statusLine.textContent = '';
                    statusTimeout = null;
                }, duration);
            }
        }

        function clearStatus() {
            if (statusTimeout) {
                clearTimeout(statusTimeout);
                statusTimeout = null;
            }
            statusLine.textContent = '';
        }

        // Legacy wrapper for compatibility
        function showError(message, type = 'error') {
            const duration = type === 'success' ? 4000 : 6000;
            setStatus(message, duration);
        }

        // Close map with Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && mapModal.classList.contains('active')) {
                closeAllPhotoPopups();
                clearPhotoMarkers();
                mapModal.classList.remove('active');
            }
        });
    </script>
</body>
</html>
